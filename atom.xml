<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云遇未晚</title>
  
  <subtitle>大自然的搬运工</subtitle>
  <link href="https://hexo.tryrun.top/atom.xml" rel="self"/>
  
  <link href="https://hexo.tryrun.top/"/>
  <updated>2023-06-11T08:09:22.111Z</updated>
  <id>https://hexo.tryrun.top/</id>
  
  <author>
    <name>云少</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二十九、C++ 接口（抽象类）</title>
    <link href="https://hexo.tryrun.top/posts/7886883d.html"/>
    <id>https://hexo.tryrun.top/posts/7886883d.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十九、C-接口（抽象类）"><a href="#二十九、C-接口（抽象类）" class="headerlink" title="二十九、C++ 接口（抽象类）"></a>二十九、C++ 接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p><p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p><p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p><p>可用于实例化对象的类被称为<strong>具体类</strong>。</p><h2 id="抽象类的实例"><a href="#抽象类的实例" class="headerlink" title="抽象类的实例"></a>抽象类的实例</h2><p>请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 提供接口框架的纯虚函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      width = w;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="type">int</span> width;</span><br><span class="line">   <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height)/<span class="number">2</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   Triangle  Tri;</span><br><span class="line"></span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   Tri.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Tri.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class="built_in">getArea</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total Rectangle area: 35</span><br><span class="line">Total Triangle area: 17</span><br></pre></td></tr></table></figure><p>从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。</p><h2 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h2><p>面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。</p><p>外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。</p><p>这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二十九、C-接口（抽象类）&quot;&gt;&lt;a href=&quot;#二十九、C-接口（抽象类）&quot; class=&quot;headerlink&quot; title=&quot;二十九、C++ 接口（抽象类）&quot;&gt;&lt;/a&gt;二十九、C++ 接口（抽象类）&lt;/h1&gt;&lt;p&gt;接口描述了类的行为和功能，而不需要完成类的特</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十、C++ 文件和流</title>
    <link href="https://hexo.tryrun.top/posts/90f0b145.html"/>
    <id>https://hexo.tryrun.top/posts/90f0b145.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十、C-文件和流"><a href="#三十、C-文件和流" class="headerlink" title="三十、C++ 文件和流"></a>三十、C++ 文件和流</h1><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p><p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ofstream</td><td align="center">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td></tr><tr><td align="center">ifstream</td><td align="center">该数据类型表示输入文件流，用于从文件读取信息。</td></tr><tr><td align="center">fstream</td><td align="center">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td></tr></tbody></table><p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。</p><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p><p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure><p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p><table><thead><tr><th align="center">模式标志</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ios::app</td><td align="center">追加模式。所有写入都追加到文件末尾。</td></tr><tr><td align="center">ios::ate</td><td align="center">文件打开后定位到文件末尾。</td></tr><tr><td align="center">ios::in</td><td align="center">打开文件用于读取。</td></tr><tr><td align="center">ios::out</td><td align="center">打开文件用于写入。</td></tr><tr><td align="center">ios::trunc</td><td align="center">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td></tr></tbody></table><p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure><p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fstream  afile;</span><br><span class="line">afile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p><p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p><h2 id="读取-amp-写入实例"><a href="#读取-amp-写入实例" class="headerlink" title="读取 &amp; 写入实例"></a>读取 &amp; 写入实例</h2><p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p><h2 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p><p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p><p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"></span><br><span class="line">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"></span><br><span class="line">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"></span><br><span class="line">// 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十、C-文件和流&quot;&gt;&lt;a href=&quot;#三十、C-文件和流&quot; class=&quot;headerlink&quot; title=&quot;三十、C++ 文件和流&quot;&gt;&lt;/a&gt;三十、C++ 文件和流&lt;/h1&gt;&lt;p&gt;到目前为止，我们已经使用了 &lt;strong&gt;iostream&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十一、C++ 异常处理</title>
    <link href="https://hexo.tryrun.top/posts/6f5dc425.html"/>
    <id>https://hexo.tryrun.top/posts/6f5dc425.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十一、C-异常处理"><a href="#三十一、C-异常处理" class="headerlink" title="三十一、C++ 异常处理"></a>三十一、C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p><ul><li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li><li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li><li><strong>try: try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li></ul><p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p><p>以下是尝试除以零时抛出异常的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Division by zero condition!</span><br></pre></td></tr></table></figure><h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的</p><p>下表是对上面层次结构中出现的每个异常的说明：</p><table><thead><tr><th align="center">异常</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>std::exception</strong></td><td align="center">该异常是所有标准 C++ 异常的父类。</td></tr><tr><td align="center">std::bad_alloc</td><td align="center">该异常可以通过 <strong>new</strong> 抛出。</td></tr><tr><td align="center">std::bad_cast</td><td align="center">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td></tr><tr><td align="center">std::bad_exception</td><td align="center">这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td align="center">std::bad_typeid</td><td align="center">该异常可以通过 <strong>typeid</strong> 抛出。</td></tr><tr><td align="center"><strong>std::logic_error</strong></td><td align="center">理论上可以通过读取代码来检测到的异常。</td></tr><tr><td align="center">std::domain_error</td><td align="center">当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td align="center">std::invalid_argument</td><td align="center">当使用了无效的参数时，会抛出该异常。</td></tr><tr><td align="center">std::length_error</td><td align="center">当创建了太长的 std::string 时，会抛出该异常。</td></tr><tr><td align="center">std::out_of_range</td><td align="center">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td></tr><tr><td align="center"><strong>std::runtime_error</strong></td><td align="center">理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td align="center">std::overflow_error</td><td align="center">当发生数学上溢时，会抛出该异常。</td></tr><tr><td align="center">std::range_error</td><td align="center">当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td align="center">std::underflow_error</td><td align="center">当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将产生以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyException caught</span><br><span class="line">C++ Exception</span><br></pre></td></tr></table></figure><p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十一、C-异常处理&quot;&gt;&lt;a href=&quot;#三十一、C-异常处理&quot; class=&quot;headerlink&quot; title=&quot;三十一、C++ 异常处理&quot;&gt;&lt;/a&gt;三十一、C++ 异常处理&lt;/h1&gt;&lt;p&gt;异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十二、C++ 动态内存</title>
    <link href="https://hexo.tryrun.top/posts/28fc4cb.html"/>
    <id>https://hexo.tryrun.top/posts/28fc4cb.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十二、C-动态内存"><a href="#三十二、C-动态内存" class="headerlink" title="三十二、C++ 动态内存"></a>三十二、C++ 动态内存</h1><p>了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：</p><ul><li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li><li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li></ul><p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p><p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p><p>如果您不需要动态分配内存，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p><h2 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h2><p>下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> data-type;</span><br></pre></td></tr></table></figure><p>在这里，<strong>data-type</strong> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 <strong>new</strong> 运算符来完成这点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br></pre></td></tr></table></figure><p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>( !(pvalue  = <span class="keyword">new</span> <span class="type">double</span> ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>malloc()</strong> 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p><p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pvalue;        <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure><p>下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">   pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line">   *pvalue = <span class="number">29494.99</span>;     <span class="comment">// 在分配的地址存储值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> pvalue;         <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of pvalue : <span class="number">29495</span></span><br></pre></td></tr></table></figure><h2 id="数组的动态内存分配"><a href="#数组的动态内存分配" class="headerlink" title="数组的动态内存分配"></a>数组的动态内存分配</h2><p>假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br></pre></td></tr></table></figure><p>要删除我们刚才创建的数组，语句如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pvalue;        <span class="comment">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure><p>下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ROW = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> COL = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> **pvalue  = <span class="keyword">new</span> <span class="type">double</span>* [ROW]; <span class="comment">// 为行分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为列分配内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; COL; i++) &#123;</span><br><span class="line">    pvalue[i] = <span class="keyword">new</span> <span class="type">double</span>[COL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放多维数组内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; COL; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pvalue[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] pvalue; </span><br></pre></td></tr></table></figure><h2 id="对象的动态内存分配"><a href="#对象的动态内存分配" class="headerlink" title="对象的动态内存分配"></a>对象的动态内存分配</h2><p>对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Box</span>() &#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;调用构造函数！&quot;</span> &lt;&lt;endl; </span><br><span class="line">      &#125;</span><br><span class="line">      ~<span class="built_in">Box</span>() &#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;调用析构函数！&quot;</span> &lt;&lt;endl; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box* myBoxArray = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> [] myBoxArray; <span class="comment">// Delete array</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。</p><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数！</span><br><span class="line">调用构造函数！</span><br><span class="line">调用构造函数！</span><br><span class="line">调用构造函数！</span><br><span class="line">调用析构函数！</span><br><span class="line">调用析构函数！</span><br><span class="line">调用析构函数！</span><br><span class="line">调用析构函数！</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十二、C-动态内存&quot;&gt;&lt;a href=&quot;#三十二、C-动态内存&quot; class=&quot;headerlink&quot; title=&quot;三十二、C++ 动态内存&quot;&gt;&lt;/a&gt;三十二、C++ 动态内存&lt;/h1&gt;&lt;p&gt;了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十三、C++ 命名空间</title>
    <link href="https://hexo.tryrun.top/posts/bb7dc1c7.html"/>
    <id>https://hexo.tryrun.top/posts/bb7dc1c7.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十三、C-命名空间"><a href="#三十三、C-命名空间" class="headerlink" title="三十三、C++ 命名空间"></a>三十三、C++ 命名空间</h1><p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p><p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</p><p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name &#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name::code;  // code 可以是变量或函数</span><br></pre></td></tr></table></figure><p>让我们来看看命名空间如何为变量或函数等实体定义范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   first_space::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   second_space::<span class="built_in">func</span>(); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure><h2 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h2><p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inside first_space</span><br></pre></td></tr></table></figure><p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;</span><br></pre></td></tr></table></figure><p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 <strong>std</strong> 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;std::endl is used with std!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::endl is used with std!</span><br></pre></td></tr></table></figure><p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p><h2 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h2><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p><p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h2><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">   <span class="keyword">namespace</span> namespace_name2 &#123;</span><br><span class="line">      <span class="comment">// 代码声明</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 namespace_name2 中的成员</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1::namespace_name2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 namespace:name1 中的成员</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> namespace_name1;</span><br></pre></td></tr></table></figure><p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 第二个命名空间</span></span><br><span class="line">   <span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> first_space::second_space;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inside second_space</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十三、C-命名空间&quot;&gt;&lt;a href=&quot;#三十三、C-命名空间&quot; class=&quot;headerlink&quot; title=&quot;三十三、C++ 命名空间&quot;&gt;&lt;/a&gt;三十三、C++ 命名空间&lt;/h1&gt;&lt;p&gt;假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十四、C++ 模板</title>
    <link href="https://hexo.tryrun.top/posts/f3d4f380.html"/>
    <id>https://hexo.tryrun.top/posts/f3d4f380.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十四、C-模板"><a href="#三十四、C-模板" class="headerlink" title="三十四、C++ 模板"></a>三十四、C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p><p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector</strong> 或 <strong>vector</strong> 。</p><p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板函数定义的一般形式如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; ret-type func-<span class="built_in">name</span>(parameter list)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p><p>下面是函数模板的实例，返回两个数中的最大值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">class</span> <span class="title class_">class</span>-name &#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p><p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    vector&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();      </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十四、C-模板&quot;&gt;&lt;a href=&quot;#三十四、C-模板&quot; class=&quot;headerlink&quot; title=&quot;三十四、C++ 模板&quot;&gt;&lt;/a&gt;三十四、C++ 模板&lt;/h1&gt;&lt;p&gt;模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十五、C++ 预处理器</title>
    <link href="https://hexo.tryrun.top/posts/2801a943.html"/>
    <id>https://hexo.tryrun.top/posts/2801a943.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十五、C-预处理器"><a href="#三十五、C-预处理器" class="headerlink" title="三十五、C++ 预处理器"></a>三十五、C++ 预处理器</h1><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p><p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p><p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p><p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。</p><h2 id="define-预处理"><a href="#define-预处理" class="headerlink" title="define 预处理"></a>define 预处理</h2><p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>，指令的一般形式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> macro-name replacement-text </span></span><br></pre></td></tr></table></figure><p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of PI :&quot;</span> &lt;&lt; PI &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$gcc -E test.cpp &gt; test.p</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of PI :&quot;</span> &lt;&lt; <span class="number">3.14159</span> &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a>函数宏</h2><p>您可以使用 #define 来定义一个带有参数的宏，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   i = <span class="number">100</span>;</span><br><span class="line">   j = <span class="number">30</span>;</span><br><span class="line">   cout &lt;&lt;<span class="string">&quot;The minimum is &quot;</span> &lt;&lt; <span class="built_in">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The minimum is 30</span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p><p>条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 <strong>cerr</strong> 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">   不进行编译的代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>让我们尝试下面的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   i = <span class="number">100</span>;</span><br><span class="line">   j = <span class="number">30</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">   <span class="comment">/* 这是注释部分 */</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   cout &lt;&lt;<span class="string">&quot;The minimum is &quot;</span> &lt;&lt; <span class="built_in">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Trace: Inside main function</span><br><span class="line">The minimum is 30</span><br><span class="line">Trace: Coming out of main function</span><br></pre></td></tr></table></figure><h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI&#x2F;ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p><p>请看下面的宏定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO C++</span><br></pre></td></tr></table></figure><p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl; </span><br></pre></td></tr></table></figure><p>转换成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;HELLO C++&quot; &lt;&lt; endl; </span><br></pre></td></tr></table></figure><p>## 运算符用于连接两个令牌。下面是一个实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONCAT( x, y )  x ## y</span><br></pre></td></tr></table></figure><p>当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> xy = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="built_in">concat</span>(x, y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; concat(x, y); </span><br></pre></td></tr></table></figure><p>转换成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; xy; </span><br></pre></td></tr></table></figure><h2 id="C-中的预定义宏"><a href="#C-中的预定义宏" class="headerlink" title="C++ 中的预定义宏"></a>C++ 中的预定义宏</h2><p>C++ 提供了下表所示的一些预定义宏：</p><table><thead><tr><th align="center">宏</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>LINE</strong></td><td align="center">这会在程序编译时包含当前行号。</td></tr><tr><td align="center"><strong>FILE</strong></td><td align="center">这会在程序编译时包含当前文件名。</td></tr><tr><td align="center"><strong>DATE</strong></td><td align="center">这会包含一个形式为 month&#x2F;day&#x2F;year 的字符串，它表示把源文件转换为目标代码的日期。</td></tr><tr><td align="center"><strong>TIME</strong></td><td align="center">这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</td></tr></tbody></table><p>让我们看看上述这些宏的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value of __LINE__ : 6</span><br><span class="line">Value of __FILE__ : test.cpp</span><br><span class="line">Value of __DATE__ : Feb 28 2011</span><br><span class="line">Value of __TIME__ : 18:52:48</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十五、C-预处理器&quot;&gt;&lt;a href=&quot;#三十五、C-预处理器&quot; class=&quot;headerlink&quot; title=&quot;三十五、C++ 预处理器&quot;&gt;&lt;/a&gt;三十五、C++ 预处理器&lt;/h1&gt;&lt;p&gt;预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十六、C++ 信号处理</title>
    <link href="https://hexo.tryrun.top/posts/7f48f714.html"/>
    <id>https://hexo.tryrun.top/posts/7f48f714.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十六、C-信号处理"><a href="#三十六、C-信号处理" class="headerlink" title="三十六、C++ 信号处理"></a>三十六、C++ 信号处理</h1><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p><p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。</p><table><thead><tr><th align="center">信号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SIGABRT</td><td align="center">程序的异常终止，如调用 <strong>abort</strong>。</td></tr><tr><td align="center">SIGFPE</td><td align="center">错误的算术运算，比如除以零或导致溢出的操作。</td></tr><tr><td align="center">SIGILL</td><td align="center">检测非法指令。</td></tr><tr><td align="center">SIGINT</td><td align="center">接收到交互注意信号。</td></tr><tr><td align="center">SIGSEGV</td><td align="center">非法访问内存。</td></tr><tr><td align="center">SIGTERM</td><td align="center">发送到程序的终止请求。</td></tr></tbody></table><h2 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal() 函数"></a>signal() 函数</h2><p>C++ 信号处理库提供了 <strong>signal</strong> 函数，用来捕获突发事件。以下是 signal() 函数的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span> (<span class="type">int</span> sig, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>); </span><br></pre></td></tr></table></figure><p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p><p>让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 <strong>signal</strong> 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">( <span class="type">int</span> signum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序  </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(signum);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br></pre></td></tr></table></figure><p>现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure><h2 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h2><p>您可以使用函数 <strong>raise()</strong> 生成信号，该函数带有一个整数信号编号作为参数，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span> <span class="params">(signal sig)</span></span>;</span><br></pre></td></tr></table></figure><p>在这里，<strong>sig</strong> 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">( <span class="type">int</span> signum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序 </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(signum);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(++i)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">if</span>( i == <span class="number">3</span> )&#123;</span><br><span class="line">          <span class="built_in">raise</span>( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十六、C-信号处理&quot;&gt;&lt;a href=&quot;#三十六、C-信号处理&quot; class=&quot;headerlink&quot; title=&quot;三十六、C++ 信号处理&quot;&gt;&lt;/a&gt;三十六、C++ 信号处理&lt;/h1&gt;&lt;p&gt;信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、L</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十七、C++ 多线程</title>
    <link href="https://hexo.tryrun.top/posts/fdda07c4.html"/>
    <id>https://hexo.tryrun.top/posts/fdda07c4.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十七、C-多线程"><a href="#三十七、C-多线程" class="headerlink" title="三十七、C++ 多线程"></a>三十七、C++ 多线程</h1><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。在一般情况下，有两种类型的多任务处理：基于进程和基于线程。</p><p>基于进程的多任务处理处理的是程序的并发执行。基于线程的多任务处理的是同一程序的片段的并发执行。</p><p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p><p>C++ 不包含多线程应用程序的任何内置支持。相反，它完全依赖于操作系统来提供此功能。</p><p>本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU&#x2F;Linux、Mac OS X 和 Solaris。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>有下面的例程，我们可以用它来创建一个 POSIX 线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_create</span> (thread, attr, start_routine, arg) </span><br></pre></td></tr></table></figure><p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。这个例程可在代码内的任何地方被调用任意次数。下面是关于参数的说明：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">thread</td><td align="center">一个不透明的、唯一的标识符，用来标识例程返回的新线程。</td></tr><tr><td align="center">attr</td><td align="center">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td></tr><tr><td align="center">start_routine</td><td align="center">C++ 例程，一旦线程被创建就会执行。</td></tr><tr><td align="center">arg</td><td align="center">一个可能传递给 start_routine 的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td></tr></tbody></table><p>一个进程可以创建的最大线程数是依赖于实现的。线程一旦被创建，就是同等的，而且可以创建其他线程。线程之间没有隐含层次或依赖。</p><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>有下面的例程，我们可以用它来终止一个 POSIX 线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="built_in">pthread_exit</span> (status) </span><br></pre></td></tr></table></figure><p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 例程是在线程完成工作后无需继续存在时被调用。</p><p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>这个简单的实例代码使用 pthread_create() 例程创建了 5 个线程。每个线程打印一个 “Hello World!” 消息，然后调用 pthread_exit() 终止线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 必须的头文件是</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的运行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">say_hello</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello w3cschool！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class="line">    <span class="type">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">NULL</span>, say_hello, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 -lpthread 库编译下面的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o</span><br></pre></td></tr></table></figure><p>现在，执行程序，将产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.o</span><br><span class="line">Hello w3cschool！</span><br><span class="line">Hello w3cschool！</span><br><span class="line">Hello w3cschool！</span><br><span class="line">Hello w3cschool！</span><br><span class="line">Hello w3cschool！</span><br></pre></td></tr></table></figure><p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello w3cschool！” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名：test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="type">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">   <span class="type">int</span> tid = *((<span class="type">int</span>*)threadid);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello w3cschool！线程 ID, &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="type">int</span> indexes[NUM_THREADS];<span class="comment">// 用数组来保存i的值</span></span><br><span class="line">   <span class="type">int</span> rc;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : 创建线程, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line">      <span class="comment">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, </span><br><span class="line">                          PrintHello, (<span class="type">void</span> *)&amp;(indexes[i]));</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在编译并执行程序，将产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : 创建线程, 0</span><br><span class="line">main() : 创建线程, 1</span><br><span class="line">main() : 创建线程, 2</span><br><span class="line">main() : 创建线程, 3</span><br><span class="line">main() : 创建线程, 4</span><br><span class="line">Hello w3cschool! 线程 ID, 4</span><br><span class="line">Hello w3cschool! 线程 ID, 3</span><br><span class="line">Hello w3cschool! 线程 ID, 2</span><br><span class="line">Hello w3cschool! 线程 ID, 1</span><br><span class="line">Hello w3cschool! 线程 ID, 0</span><br></pre></td></tr></table></figure><p>向线程传递参数</p><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_data</span>&#123;</span><br><span class="line">   <span class="type">int</span>  thread_id;</span><br><span class="line">   <span class="type">char</span> *message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="type">void</span> *threadarg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">thread_data</span> *my_data;</span><br><span class="line"></span><br><span class="line">   my_data = (<span class="keyword">struct</span> thread_data *) threadarg;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Thread ID : &quot;</span> &lt;&lt; my_data-&gt;thread_id ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot; Message : &quot;</span> &lt;&lt; my_data-&gt;message &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">thread_data</span> td[NUM_THREADS];</span><br><span class="line">   <span class="type">int</span> rc;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      td[i].thread_id = i;</span><br><span class="line">      td[i].message = <span class="string">&quot;This is message&quot;</span>;</span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>,</span><br><span class="line">                          PrintHello, (<span class="type">void</span> *)&amp;td[i]);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wno-write-strings test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Thread ID : 3 Message : This is message</span><br><span class="line">Thread ID : 2 Message : This is message</span><br><span class="line">Thread ID : 0 Message : This is message</span><br><span class="line">Thread ID : 1 Message : This is message</span><br><span class="line">Thread ID : 4 Message : This is message</span><br></pre></td></tr></table></figure><h2 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h2><p>有以下两个例程，我们可以用它们来连接或分离线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_join (threadid, status) </span><br><span class="line">pthread_detach (threadid) </span><br></pre></td></tr></table></figure><p>pthread_join() 子例程阻碍调用例程，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p><p>这个实例演示了如何使用 pthread_join() 例程来等待线程的完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">wait</span><span class="params">(<span class="type">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">long</span> tid;</span><br><span class="line"></span><br><span class="line">   tid = (<span class="type">long</span>)t;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> rc;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">   <span class="type">void</span> *status;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class="line">   <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">   <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, wait, (<span class="type">void</span> *)i );</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除属性，并等待其他线程</span></span><br><span class="line">   <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = <span class="built_in">pthread_join</span>(threads[i], &amp;status);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 4  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 3  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 2  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 1  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十七、C-多线程&quot;&gt;&lt;a href=&quot;#三十七、C-多线程&quot; class=&quot;headerlink&quot; title=&quot;三十七、C++ 多线程&quot;&gt;&lt;/a&gt;三十七、C++ 多线程&lt;/h1&gt;&lt;p&gt;多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十八、C++ Web 编程</title>
    <link href="https://hexo.tryrun.top/posts/f8d660b9.html"/>
    <id>https://hexo.tryrun.top/posts/f8d660b9.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十八、C-Web-编程"><a href="#三十八、C-Web-编程" class="headerlink" title="三十八、C++ Web 编程"></a>三十八、C++ Web 编程</h1><h2 id="什么是-CGI？"><a href="#什么是-CGI？" class="headerlink" title="什么是 CGI？"></a>什么是 CGI？</h2><ul><li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li><li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li><li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li><li>目前的版本是 CGI&#x2F;1.1，CGI&#x2F;1.2 版本正在推进中。</li></ul><h2 id="Web-浏览"><a href="#Web-浏览" class="headerlink" title="Web 浏览"></a>Web 浏览</h2><p>为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。</p><ul><li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li><li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li><li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li></ul><p>然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。</p><p>公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。</p><h2 id="Web-服务器配置"><a href="#Web-服务器配置" class="headerlink" title="Web 服务器配置"></a>Web 服务器配置</h2><p>在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 &#x2F;var&#x2F;www&#x2F;cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 <strong>.cgi</strong>。</p><p>默认情况下，Apache Web 服务器会配置在 &#x2F;var&#x2F;www&#x2F;cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Directory</span> &quot;/<span class="attr">var</span>/<span class="attr">www</span>/<span class="attr">cgi-bin</span>&quot;&gt;</span></span><br><span class="line">   AllowOverride None</span><br><span class="line">   Options ExecCGI</span><br><span class="line">   Order allow,deny</span><br><span class="line">   Allow from all</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Directory</span> &quot;/<span class="attr">var</span>/<span class="attr">www</span>/<span class="attr">cgi-bin</span>&quot;&gt;</span></span><br><span class="line">Options All</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。</p><h2 id="第一个-CGI-程序"><a href="#第一个-CGI-程序" class="headerlink" title="第一个 CGI 程序"></a>第一个 CGI 程序</h2><p>请看下面的 C++ 程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;    cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;Hello World - 第一个 CGI 程序&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;h2&gt;Hello World! 这是我的第一个 CGI 程序&lt;/h2&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 &#x2F;var&#x2F;www&#x2F;cgi-bin 目录中。在运行 CGI 程序之前，请使用 <strong>chmod 755 cplusplus.cgi</strong> UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：</p><h2 id="Hello-World-这是我的第一个-CGI-程序"><a href="#Hello-World-这是我的第一个-CGI-程序" class="headerlink" title="Hello World! 这是我的第一个 CGI 程序"></a>Hello World! 这是我的第一个 CGI 程序</h2><p>上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 <strong>Content-type:text&#x2F;html\r\n\r\n</strong>。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。</p><h2 id="HTTP-头信息"><a href="#HTTP-头信息" class="headerlink" title="HTTP 头信息"></a>HTTP 头信息</h2><p>行 <strong>Content-type:text&#x2F;html\r\n\r\n</strong> 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP 字段名称: 字段内容</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line">Content-type: text/html\r\n\r\n</span><br></pre></td></tr></table></figure><p>还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。</p><table><thead><tr><th align="center">头信息</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Content-type:</td><td align="center">MIME 字符串，定义返回的文件格式。例如 Content-type:text&#x2F;html。</td></tr><tr><td align="center">Expires: Date</td><td align="center">信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td></tr><tr><td align="center">Location: URL</td><td align="center">这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td></tr><tr><td align="center">Last-modified: Date</td><td align="center">资源的最后修改日期。</td></tr><tr><td align="center">Content-length: N</td><td align="center">要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td></tr><tr><td align="center">Set-Cookie: String</td><td align="center">通过 <em>string</em> 设置 cookie。</td></tr></tbody></table><h2 id="CGI-环境变量"><a href="#CGI-环境变量" class="headerlink" title="CGI 环境变量"></a>CGI 环境变量</h2><p>所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。</p><table><thead><tr><th align="center">变量名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONTENT_TYPE</td><td align="center">内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td></tr><tr><td align="center">CONTENT_LENGTH</td><td align="center">查询的信息长度。只对 POST 请求可用。</td></tr><tr><td align="center">HTTP_COOKIE</td><td align="center">以键 &amp; 值对的形式返回设置的 cookies。</td></tr><tr><td align="center">HTTP_USER_AGENT</td><td align="center">用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td></tr><tr><td align="center">PATH_INFO</td><td align="center">CGI 脚本的路径。</td></tr><tr><td align="center">QUERY_STRING</td><td align="center">通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td></tr><tr><td align="center">REMOTE_ADDR</td><td align="center">发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td></tr><tr><td align="center">REMOTE_HOST</td><td align="center">发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td></tr><tr><td align="center">REQUEST_METHOD</td><td align="center">用于发出请求的方法。最常见的方法是 GET 和 POST。</td></tr><tr><td align="center">SCRIPT_FILENAME</td><td align="center">CGI 脚本的完整路径。</td></tr><tr><td align="center">SCRIPT_NAME</td><td align="center">CGI 脚本的名称。</td></tr><tr><td align="center">SERVER_NAME</td><td align="center">服务器的主机名或 IP 地址。</td></tr><tr><td align="center">SERVER_SOFTWARE</td><td align="center">服务器上运行的软件的名称和版本。</td></tr></tbody></table><p>下面的 CGI 程序列出了所有的 CGI 变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string ENV[ <span class="number">24</span> ] = &#123;                 </span><br><span class="line">        <span class="string">&quot;COMSPEC&quot;</span>, <span class="string">&quot;DOCUMENT_ROOT&quot;</span>, <span class="string">&quot;GATEWAY_INTERFACE&quot;</span>,   </span><br><span class="line">        <span class="string">&quot;HTTP_ACCEPT&quot;</span>, <span class="string">&quot;HTTP_ACCEPT_ENCODING&quot;</span>,             </span><br><span class="line">        <span class="string">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>, <span class="string">&quot;HTTP_CONNECTION&quot;</span>,         </span><br><span class="line">        <span class="string">&quot;HTTP_HOST&quot;</span>, <span class="string">&quot;HTTP_USER_AGENT&quot;</span>, <span class="string">&quot;PATH&quot;</span>,            </span><br><span class="line">        <span class="string">&quot;QUERY_STRING&quot;</span>, <span class="string">&quot;REMOTE_ADDR&quot;</span>, <span class="string">&quot;REMOTE_PORT&quot;</span>,      </span><br><span class="line">        <span class="string">&quot;REQUEST_METHOD&quot;</span>, <span class="string">&quot;REQUEST_URI&quot;</span>, <span class="string">&quot;SCRIPT_FILENAME&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SCRIPT_NAME&quot;</span>, <span class="string">&quot;SERVER_ADDR&quot;</span>, <span class="string">&quot;SERVER_ADMIN&quot;</span>,      </span><br><span class="line">        <span class="string">&quot;SERVER_NAME&quot;</span>,<span class="string">&quot;SERVER_PORT&quot;</span>,<span class="string">&quot;SERVER_PROTOCOL&quot;</span>,     </span><br><span class="line">        <span class="string">&quot;SERVER_SIGNATURE&quot;</span>,<span class="string">&quot;SERVER_SOFTWARE&quot;</span> &#125;;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 环境变量&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;table border = \&quot;0\&quot; cellspacing = \&quot;2\&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; ENV[ i ] &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class="line">       <span class="comment">// 尝试检索环境变量的值</span></span><br><span class="line">       <span class="type">char</span> *value = <span class="built_in">getenv</span>( ENV[ i ].<span class="built_in">c_str</span>() );  </span><br><span class="line">       <span class="keyword">if</span> ( value != <span class="number">0</span> )&#123;</span><br><span class="line">         cout &lt;&lt; value;                                 </span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;环境变量不存在。&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/table&gt;&lt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-CGI-库"><a href="#C-CGI-库" class="headerlink" title="C++ CGI 库"></a>C++ CGI 库</h2><p>在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 <a href="ftp://ftp.gnu.org/gnu/cgicc/">ftp://ftp.gnu.org/gnu/cgicc/</a> 上下载这个 CGI 库，并按照下面的步骤安装库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$tar xzf cgicc-X.X.X.tar.gz </span><br><span class="line">$cd cgicc-X.X.X/ </span><br><span class="line">$./configure --prefix=/usr </span><br><span class="line">$make</span><br><span class="line">$make install</span><br></pre></td></tr></table></figure><p>您可以点击 C++ CGI Lib Documentation，查看相关的库文档。</p><h2 id="GET-和-POST-方法"><a href="#GET-和-POST-方法" class="headerlink" title="GET 和 POST 方法"></a>GET 和 POST 方法</h2><p>您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。</p><h2 id="使用-GET-方法传递信息"><a href="#使用-GET-方法传递信息" class="headerlink" title="使用 GET 方法传递信息"></a>使用 GET 方法传递信息</h2><p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure><p>GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。</p><p>当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。</p><p>您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML</p><p>标签的 GET 方法来传信息。</p><h2 id="简单的-URL-实例：Get-方法"><a href="#简单的-URL-实例：Get-方法" class="headerlink" title="简单的 URL 实例：Get 方法"></a>简单的 URL 实例：Get 方法</h2><p>下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。</p><p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p><p>下面的实例生成 <strong>cpp_get.cgi</strong> CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc formData;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;使用 GET 和 POST 方法&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;first_name&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;名：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No text entered for first name&quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;last_name&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp;fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;姓：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No text entered for last name&quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，编译上面的程序，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc</span><br></pre></td></tr></table></figure><p>生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：</p><p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p><p>这会产生以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名：ZARA </span><br><span class="line">姓：ALI </span><br></pre></td></tr></table></figure><h2 id="简单的表单实例：GET-方法"><a href="#简单的表单实例：GET-方法" class="headerlink" title="简单的表单实例：GET 方法"></a>简单的表单实例：GET 方法</h2><p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_get.cgi&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;first_name&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;last_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。</p><h2 id="使用-POST-方法传递信息"><a href="#使用-POST-方法传递信息" class="headerlink" title="使用 POST 方法传递信息"></a>使用 POST 方法传递信息</h2><p>一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。</p><p>我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_get.cgi&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;first_name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;last_name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="向-CGI-程序传递复选框数据"><a href="#向-CGI-程序传递复选框数据" class="headerlink" title="向 CGI 程序传递复选框数据"></a>向 CGI 程序传递复选框数据</h2><p>当需要选择多个选项时，我们使用复选框。</p><p>下面的 HTML 代码实例是一个带有两个复选框的表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_checkbox.cgi&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;maths&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 数学</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;physics&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 物理</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;选择学科&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc formData;</span><br><span class="line">   <span class="type">bool</span> maths_flag, physics_flag;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递复选框数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   maths_flag = formData.<span class="built_in">queryCheckbox</span>(<span class="string">&quot;maths&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>( maths_flag ) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Maths Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Maths Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   physics_flag = formData.<span class="built_in">queryCheckbox</span>(<span class="string">&quot;physics&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>( physics_flag ) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Physics Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Physics Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向-CGI-程序传递单选按钮数据"><a href="#向-CGI-程序传递单选按钮数据" class="headerlink" title="向 CGI 程序传递单选按钮数据"></a>向 CGI 程序传递单选按钮数据</h2><p>当只需要选择一个选项时，我们使用单选按钮。</p><p>下面的 HTML 代码实例是一个带有两个单选按钮的表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_radiobutton.cgi&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;maths&quot;</span> </span></span><br><span class="line"><span class="tag">                                    <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>/&gt;</span> 数学 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;physics&quot;</span> /&gt;</span> 物理</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;选择学科&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc formData;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递单选按钮数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;subject&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Radio box selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向-CGI-程序传递文本区域数据"><a href="#向-CGI-程序传递文本区域数据" class="headerlink" title="向 CGI 程序传递文本区域数据"></a>向 CGI 程序传递文本区域数据</h2><p>当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。</p><p>下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_textarea.cgi&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;textcontent&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;40&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">请在这里输入文本...</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc formData;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递文本区域数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;textcontent&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Text Content: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No text entered&quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向-CGI-程序传递下拉框数据"><a href="#向-CGI-程序传递下拉框数据" class="headerlink" title="向 CGI 程序传递下拉框数据"></a>向 CGI 程序传递下拉框数据</h2><p>当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。</p><p>下面的 HTML 代码实例是一个带有下拉框的表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_dropdown.cgi&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;dropdown&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Maths&quot;</span> <span class="attr">selected</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Physics&quot;</span>&gt;</span>物理<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc formData;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递下拉框数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;dropdown&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Value Selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-CGI-中使用-Cookies"><a href="#在-CGI-中使用-Cookies" class="headerlink" title="在 CGI 中使用 Cookies"></a>在 CGI 中使用 Cookies</h2><p>HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。</p><p>在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p><h3 id="它是如何工作的"><a href="#它是如何工作的" class="headerlink" title="它是如何工作的"></a>它是如何工作的</h3><p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p><p>cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：</p><ul><li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li><li><strong>Domain :</strong> 网站的域名。</li><li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li><li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li><li><strong>Name&#x3D;Value :</strong> cookie 以键值对的形式被设置和获取。</li></ul><h3 id="设置-Cookies"><a href="#设置-Cookies" class="headerlink" title="设置 Cookies"></a>设置 Cookies</h3><p>向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:UserID=XYZ;\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:Password=XYZ123;\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:Domain=www.w3cschool.cn;\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:Path=/perl;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;设置 cookies&quot;</span> &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个实例中，我们了解了如何设置 cookies。我们使用 <strong>Set-Cookie</strong> HTTP 头来设置 cookies。</p><p>在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 <strong>“Content-type:text&#x2F;html\r\n\r\n</strong> 之前被设置的。</p><p>编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：</p><p>&#x2F;cgi-bin&#x2F;setcookies.cgi</p><h3 id="获取-Cookies"><a href="#获取-Cookies" class="headerlink" title="获取 Cookies"></a>获取 Cookies</h3><p>检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key1=value1;key2=value2;key3=value3....</span><br></pre></td></tr></table></figure><p>下面的实例演示了如何获取 cookies。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc cgi;</span><br><span class="line">   const_cookie_iterator cci;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;table border = \&quot;0\&quot; cellspacing = \&quot;2\&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取环境变量</span></span><br><span class="line">   <span class="type">const</span> CgiEnvironment&amp; env = cgi.<span class="built_in">getEnvironment</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( cci = env.<span class="built_in">getCookieList</span>().<span class="built_in">begin</span>();</span><br><span class="line">        cci != env.<span class="built_in">getCookieList</span>().<span class="built_in">end</span>(); </span><br><span class="line">        ++cci )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; cci-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class="line">      cout &lt;&lt; cci-&gt;<span class="built_in">getValue</span>();                                 </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/table&gt;&lt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：</p><p>&#x2F;cgi-bin&#x2F;getcookies.cgi</p><p>这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserID XYZ </span><br><span class="line">Password XYZ123 </span><br><span class="line">Domain www.w3cschool.cn </span><br><span class="line">Path /perl </span><br></pre></td></tr></table></figure><h2 id="文件上传实例"><a href="#文件上传实例" class="headerlink" title="文件上传实例"></a>文件上传实例</h2><p>为了上传一个文件，HTML 表单必须把 enctype 属性设置为 <strong>multipart&#x2F;form-data</strong>。带有文件类型的 input 标签会创建一个 “Browse” 按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_uploadfile.cgi&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userfile&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>您可以在自己的服务器上尝试上面的代码。</p><p>下面是用于处理文件上传的脚本 <strong>cpp_uploadfile.cpp</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cgicc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Cgicc cgi;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 中的文件上传&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取要被上传的文件列表</span></span><br><span class="line">   const_file_iterator file = cgi.<span class="built_in">getFile</span>(<span class="string">&quot;userfile&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(file != cgi.<span class="built_in">getFiles</span>().<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// 在 cout 中发送数据类型</span></span><br><span class="line">      cout &lt;&lt; <span class="built_in">HTTPContentHeader</span>(file-&gt;<span class="built_in">getDataType</span>());</span><br><span class="line">      <span class="comment">// 在 cout 中写入内容</span></span><br><span class="line">      file-&gt;<span class="built_in">writeToStream</span>(cout);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;文件上传成功&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例是在 <strong>cout</strong> 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十八、C-Web-编程&quot;&gt;&lt;a href=&quot;#三十八、C-Web-编程&quot; class=&quot;headerlink&quot; title=&quot;三十八、C++ Web 编程&quot;&gt;&lt;/a&gt;三十八、C++ Web 编程&lt;/h1&gt;&lt;h2 id=&quot;什么是-CGI？&quot;&gt;&lt;a href=&quot;#什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>三十九、C++ STL 教程</title>
    <link href="https://hexo.tryrun.top/posts/b694d422.html"/>
    <id>https://hexo.tryrun.top/posts/b694d422.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十九、C-STL-教程"><a href="#三十九、C-STL-教程" class="headerlink" title="三十九、C++ STL 教程"></a>三十九、C++ STL 教程</h1><p>在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p><p>C++ 标准模板库的核心包括以下三个组件：</p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">容器（Containers）</td><td align="center">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td align="center">算法（Algorithms）</td><td align="center">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td align="center">迭代器（terators）</td><td align="center">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td></tr></tbody></table><p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。</p><p>下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec; </span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector size = 0</span><br><span class="line">extended vector size = 5</span><br><span class="line">value of vec [0] = 0</span><br><span class="line">value of vec [1] = 1</span><br><span class="line">value of vec [2] = 2</span><br><span class="line">value of vec [3] = 3</span><br><span class="line">value of vec [4] = 4</span><br><span class="line">value of v = 0</span><br><span class="line">value of v = 1</span><br><span class="line">value of v = 2</span><br><span class="line">value of v = 3</span><br><span class="line">value of v = 4</span><br></pre></td></tr></table></figure><p>关于上面实例中所使用的各种函数，有几点要注意：</p><ul><li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li><li>size( ) 函数显示向量的大小。</li><li>begin( ) 函数返回一个指向向量开头的迭代器。</li><li>end( ) 函数返回一个指向向量末尾的迭代器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十九、C-STL-教程&quot;&gt;&lt;a href=&quot;#三十九、C-STL-教程&quot; class=&quot;headerlink&quot; title=&quot;三十九、C++ STL 教程&quot;&gt;&lt;/a&gt;三十九、C++ STL 教程&lt;/h1&gt;&lt;p&gt;在前面的章节中，我们已经学习了 C++ 模板的概念。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十、C++ 标准库</title>
    <link href="https://hexo.tryrun.top/posts/bbbcd56b.html"/>
    <id>https://hexo.tryrun.top/posts/bbbcd56b.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十、C-标准库"><a href="#四十、C-标准库" class="headerlink" title="四十、C++ 标准库"></a>四十、C++ 标准库</h1><p>C++ 标准库可以分为两部分：</p><ul><li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li><li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li></ul><p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p><h2 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h2><p>标准函数库分为以下几类：</p><ul><li>输入&#x2F;输出 I&#x2F;O</li><li>字符串和字符处理</li><li>数学</li><li>时间、日期和本地化</li><li>动态分配</li><li>其他</li><li>宽字符函数</li></ul><h2 id="面向对象类库"><a href="#面向对象类库" class="headerlink" title="面向对象类库"></a>面向对象类库</h2><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p><ul><li>标准的 C++ I&#x2F;O 类</li><li>String 类</li><li>数值类</li><li>STL 容器类</li><li>STL 算法</li><li>STL 函数对象</li><li>STL 迭代器</li><li>STL 分配器</li><li>本地化库</li><li>异常处理类</li><li>杂项支持库</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十、C-标准库&quot;&gt;&lt;a href=&quot;#四十、C-标准库&quot; class=&quot;headerlink&quot; title=&quot;四十、C++ 标准库&quot;&gt;&lt;/a&gt;四十、C++ 标准库&lt;/h1&gt;&lt;p&gt;C++ 标准库可以分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标准函数库</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十一、C++ 有用的资源</title>
    <link href="https://hexo.tryrun.top/posts/43948d17.html"/>
    <id>https://hexo.tryrun.top/posts/43948d17.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十一、C-有用的资源"><a href="#四十一、C-有用的资源" class="headerlink" title="四十一、C++ 有用的资源"></a>四十一、C++ 有用的资源</h1><ul><li>C++ Programming Language Tutorials − C++ 编程语言教程。</li><li>C++ Programming − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。</li><li>C++ FAQ − C++ 常见问题</li><li>Free Country − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。</li><li>C and C++ Users Group − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十一、C-有用的资源&quot;&gt;&lt;a href=&quot;#四十一、C-有用的资源&quot; class=&quot;headerlink&quot; title=&quot;四十一、C++ 有用的资源&quot;&gt;&lt;/a&gt;四十一、C++ 有用的资源&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;C++ Programming Language</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十二、20道必须掌握的C++面试题</title>
    <link href="https://hexo.tryrun.top/posts/cf4e807d.html"/>
    <id>https://hexo.tryrun.top/posts/cf4e807d.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十二、20道必须掌握的C-面试题"><a href="#四十二、20道必须掌握的C-面试题" class="headerlink" title="四十二、20道必须掌握的C++面试题"></a>四十二、20道必须掌握的C++面试题</h1><p>在面试C++方面的工作时，经常会遇到各种面试题，这对应聘人员的知识掌握能力要求较高。本文将为大家带来的就是20道必须掌握的C++面试题，不要错过哦！</p><p><strong>问1：请用简单的语言告诉我C++ 是什么？</strong></p><p>答：C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!</p><p><strong>问2：C和C++的区别？</strong></p><p>答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。</p><p><strong>问3：什么是面向对象（OOP）？</strong></p><p>答：面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。</p><p><strong>问4：什么是多态？</strong></p><p>答：多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。</p><p><strong>问5：设计模式懂嘛，简单举个例子？</strong></p><p>答：</p><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p>比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p>适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p><strong>问6：STL库用过吗？常见的STL容器有哪些？算法用过哪几个？</strong></p><p>答：</p><p>STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）</p><p>容器，即存放数据的地方。比如array等。</p><p>在STL中，容器分为两类：序列式容器和关联式容器。</p><p>序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；</p><p>关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。</p><p>下面各选取一个作为说明。</p><p>vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。</p><p>set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。</p><p>算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。</p><p>迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。</p><p><strong>问7：数据结构会吗？项目开发过程中主要用到那些？</strong></p><p>答：数据结构中主要会用到数组，链表，树（较少），也会用到栈和队列的思想。</p><p><strong>问8：const知道吗？解释其作用。</strong></p><p>答：</p><p>1、const 修饰类的成员变量，表示成员常量，不能被修改。</p><p>2、const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。</p><p>3、如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。</p><p>4、const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。</p><p>5、类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。</p><p><strong>问9：类的static变量在什么时候初始化？函数的static变量在什么时候初始化？</strong></p><p>答：类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。</p><p><strong>问10：堆和栈的区别？堆和栈的生命周期？</strong></p><p>答：</p><p>一、堆栈空间分配区别：</p><p>1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</p><p>2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p><p>二、堆栈缓存方式区别：</p><p>1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p><p>2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p><p>三、堆栈数据结构区别：</p><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p><p>栈（数据结构）：一种先进后出的数据结构。</p><p><strong>问11：C和C++的区别？</strong></p><p>答：</p><p>C++在C的基础上增添类</p><p>C是一个结构化语言，它的重点在于算法和数据结构。</p><p>C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。</p><p><strong>问12：解释下封装、继承和多态？</strong></p><p>答：</p><p>一、封装：</p><p>封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。</p><p>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</p><p>二、继承：</p><p>继承主要实现重用代码，节省开发时间。</p><p>子类可以继承父类的一些东西。</p><p>三、多态</p><p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</p><p><strong>问13：指针和引用的区别？</strong></p><p>答：</p><p>1、 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；</p><p>2、 引用使用时无需解引用(*)，指针需要解引用；</p><p>3、 引用只能在定义时被初始化一次，之后不可变；指针可变；</p><p>4、 引用没有 const，指针有 const；</p><p>5、 引用不能为空，指针可以为空；</p><p>6、 “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p><p>7、 指针和引用的自增(++)运算意义不一样；</p><p>8、 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</p><p>9、从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</p><p><strong>问14：什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？</strong></p><p>答：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。</p><p>使用的时候要记得指针的长度。</p><p>malloc的时候得确定在那里free.</p><p>对指针赋值的时候应该注意被赋值指针需要不需要释放.</p><p>动态分配内存的指针最好不要再次赋值.</p><p><strong>问15：常用的排序算法有哪些？简单描述几个排序算法的优缺点？</strong></p><p>答：选择、冒泡、快速、希尔、归并、堆排等。</p><p>1、快排：是冒泡排序的一种改进。</p><p>优点：快，数据移动少</p><p>缺点：稳定性不足</p><p>2、归并：分治法排序，稳定的排序算法，一般用于对总体无序，但局部有序的数列。</p><p>优点：效率高O(n)，稳定</p><p>缺点：比较占用内存</p><p><strong>问16：new和malloc的区别？</strong></p><p>答：</p><p>1、malloc与free是C++&#x2F;C语言的标准库函数，new&#x2F;delete是C++的运算符。它们都可用于申请动态内存和释放内存。</p><p>2、对于非内部数据类型的对象而言，光用maloc&#x2F;free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。</p><p>3、由于malloc&#x2F;free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc&#x2F;free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new&#x2F;delete不是库函数。</p><p>4、C++程序经常要调用C函数，而C程序只能用malloc&#x2F;free管理动态内存。</p><p>5、new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。</p><p><strong>问17：TCP和UDP通信的差别？什么是IOCP？</strong></p><p>答：</p><p>1、TCP面向连接， UDP面向无连接的</p><p>2、TCP有保障的，UDP传输无保障的</p><p>3、TCP是效率低的，UDP效率高的</p><p>4、TCP是基于流的，UDP基于数据报文</p><p>5、TCP传输重要数据，UDP传输不重要的数据</p><p>IOCP全称I&#x2F;O Completion Port，中文译为I&#x2F;O完成端口。</p><p>IOCP是一个异步I&#x2F;O的API，它可以高效地将I&#x2F;O事件通知给应用程序。</p><p>与使用select()或是其它异步方法不同的是，一个套接字[socket]与一个完成端口关联了起来，然后就可继续进行正常的Winsock操作了。然而，当一个事件发生的时候，此完成端口就将被操作系统加入一个队列中。然后应用程序可以对核心层进行查询以得到此完成端口。</p><p><strong>问18：同步IO和异步IO的区别？</strong></p><p>答：</p><p>A. 同步</p><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p><p>按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。</p><p>但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p><p>最常见的例子就是 SendMessage。</p><p>该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。</p><p>当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</p><p>B. 异步</p><p>异步的概念和同步相对。</p><p>当一个异步过程调用发出后，调用者不会立刻得到结果。</p><p>实际处理这个调用的部件是在调用发出后，通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p><strong>问19：解释C++中静态函数和静态变量？</strong></p><p>答：</p><p>(1)类静态数据成员在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。类静态数据成员只有一个拷贝，为所有此类的对象所共享。</p><p>(2)类静态成员函数属于整个类，不属于某个对象，由该类所有对象共享。</p><p>1、static 成员变量实现了同类对象间信息共享。</p><p>2、static 成员类外存储，求类大小，并不包含在内。</p><p>3、static 成员是命名空间属于类的全局变量，存储在 data 区的rw段。</p><p>4、static 成员只能类外初始化。</p><p>5、可以通过类名访问（无对象生成时亦可），也可以通过对象访问。</p><p><strong>问20：说下你对内存的了解？</strong></p><p>答：</p><p>1、栈 – 由编译器自动分配释放</p><p>2、堆 – 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收</p><p>3、全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放</p><p>4、另外还有一个专门放常量的地方。- 程序结束释放</p><p>5 程序代码区，存放2进制代码。</p><p>在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的”adgfdf”这样的字符串存放在常量区。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十二、20道必须掌握的C-面试题&quot;&gt;&lt;a href=&quot;#四十二、20道必须掌握的C-面试题&quot; class=&quot;headerlink&quot; title=&quot;四十二、20道必须掌握的C++面试题&quot;&gt;&lt;/a&gt;四十二、20道必须掌握的C++面试题&lt;/h1&gt;&lt;p&gt;在面试C++方面</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十三、C++ map用法</title>
    <link href="https://hexo.tryrun.top/posts/898e3ab4.html"/>
    <id>https://hexo.tryrun.top/posts/898e3ab4.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十三、C-map用法"><a href="#四十三、C-map用法" class="headerlink" title="四十三、C++ map用法"></a>四十三、C++ map用法</h1><p>map是C++中的一个标准容器，她提供了很好一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果，本文为大家总结了map的一些基本简单的操作！</p><p><strong>1、map最基本的构造函数；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapmapstring; mapmapint;</span><br><span class="line"></span><br><span class="line">map&lt;sring, <span class="type">char</span>&gt;mapstring; map&lt; <span class="type">char</span> ,string&gt;mapchar;</span><br><span class="line"></span><br><span class="line">mapmapchar; mapmapint；</span><br></pre></td></tr></table></figure><p><strong>2、map添加数据；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string&gt; maplive;  </span><br><span class="line"><span class="number">1.</span>maplive.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">102</span>,<span class="string">&quot;aclive&quot;</span>));</span><br><span class="line"><span class="number">2.</span>maplive.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">321</span>,<span class="string">&quot;hai&quot;</span>));</span><br><span class="line"><span class="number">3</span>, maplive[<span class="number">112</span>]=<span class="string">&quot;April&quot;</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br></pre></td></tr></table></figure><p><strong>3、map中元素的查找：</strong></p><p>find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int ,string &gt;::iterator l_it;; </span><br><span class="line">  l_it=maplive.find(112);</span><br><span class="line">  if(l_it==maplive.end())</span><br><span class="line">               cout&lt;&lt;&quot;we do not find 112&quot;&lt;&lt;endl;</span><br><span class="line">  else cout&lt;&lt;&quot;wo find 112&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>4、map中元素的删除：</strong></p><p>如果删除112；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string &gt;::iterator l_it;;   </span><br><span class="line">  l_it=maplive.<span class="built_in">find</span>(<span class="number">112</span>);</span><br><span class="line">  <span class="keyword">if</span>(l_it==maplive.<span class="built_in">end</span>())</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;we do not find 112&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">else</span>  maplive.<span class="built_in">erase</span>(l_it);  <span class="comment">//delete 112;</span></span><br></pre></td></tr></table></figure><p><strong>5、map中 swap的用法：</strong></p><p>Map中的swap不是一个容器中的元素交换，而是两个容器交换；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1, m2, m3;</span><br><span class="line">      map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator m1_Iter;</span><br><span class="line">      m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">1</span>, <span class="number">10</span> ) );</span><br><span class="line">      m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">2</span>, <span class="number">20</span> ) );</span><br><span class="line">      m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">3</span>, <span class="number">30</span> ) );</span><br><span class="line">      m2.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">10</span>, <span class="number">100</span> ) );</span><br><span class="line">      m2.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">20</span>, <span class="number">200</span> ) );</span><br><span class="line">      m3.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">30</span>, <span class="number">300</span> ) );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The original map m1 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter-&gt;second;</span><br><span class="line">      cout   &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// This is the member function version of swap</span></span><br><span class="line">   <span class="comment">//m2 is said to be the argument map; m1 the target map</span></span><br><span class="line">   m1.<span class="built_in">swap</span>( m2 );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;After swapping with m2, map m1 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter -&gt; second;</span><br><span class="line">      cout  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;After swapping with m2, map m2 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m2.<span class="built_in">begin</span>( ); m1_Iter != m2.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter -&gt; second;</span><br><span class="line">      cout  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// This is the specialized template version of swap</span></span><br><span class="line">   <span class="built_in">swap</span>( m1, m3 );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;After swapping with m3, map m1 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter -&gt; second;</span><br><span class="line">      cout   &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、map的sort问题：</strong></p><p>Map中的元素是自动按key升序排序,所以不能对map用sort函数：</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">   map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator m1_Iter;</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">1</span>, <span class="number">20</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">4</span>, <span class="number">40</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">3</span>, <span class="number">60</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">2</span>, <span class="number">50</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">6</span>, <span class="number">40</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">7</span>, <span class="number">30</span> ) );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The original map m1 is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt;  m1_Iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、map的基本操作函数：</strong></p><p>C++ Maps是一种关联式容器，包含“关键字&#x2F;值”对</p><p>begin() 返回指向map头部的迭代器</p><p>clear(） 删除所有元素</p><p>begin() 返回指向map头部的迭代器</p><p>clear(） 删除所有元素</p><p>count() 返回指定元素出现的次数</p><p>empty() 如果map为空则返回true</p><p>end() 返回指向map末尾的迭代器</p><p>equal_range() 返回特殊条目的迭代器对</p><p>erase() 删除一个元素</p><p>find() 查找一个元素</p><p>get_allocator() 返回map的配置器</p><p>insert() 插入元素</p><p>key_comp() 返回比较元素key的函数</p><p>lower_bound() 返回键值&gt;&#x3D;给定元素的第一个位置</p><p>max_size() 返回可以容纳的最大元素个数</p><p>rbegin() 返回一个指向map尾部的逆向迭代器</p><p>rend() 返回一个指向map头部的逆向迭代器</p><p>size() 返回map中元素的个数</p><p>swap() 交换两个map</p><p>upper_bound() 返回键值&gt;给定元素的第一个位置</p><p>value_comp() 返回比较元素value的函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十三、C-map用法&quot;&gt;&lt;a href=&quot;#四十三、C-map用法&quot; class=&quot;headerlink&quot; title=&quot;四十三、C++ map用法&quot;&gt;&lt;/a&gt;四十三、C++ map用法&lt;/h1&gt;&lt;p&gt;map是C++中的一个标准容器，她提供了很好一对一的关系，在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十四、C++ vector使用方法</title>
    <link href="https://hexo.tryrun.top/posts/d72ec39.html"/>
    <id>https://hexo.tryrun.top/posts/d72ec39.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十四、C-vector使用方法"><a href="#四十四、C-vector使用方法" class="headerlink" title="四十四、C++ vector使用方法"></a>四十四、C++ vector使用方法</h1><p>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><p><strong>使用vector注意事项：</strong></p><p>1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p><p>2、Vector作为函数的参数或者返回值时，需要注意它的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Distance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a, vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span></span><br></pre></td></tr></table></figure><p>其中的“&amp;”绝对不能少！！！</p><p><strong>实例：</strong></p><p>vectortest;&#x2F;&#x2F;建立一个vector，int为数组元素的数据类型，test为动态数组名</p><p>简单的使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;test;<span class="comment">//建立一个vector</span></span><br><span class="line">test.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">test.<span class="built_in">push_back</span>(<span class="number">2</span>);<span class="comment">//把1和2压入vector，这样test[0]就是1,test[1]就是2</span></span><br></pre></td></tr></table></figure><p>自己见到的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;Point2f&gt; &gt; points; <span class="comment">//定义一个二维数组</span></span><br><span class="line">points[<span class="number">0</span>].<span class="built_in">size</span>();  <span class="comment">//指第一行的列数</span></span><br></pre></td></tr></table></figure><p><strong>1 、基本操作</strong></p><p>(1)头文件#include.</p><p>(2)创建vector对象，<code>vector vec;</code></p><p>(3)尾部插入数字：<code>vec.push_back(a);</code></p><p>(4)使用下标访问元素，<code>cout&lt;&lt;vec[0]&lt;&lt;endl;</code>记住下标是从0开始的。</p><p>(5)使用迭代器访问元素.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>(6)插入元素：<code>vec.insert(vec.begin()+i,a);</code>在第i+1个元素前面插入a;</p><p>(7)删除元素：<code>vec.erase(vec.begin()+2);</code>删除第3个元素</p><p><code>vec.erase(vec.begin()+i,vec.end()+j);</code>删除区间[i,j-1];区间从0开始</p><p>(8)向量大小:<code>vec.size();</code></p><p>(9)清空:<code>vec.clear();</code></p><p>特别提示：这里有begin()与end()函数、front()与back()的差别</p><p><strong>2、重要说明</strong></p><p>vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">rect</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> id;  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">    <span class="type">int</span> width;  </span><br><span class="line">　　<span class="comment">//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。  </span></span><br><span class="line">　　<span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> rect &amp;a)  <span class="type">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(id!=a.id)  </span><br><span class="line">            <span class="keyword">return</span> id&lt;a.id;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(length!=a.length)  </span><br><span class="line">                <span class="keyword">return</span> length&lt;a.length;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="keyword">return</span> width&lt;a.width;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;Rect;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    vector&lt;Rect&gt; vec;  </span><br><span class="line">    Rect rect;  </span><br><span class="line">    rect.id=<span class="number">1</span>;  </span><br><span class="line">    rect.length=<span class="number">2</span>;  </span><br><span class="line">    rect.width=<span class="number">3</span>;  </span><br><span class="line">    vec.<span class="built_in">push_back</span>(rect);  </span><br><span class="line">    vector&lt;Rect&gt;::iterator it=vec.<span class="built_in">begin</span>();  </span><br><span class="line">    cout&lt;&lt;(*it).id&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;(*it).length&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;(*it).width&lt;&lt;endl;      </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>3、算法</strong></p><p>(1) 使用reverse将元素翻转：需要头文件#include</p><p><code>reverse(vec.begin(),vec.end());</code>将元素翻转，即逆序排列！</p><p>(在vector中，如果一个函数中需要两个迭代器，一般后一个都不包含)</p><p>(2)使用sort排序：需要头文件#include，</p><p><code>sort(vec.begin(),vec.end());</code>(默认是按升序排列,即从小到大).</p><p>可以通过重写排序比较函数按照降序比较，如下：</p><p>定义排序比较函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Comp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时<code>:sort(vec.begin(),vec.end(),Comp)</code>，这样就降序排序。</p><p><strong>输出Vector的中的元素</strong></p><p>vector vecClass;</p><p>int nSize &#x3D; vecClass.size();</p><p>&#x2F;&#x2F;打印vecClass,方法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nSize;i++)    </span><br><span class="line">&#123;    </span><br><span class="line">   cout&lt;&lt;vecClass[i]&lt;&lt;<span class="string">&quot;     &quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">   cout&lt;&lt;endl;   </span><br></pre></td></tr></table></figure><p>需要注意的是：以方法一进行输出时，数组的下表必须保证是整数。</p><p>&#x2F;&#x2F;打印vecClass,方法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nSize;i++)    </span><br><span class="line">&#123;    </span><br><span class="line">   cout&lt;&lt;vecClass.<span class="built_in">at</span>(i)&lt;&lt;<span class="string">&quot;     &quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">   cout&lt;&lt;endl;    </span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;打印vecClass,方法三：输出某一指定的数值时不方便</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">float</span>&gt;::iterator it = vecClass.<span class="built_in">begin</span>();it!=vecClass.<span class="built_in">end</span>();it++)    </span><br><span class="line">&#123;    </span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;   &quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    cout&lt;&lt;endl;    </span><br></pre></td></tr></table></figure><p><strong>二维数组的使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">    <span class="type">int</span> out[<span class="number">3</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>,   </span><br><span class="line">             <span class="number">3</span>, <span class="number">4</span>,  </span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span> &#125;;  </span><br><span class="line">    vector &lt;<span class="type">int</span>*&gt; v1;  </span><br><span class="line">    v1.<span class="built_in">push_back</span>(out[<span class="number">0</span>]);  </span><br><span class="line">    v1.<span class="built_in">push_back</span>(out[<span class="number">1</span>]);  </span><br><span class="line">    v1.<span class="built_in">push_back</span>(out[<span class="number">2</span>]);  </span><br><span class="line">    cout &lt;&lt; v1[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//1  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//2  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//3  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//4  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">2</span>][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//5  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">2</span>][<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//6  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十四、C-vector使用方法&quot;&gt;&lt;a href=&quot;#四十四、C-vector使用方法&quot; class=&quot;headerlink&quot; title=&quot;四十四、C++ vector使用方法&quot;&gt;&lt;/a&gt;四十四、C++ vector使用方法&lt;/h1&gt;&lt;p&gt;在c++中，vect</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十五、常用C++编译器推荐</title>
    <link href="https://hexo.tryrun.top/posts/c46d9b3b.html"/>
    <id>https://hexo.tryrun.top/posts/c46d9b3b.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十五、常用C-编译器推荐"><a href="#四十五、常用C-编译器推荐" class="headerlink" title="四十五、常用C++编译器推荐"></a>四十五、常用C++编译器推荐</h1><p>本文将为大家带来的是几款简单实用的C++编译器（非IDE），希望大家喜欢。</p><h2 id="GCC（GNU-Compiler-Collection）"><a href="#GCC（GNU-Compiler-Collection）" class="headerlink" title="GCC（GNU Compiler Collection）"></a><strong>GCC（GNU Compiler Collection）</strong></h2><p>官方网站: <a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p><p>GCC有Windows移植版本，比较出名的就是MinGW和TDM-GCC</p><p>GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。</p><h2 id="llvm-Clang"><a href="#llvm-Clang" class="headerlink" title="llvm+Clang"></a><strong>llvm+Clang</strong></h2><p>LLVM官方网站：<a href="http://llvm.org/">http://llvm.org/</a></p><p>Clang官方网站：<a href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p><p>LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。LLVM计划启动于2000年，最初由University of Illinois at Urbana-Champaign的Chris Lattner主持开展。2006年Chris Lattner加盟Apple Inc.并致力于LLVM在Apple开发体系中的应用。Apple也是LLVM计划的主要资助者.</p><p>Low Level Virtual Machine (LLVM) 是一个开源的编译器架构，它已经被成功应用到多个应用领域。Clang ( 发音为 &#x2F;kl??&#x2F;) 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。</p><p>Clang 的开发目标是提供一个可以替代 GCC 的前端编译器。与 GCC 相比，Clang 是一个重新设计的编译器前端，具有一系列优点，例如模块化，代码简单易懂，占用内存小以及容易扩展和重用等。由于 Clang 在设计上的优异性，使得 Clang 非常适合用于设计源代码级别的分析和转化工具。Clang 也已经被应用到一些重要的开发领域，如 Static Analysis 是一个基于 Clang 的静态代码分析工具。</p><h2 id="Watcom-C-x2F-C"><a href="#Watcom-C-x2F-C" class="headerlink" title="Watcom C&#x2F;C++"></a><strong>Watcom C&#x2F;C++</strong></h2><p>官方网站：<a href="http://www.openwatcom.org/index.php/Download">http://www.openwatcom.org/index.php/Download</a></p><p>在DOS开发环境中，Watcom C&#x2F;C++ 编译器 以编译后的exe运行高速而著称，且首个支持Intel 80386 “保护模式”的编译器。于90年代中期，大批的雄心技术游戏(例如 Doom、Descent、Duke Nukem 3D 都以 Watcom C 写成）</p><p>Watcom C&#x2F;C++ 编译器、Watch Fortran 编译器 经已在不其先前所属公司Sybase售卖, 而被 SciTech 软件公司 作为 Open Watcom 开源包 发行。类似于其他的 开源编译器(例如 [GCC])项目，Watcom C代码小而便携, 其编译器后端(代码生成器)的目标码可变。该编译器可在DOS、OS&#x2F;2、Windows等操作系统上运行，并生成各种可运行的(不必是该操作系统的)代码。该编译器支持Novell NetWare的 NLM 目标码。目前正进行 为 Linux[1] 、modern BSD (例如FreeBSD) 操作系统 重定目标码, 以便在 x86、PowerPC 及　其它处理器上运行。Open Watcom C&#x2F;C++ 的1.4版于2005年12月发行，采用 Linux x86 为实验目标, 支持NT、OS&#x2F;2等host平台. 曾有某被弃置的QNX版本，但其编译所须的库并未开源发行。当前最近的稳定版是1.9版，在2010年6月发行。</p><h2 id="Digital-Mars"><a href="#Digital-Mars" class="headerlink" title="Digital Mars"></a><strong>Digital Mars</strong></h2><p>官方网站：<a href="http://www.digitalmars.com/">http://www.digitalmars.com/</a></p><p>DigitalMars是一款高性能的编译器，功能包含，快速编译&#x2F;链接时、强大的优化技术、Contract设计、完整的资源库、浏览HTML文档，反汇编、库、资源编译器等。命令行及GUI版本、教程、代码示例、在线更新、标准模板库等等。</p><h2 id="MSVC系列"><a href="#MSVC系列" class="headerlink" title="MSVC系列"></a><strong>MSVC系列</strong></h2><p>与Visual Studio集成发布，微软自己的编译器，VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等。所写的目标代码适用于微软支持的所有平台，包括Microsoft Windows、Windows Mobile、Windows CE、.NET Framework、.NET Compact Framework和Microsoft Silverlight 及Windows Phone。</p><h2 id="Borland系列（turbo-c和Borland-C-）"><a href="#Borland系列（turbo-c和Borland-C-）" class="headerlink" title="Borland系列（turbo c和Borland C++）"></a><strong>Borland系列（turbo c和Borland C++）</strong></h2><p>Borland C++ Builder Compiler 是一个 BC编译器。它是用来优化 BC 开发系统的工具。它包括最后版本的 ANSI&#x2F;ISO C++ 语言的支持，包括 RTL，C++ 的 STL框架结构支持。Turbo C（TC）是其早期的命令行编译器作品</p><h2 id="Intel-C"><a href="#Intel-C" class="headerlink" title="Intel C++"></a><strong>Intel C++</strong></h2><p>Intel C++ Compiler （简称 icc 或 icl）是美国 Intel 公司开发的 C&#x2F;C++编译器，适用于 Linux、Microsoft Windows 和 Mac OS X 操作系统。</p><p>Intel 编译支持 IA-32、Intel 64、Itanium 2、Intel Atom 处理器和某些非 Intel 的兼容处理器（例如某些 AMD 处理器）。开发人员应当检查系统需求。适用于 IA-32 和 Intel 64 的 Intel C++ 编译器的主要特点是自动向量化器，它能够生成 SSE、SSE2 和 SSE3 的 SIMD 指令及其适用于 Intel 无线 MMX 和 MMX 2 的嵌入式变种。</p><p>Intel C++ Compiler 进一步支持 OpenMP 3.0 和适用于对称多处理的自动并行化。借助于 Cluster OpenMP 的附加能力，编译器还可为分布存储多处理根据 OpenMP 指示自动生成消息传递接口调用。</p><p>Intel C++ Compiler 可通过四种方式获得，它分别是 Intel Parallel Studio、Intel C++ Compiler 专业版、Intel 编译器套装和 Intel Cluster Toolkit 编译器版的一部分。该编译器的最新发布是 Intel C++ Compiler 14.0 版本</p><h2 id="TCC-Tiny-C-Compiler"><a href="#TCC-Tiny-C-Compiler" class="headerlink" title="TCC(Tiny C Compiler)"></a><strong>TCC(Tiny C Compiler)</strong></h2><p>官方网站：<a href="http://bellard.org/tcc/">http://bellard.org/tcc/</a></p><p>Tiny C Compiler（缩写为TCC, tCc或TinyCC）用于x86（16&#x2F;32位）或是x86-64（64位）系统的C compiler，而开发者为Fabrice Bellard。软件是设计用于低级电脑环境，或是于磁盘容量有限的空间中（1.44磁片或是硬盘）。软件可以适用于Windows、Linux、Unix操作系统，而最新版本为0.9.26（Feb 15, 2013）。TCC是在GNU宽通用公共许可证（LGPL）协议规范下发布。作者是大神法布里斯·贝拉（FabriceBellard）</p><p>TCC符合ANSI C（C89&#x2F;C90）规范，Tiny C Compiler Reference Documentation accessed on 2008-08-07]亦符合新版的ISO C99标准规范，与GNU C扩展的内嵌汇编语言（即inline assembler，内联汇编大陆用语）功能汇编语言。</p><p>而Google Andriod系统内亦曾经内置于其中，于Andriod 2.0版本中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十五、常用C-编译器推荐&quot;&gt;&lt;a href=&quot;#四十五、常用C-编译器推荐&quot; class=&quot;headerlink&quot; title=&quot;四十五、常用C++编译器推荐&quot;&gt;&lt;/a&gt;四十五、常用C++编译器推荐&lt;/h1&gt;&lt;p&gt;本文将为大家带来的是几款简单实用的C++编译器（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 概述</title>
    <link href="https://hexo.tryrun.top/posts/3c0e80ab.html"/>
    <id>https://hexo.tryrun.top/posts/3c0e80ab.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Swing-概述"><a href="#一、Swing-概述" class="headerlink" title="一、Swing 概述"></a>一、Swing 概述</h1><p>Swing API 是一组可扩展的 GUI 组件，用来创建基于 JAVA 的前端&#x2F; GUI 应用程序。它是建立在 AWT API 之上，并且作为 AWT API 的替代者，因为它的几乎每一个控件都对应 AWT 控件。 Swing 组件遵循模型 – 视图 – 控制器架构来满足下面的准则。</p><ul><li>一个单一的 API 足够支持多种外观和风格。</li><li>API 是模拟驱动的，这样最高层级的 API 不需要有数据。</li><li>API 是使用 Java Bean 模式的，这样 Builder Tools 和 IDE 可以为开发者提供更好的服务来使用它。</li></ul><h2 id="MVC-架构"><a href="#MVC-架构" class="headerlink" title="MVC 架构"></a>MVC 架构</h2><p>Swing API 架构用下列的方式来遵循基于松散的 MVC 架构。</p><ul><li>模型表示组件的数据。</li><li>视图表示组件数据的可视化表示形式。</li><li>控制器接受用户在视图上的输入，并且在组件的数据上反映变化。</li><li>Swing 组件把模型作为一个单独的元素，并且把视图和控制器部分组合成用户界面的元素。使用这种方式，Swing 具有可插拔的外观与风格架构。</li></ul><h2 id="Swing-特点"><a href="#Swing-特点" class="headerlink" title="Swing 特点"></a>Swing 特点</h2><ul><li><strong>轻量级 ——</strong> Swing 组件是独立的本地操作系统的 API，因为 Swing API 控件通常采用纯 JAVA 代码而不是采用底层的操作系统调用来呈现。</li><li><strong>丰富的控件 ——</strong> Swing 提供了一组丰富的先进的控件，如树，页签窗体，滑动条，颜色选择器，表格控件</li><li><strong>高级自定义 ——</strong> Swing 控件可以用非常简单的方法来自定义，因为可视化外观是独立于内部表示的。</li><li><strong>可插拔的外观和风格 ——</strong> 基于 Swing 的 GUI 应用程序的外观和风格可以在运行时根据有效的值改变。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Swing-概述&quot;&gt;&lt;a href=&quot;#一、Swing-概述&quot; class=&quot;headerlink&quot; title=&quot;一、Swing 概述&quot;&gt;&lt;/a&gt;一、Swing 概述&lt;/h1&gt;&lt;p&gt;Swing API 是一组可扩展的 GUI 组件，用来创建基于 JAVA 的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 容器</title>
    <link href="https://hexo.tryrun.top/posts/75aa4e45.html"/>
    <id>https://hexo.tryrun.top/posts/75aa4e45.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十、Swing-容器"><a href="#十、Swing-容器" class="headerlink" title="十、Swing 容器"></a>十、Swing 容器</h1><p>容器是 SWING GUI 组件的组成部分。一个容器提供了一个可以放置组件的空间。在 AWT 中，一个容器是组件本身，并且它增加了功能来添加组件本身。下面是需要考虑的注意事项。</p><ul><li>容器的子类被称为容器。例如 JPanel，JFrame 和 JWindow。</li><li>容器可以仅仅添加组件到自身。</li><li>一个默认的布局使用 setLayout 方法来呈现在每个可以被重写的容器中。</li></ul><h2 id="SWING-容器："><a href="#SWING-容器：" class="headerlink" title="SWING 容器："></a>SWING 容器：</h2><p>下面是当使用 SWING 设计 GUI 事件时常用的容器列表。</p><table><thead><tr><th align="center">序号</th><th align="center">容器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Panel</strong> JPanel 是一个最简单的容器。它提供了任何其他组件可以被放置的空间，包括其他面板。</td></tr><tr><td align="center">2</td><td align="center"><strong>Frame</strong> JFrame 是一个带有标题和边界的顶层窗口。</td></tr><tr><td align="center">3</td><td align="center"><strong>Window</strong> JWindow 对象是一个没有边界和菜单条的顶层窗口。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十、Swing-容器&quot;&gt;&lt;a href=&quot;#十、Swing-容器&quot; class=&quot;headerlink&quot; title=&quot;十、Swing 容器&quot;&gt;&lt;/a&gt;十、Swing 容器&lt;/h1&gt;&lt;p&gt;容器是 SWING GUI 组件的组成部分。一个容器提供了一个可以放置组件的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 环境安装</title>
    <link href="https://hexo.tryrun.top/posts/8ab406ce.html"/>
    <id>https://hexo.tryrun.top/posts/8ab406ce.html</id>
    <published>2023-06-11T08:09:22.111Z</published>
    <updated>2023-06-11T08:09:22.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Swing-环境安装"><a href="#二、Swing-环境安装" class="headerlink" title="二、Swing 环境安装"></a>二、Swing 环境安装</h1><p>本节将指导你如何在你的机器上下载和设置 Java。请按照以下步骤来设置环境。</p><p>在链接 <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp"><strong>Download Java</strong></a> 上, Java SE 免费提供的。所以你根据你的操作系统下载一个版本。</p><p>在你的机器上，按照说明下载 java 和运行 <strong>.exe</strong> 来安装 Java。一旦在你的机器上安装了 Java，你将需要设置环境变量来指向正确的安装目录：</p><h2 id="设置-windows-2000-x2F-XP-的路径："><a href="#设置-windows-2000-x2F-XP-的路径：" class="headerlink" title="设置 windows 2000&#x2F;XP 的路径："></a>设置 windows 2000&#x2F;XP 的路径：</h2><p>假设你已经在 <em>c:\Program Files\java\jdk</em> 目录上安装了 Java：</p><ul><li>右击 ‘我的电脑’，并且选择 ‘属性’。</li><li>点击 ‘高级’ 标签下的 ‘环境变量’ 按钮。</li><li>现在更改 ‘路径’ 变量，以便它也包含 Java 可执行文件的路径。例如，如果路径当前设置为 <code>C:\WINDOWS\SYSTEM32</code>，然后更改你的路径为 <code>C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin</code>。</li></ul><h2 id="设置-windows-95-x2F-98-x2F-ME-的路径："><a href="#设置-windows-95-x2F-98-x2F-ME-的路径：" class="headerlink" title="设置 windows 95&#x2F;98&#x2F;ME 的路径："></a>设置 windows 95&#x2F;98&#x2F;ME 的路径：</h2><p>假设你已经在 <em>c:\Program Files\java\jdk</em> 目录上安装了 Java：</p><ul><li>编辑 <code>C:\autoexec.bat</code> 文件，并且在最后添加下行： <code>SET PATH=%PATH%;C:\Program Files\java\jdk\bin</code></li></ul><h2 id="设置-Linux，UNIX，Solaris，FreeBSD-的路径："><a href="#设置-Linux，UNIX，Solaris，FreeBSD-的路径：" class="headerlink" title="设置 Linux，UNIX，Solaris，FreeBSD 的路径："></a>设置 Linux，UNIX，Solaris，FreeBSD 的路径：</h2><p>环境变量路径应该设置为指向 java 二进制文件已经安装的位置。如果你在这方面遇到困难，参考你的 shell 文档。</p><p>例如，如果你使用 <em>bash</em> 作为你的 shell，然后你将添加下行到最后 <code>.bashrc: export PATH=/path/to/java:$PATH</code></p><h2 id="流行的-Java-编辑器："><a href="#流行的-Java-编辑器：" class="headerlink" title="流行的 Java 编辑器："></a>流行的 Java 编辑器：</h2><p>为了编写 Java 程序，你将需要一个文本编辑器。在市场上有甚至更复杂的可用 IDE。但是现在，你可以考虑下列之一：</p><ul><li><strong>Notepad：</strong> 在 Windows 机器上，你可以使用任何简单的文本编辑器，如 Notepad（本教程推荐），TextPad。</li><li><strong>Netbeans：</strong>是一个开源而且免费的 Java IDE，它可以从 <a href="http://www.netbeans.org/index.html">http://www.netbeans.org/index.html</a> 下载。</li><li><strong>Eclipse：</strong> 也是一个 Java IDE，它是由 eclipse 开源社区开发的，可以从 <a href="http://www.eclipse.org/">http://www.eclipse.org/</a> 下载。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、Swing-环境安装&quot;&gt;&lt;a href=&quot;#二、Swing-环境安装&quot; class=&quot;headerlink&quot; title=&quot;二、Swing 环境安装&quot;&gt;&lt;/a&gt;二、Swing 环境安装&lt;/h1&gt;&lt;p&gt;本节将指导你如何在你的机器上下载和设置 Java。请按照以下</summary>
      
    
    
    
    
  </entry>
  
</feed>
