<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云遇未晚</title>
  
  <subtitle>大自然的搬运工</subtitle>
  <link href="https://hexo.tryrun.top/atom.xml" rel="self"/>
  
  <link href="https://hexo.tryrun.top/"/>
  <updated>2023-06-23T14:25:26.409Z</updated>
  <id>https://hexo.tryrun.top/</id>
  
  <author>
    <name>云少</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三十九、C++ STL 教程</title>
    <link href="https://hexo.tryrun.top/posts/b694d422.html"/>
    <id>https://hexo.tryrun.top/posts/b694d422.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三十九、C-STL-教程"><a href="#三十九、C-STL-教程" class="headerlink" title="三十九、C++ STL 教程"></a>三十九、C++ STL 教程</h1><p>在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p><p>C++ 标准模板库的核心包括以下三个组件：</p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">容器（Containers）</td><td align="center">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td align="center">算法（Algorithms）</td><td align="center">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td align="center">迭代器（terators）</td><td align="center">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td></tr></tbody></table><p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。</p><p>下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec; </span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector size = 0</span><br><span class="line">extended vector size = 5</span><br><span class="line">value of vec [0] = 0</span><br><span class="line">value of vec [1] = 1</span><br><span class="line">value of vec [2] = 2</span><br><span class="line">value of vec [3] = 3</span><br><span class="line">value of vec [4] = 4</span><br><span class="line">value of v = 0</span><br><span class="line">value of v = 1</span><br><span class="line">value of v = 2</span><br><span class="line">value of v = 3</span><br><span class="line">value of v = 4</span><br></pre></td></tr></table></figure><p>关于上面实例中所使用的各种函数，有几点要注意：</p><ul><li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li><li>size( ) 函数显示向量的大小。</li><li>begin( ) 函数返回一个指向向量开头的迭代器。</li><li>end( ) 函数返回一个指向向量末尾的迭代器。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三十九、C-STL-教程&quot;&gt;&lt;a href=&quot;#三十九、C-STL-教程&quot; class=&quot;headerlink&quot; title=&quot;三十九、C++ STL 教程&quot;&gt;&lt;/a&gt;三十九、C++ STL 教程&lt;/h1&gt;&lt;p&gt;在前面的章节中，我们已经学习了 C++ 模板的概念。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十、C++ 标准库</title>
    <link href="https://hexo.tryrun.top/posts/bbbcd56b.html"/>
    <id>https://hexo.tryrun.top/posts/bbbcd56b.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十、C-标准库"><a href="#四十、C-标准库" class="headerlink" title="四十、C++ 标准库"></a>四十、C++ 标准库</h1><p>C++ 标准库可以分为两部分：</p><ul><li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li><li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li></ul><p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p><h2 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h2><p>标准函数库分为以下几类：</p><ul><li>输入&#x2F;输出 I&#x2F;O</li><li>字符串和字符处理</li><li>数学</li><li>时间、日期和本地化</li><li>动态分配</li><li>其他</li><li>宽字符函数</li></ul><h2 id="面向对象类库"><a href="#面向对象类库" class="headerlink" title="面向对象类库"></a>面向对象类库</h2><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p><ul><li>标准的 C++ I&#x2F;O 类</li><li>String 类</li><li>数值类</li><li>STL 容器类</li><li>STL 算法</li><li>STL 函数对象</li><li>STL 迭代器</li><li>STL 分配器</li><li>本地化库</li><li>异常处理类</li><li>杂项支持库</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十、C-标准库&quot;&gt;&lt;a href=&quot;#四十、C-标准库&quot; class=&quot;headerlink&quot; title=&quot;四十、C++ 标准库&quot;&gt;&lt;/a&gt;四十、C++ 标准库&lt;/h1&gt;&lt;p&gt;C++ 标准库可以分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标准函数库</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十一、C++ 有用的资源</title>
    <link href="https://hexo.tryrun.top/posts/43948d17.html"/>
    <id>https://hexo.tryrun.top/posts/43948d17.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十一、C-有用的资源"><a href="#四十一、C-有用的资源" class="headerlink" title="四十一、C++ 有用的资源"></a>四十一、C++ 有用的资源</h1><ul><li>C++ Programming Language Tutorials − C++ 编程语言教程。</li><li>C++ Programming − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。</li><li>C++ FAQ − C++ 常见问题</li><li>Free Country − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。</li><li>C and C++ Users Group − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十一、C-有用的资源&quot;&gt;&lt;a href=&quot;#四十一、C-有用的资源&quot; class=&quot;headerlink&quot; title=&quot;四十一、C++ 有用的资源&quot;&gt;&lt;/a&gt;四十一、C++ 有用的资源&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;C++ Programming Language</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十三、C++ map用法</title>
    <link href="https://hexo.tryrun.top/posts/898e3ab4.html"/>
    <id>https://hexo.tryrun.top/posts/898e3ab4.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十三、C-map用法"><a href="#四十三、C-map用法" class="headerlink" title="四十三、C++ map用法"></a>四十三、C++ map用法</h1><p>map是C++中的一个标准容器，她提供了很好一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果，本文为大家总结了map的一些基本简单的操作！</p><p><strong>1、map最基本的构造函数；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapmapstring; mapmapint;</span><br><span class="line"></span><br><span class="line">map&lt;sring, <span class="type">char</span>&gt;mapstring; map&lt; <span class="type">char</span> ,string&gt;mapchar;</span><br><span class="line"></span><br><span class="line">mapmapchar; mapmapint；</span><br></pre></td></tr></table></figure><p><strong>2、map添加数据；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string&gt; maplive;  </span><br><span class="line"><span class="number">1.</span>maplive.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">102</span>,<span class="string">&quot;aclive&quot;</span>));</span><br><span class="line"><span class="number">2.</span>maplive.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">321</span>,<span class="string">&quot;hai&quot;</span>));</span><br><span class="line"><span class="number">3</span>, maplive[<span class="number">112</span>]=<span class="string">&quot;April&quot;</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br></pre></td></tr></table></figure><p><strong>3、map中元素的查找：</strong></p><p>find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int ,string &gt;::iterator l_it;; </span><br><span class="line">  l_it=maplive.find(112);</span><br><span class="line">  if(l_it==maplive.end())</span><br><span class="line">               cout&lt;&lt;&quot;we do not find 112&quot;&lt;&lt;endl;</span><br><span class="line">  else cout&lt;&lt;&quot;wo find 112&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>4、map中元素的删除：</strong></p><p>如果删除112；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string &gt;::iterator l_it;;   </span><br><span class="line">  l_it=maplive.<span class="built_in">find</span>(<span class="number">112</span>);</span><br><span class="line">  <span class="keyword">if</span>(l_it==maplive.<span class="built_in">end</span>())</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;we do not find 112&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">else</span>  maplive.<span class="built_in">erase</span>(l_it);  <span class="comment">//delete 112;</span></span><br></pre></td></tr></table></figure><p><strong>5、map中 swap的用法：</strong></p><p>Map中的swap不是一个容器中的元素交换，而是两个容器交换；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1, m2, m3;</span><br><span class="line">      map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator m1_Iter;</span><br><span class="line">      m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">1</span>, <span class="number">10</span> ) );</span><br><span class="line">      m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">2</span>, <span class="number">20</span> ) );</span><br><span class="line">      m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">3</span>, <span class="number">30</span> ) );</span><br><span class="line">      m2.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">10</span>, <span class="number">100</span> ) );</span><br><span class="line">      m2.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">20</span>, <span class="number">200</span> ) );</span><br><span class="line">      m3.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">30</span>, <span class="number">300</span> ) );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The original map m1 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter-&gt;second;</span><br><span class="line">      cout   &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// This is the member function version of swap</span></span><br><span class="line">   <span class="comment">//m2 is said to be the argument map; m1 the target map</span></span><br><span class="line">   m1.<span class="built_in">swap</span>( m2 );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;After swapping with m2, map m1 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter -&gt; second;</span><br><span class="line">      cout  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;After swapping with m2, map m2 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m2.<span class="built_in">begin</span>( ); m1_Iter != m2.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter -&gt; second;</span><br><span class="line">      cout  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// This is the specialized template version of swap</span></span><br><span class="line">   <span class="built_in">swap</span>( m1, m3 );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;After swapping with m3, map m1 is:&quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m1_Iter -&gt; second;</span><br><span class="line">      cout   &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、map的sort问题：</strong></p><p>Map中的元素是自动按key升序排序,所以不能对map用sort函数：</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">   map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator m1_Iter;</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">1</span>, <span class="number">20</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">4</span>, <span class="number">40</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">3</span>, <span class="number">60</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">2</span>, <span class="number">50</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">6</span>, <span class="number">40</span> ) );</span><br><span class="line">   m1.<span class="built_in">insert</span> ( pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt;  ( <span class="number">7</span>, <span class="number">30</span> ) );</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The original map m1 is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">for</span> ( m1_Iter = m1.<span class="built_in">begin</span>( ); m1_Iter != m1.<span class="built_in">end</span>( ); m1_Iter++ )</span><br><span class="line">      cout &lt;&lt;  m1_Iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、map的基本操作函数：</strong></p><p>C++ Maps是一种关联式容器，包含“关键字&#x2F;值”对</p><p>begin() 返回指向map头部的迭代器</p><p>clear(） 删除所有元素</p><p>begin() 返回指向map头部的迭代器</p><p>clear(） 删除所有元素</p><p>count() 返回指定元素出现的次数</p><p>empty() 如果map为空则返回true</p><p>end() 返回指向map末尾的迭代器</p><p>equal_range() 返回特殊条目的迭代器对</p><p>erase() 删除一个元素</p><p>find() 查找一个元素</p><p>get_allocator() 返回map的配置器</p><p>insert() 插入元素</p><p>key_comp() 返回比较元素key的函数</p><p>lower_bound() 返回键值&gt;&#x3D;给定元素的第一个位置</p><p>max_size() 返回可以容纳的最大元素个数</p><p>rbegin() 返回一个指向map尾部的逆向迭代器</p><p>rend() 返回一个指向map头部的逆向迭代器</p><p>size() 返回map中元素的个数</p><p>swap() 交换两个map</p><p>upper_bound() 返回键值&gt;给定元素的第一个位置</p><p>value_comp() 返回比较元素value的函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十三、C-map用法&quot;&gt;&lt;a href=&quot;#四十三、C-map用法&quot; class=&quot;headerlink&quot; title=&quot;四十三、C++ map用法&quot;&gt;&lt;/a&gt;四十三、C++ map用法&lt;/h1&gt;&lt;p&gt;map是C++中的一个标准容器，她提供了很好一对一的关系，在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十二、20道必须掌握的C++面试题</title>
    <link href="https://hexo.tryrun.top/posts/cf4e807d.html"/>
    <id>https://hexo.tryrun.top/posts/cf4e807d.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十二、20道必须掌握的C-面试题"><a href="#四十二、20道必须掌握的C-面试题" class="headerlink" title="四十二、20道必须掌握的C++面试题"></a>四十二、20道必须掌握的C++面试题</h1><p>在面试C++方面的工作时，经常会遇到各种面试题，这对应聘人员的知识掌握能力要求较高。本文将为大家带来的就是20道必须掌握的C++面试题，不要错过哦！</p><p><strong>问1：请用简单的语言告诉我C++ 是什么？</strong></p><p>答：C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!</p><p><strong>问2：C和C++的区别？</strong></p><p>答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。</p><p><strong>问3：什么是面向对象（OOP）？</strong></p><p>答：面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。</p><p><strong>问4：什么是多态？</strong></p><p>答：多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。</p><p><strong>问5：设计模式懂嘛，简单举个例子？</strong></p><p>答：</p><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p>比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p>适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p><strong>问6：STL库用过吗？常见的STL容器有哪些？算法用过哪几个？</strong></p><p>答：</p><p>STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）</p><p>容器，即存放数据的地方。比如array等。</p><p>在STL中，容器分为两类：序列式容器和关联式容器。</p><p>序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；</p><p>关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。</p><p>下面各选取一个作为说明。</p><p>vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。</p><p>set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。</p><p>算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。</p><p>迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。</p><p><strong>问7：数据结构会吗？项目开发过程中主要用到那些？</strong></p><p>答：数据结构中主要会用到数组，链表，树（较少），也会用到栈和队列的思想。</p><p><strong>问8：const知道吗？解释其作用。</strong></p><p>答：</p><p>1、const 修饰类的成员变量，表示成员常量，不能被修改。</p><p>2、const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。</p><p>3、如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。</p><p>4、const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。</p><p>5、类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。</p><p><strong>问9：类的static变量在什么时候初始化？函数的static变量在什么时候初始化？</strong></p><p>答：类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。</p><p><strong>问10：堆和栈的区别？堆和栈的生命周期？</strong></p><p>答：</p><p>一、堆栈空间分配区别：</p><p>1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</p><p>2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p><p>二、堆栈缓存方式区别：</p><p>1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p><p>2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p><p>三、堆栈数据结构区别：</p><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p><p>栈（数据结构）：一种先进后出的数据结构。</p><p><strong>问11：C和C++的区别？</strong></p><p>答：</p><p>C++在C的基础上增添类</p><p>C是一个结构化语言，它的重点在于算法和数据结构。</p><p>C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。</p><p><strong>问12：解释下封装、继承和多态？</strong></p><p>答：</p><p>一、封装：</p><p>封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。</p><p>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</p><p>二、继承：</p><p>继承主要实现重用代码，节省开发时间。</p><p>子类可以继承父类的一些东西。</p><p>三、多态</p><p>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</p><p><strong>问13：指针和引用的区别？</strong></p><p>答：</p><p>1、 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；</p><p>2、 引用使用时无需解引用(*)，指针需要解引用；</p><p>3、 引用只能在定义时被初始化一次，之后不可变；指针可变；</p><p>4、 引用没有 const，指针有 const；</p><p>5、 引用不能为空，指针可以为空；</p><p>6、 “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p><p>7、 指针和引用的自增(++)运算意义不一样；</p><p>8、 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</p><p>9、从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</p><p><strong>问14：什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？</strong></p><p>答：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。</p><p>使用的时候要记得指针的长度。</p><p>malloc的时候得确定在那里free.</p><p>对指针赋值的时候应该注意被赋值指针需要不需要释放.</p><p>动态分配内存的指针最好不要再次赋值.</p><p><strong>问15：常用的排序算法有哪些？简单描述几个排序算法的优缺点？</strong></p><p>答：选择、冒泡、快速、希尔、归并、堆排等。</p><p>1、快排：是冒泡排序的一种改进。</p><p>优点：快，数据移动少</p><p>缺点：稳定性不足</p><p>2、归并：分治法排序，稳定的排序算法，一般用于对总体无序，但局部有序的数列。</p><p>优点：效率高O(n)，稳定</p><p>缺点：比较占用内存</p><p><strong>问16：new和malloc的区别？</strong></p><p>答：</p><p>1、malloc与free是C++&#x2F;C语言的标准库函数，new&#x2F;delete是C++的运算符。它们都可用于申请动态内存和释放内存。</p><p>2、对于非内部数据类型的对象而言，光用maloc&#x2F;free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。</p><p>3、由于malloc&#x2F;free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc&#x2F;free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new&#x2F;delete不是库函数。</p><p>4、C++程序经常要调用C函数，而C程序只能用malloc&#x2F;free管理动态内存。</p><p>5、new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。</p><p><strong>问17：TCP和UDP通信的差别？什么是IOCP？</strong></p><p>答：</p><p>1、TCP面向连接， UDP面向无连接的</p><p>2、TCP有保障的，UDP传输无保障的</p><p>3、TCP是效率低的，UDP效率高的</p><p>4、TCP是基于流的，UDP基于数据报文</p><p>5、TCP传输重要数据，UDP传输不重要的数据</p><p>IOCP全称I&#x2F;O Completion Port，中文译为I&#x2F;O完成端口。</p><p>IOCP是一个异步I&#x2F;O的API，它可以高效地将I&#x2F;O事件通知给应用程序。</p><p>与使用select()或是其它异步方法不同的是，一个套接字[socket]与一个完成端口关联了起来，然后就可继续进行正常的Winsock操作了。然而，当一个事件发生的时候，此完成端口就将被操作系统加入一个队列中。然后应用程序可以对核心层进行查询以得到此完成端口。</p><p><strong>问18：同步IO和异步IO的区别？</strong></p><p>答：</p><p>A. 同步</p><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p><p>按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。</p><p>但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p><p>最常见的例子就是 SendMessage。</p><p>该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。</p><p>当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</p><p>B. 异步</p><p>异步的概念和同步相对。</p><p>当一个异步过程调用发出后，调用者不会立刻得到结果。</p><p>实际处理这个调用的部件是在调用发出后，通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p><strong>问19：解释C++中静态函数和静态变量？</strong></p><p>答：</p><p>(1)类静态数据成员在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。类静态数据成员只有一个拷贝，为所有此类的对象所共享。</p><p>(2)类静态成员函数属于整个类，不属于某个对象，由该类所有对象共享。</p><p>1、static 成员变量实现了同类对象间信息共享。</p><p>2、static 成员类外存储，求类大小，并不包含在内。</p><p>3、static 成员是命名空间属于类的全局变量，存储在 data 区的rw段。</p><p>4、static 成员只能类外初始化。</p><p>5、可以通过类名访问（无对象生成时亦可），也可以通过对象访问。</p><p><strong>问20：说下你对内存的了解？</strong></p><p>答：</p><p>1、栈 – 由编译器自动分配释放</p><p>2、堆 – 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收</p><p>3、全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放</p><p>4、另外还有一个专门放常量的地方。- 程序结束释放</p><p>5 程序代码区，存放2进制代码。</p><p>在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的”adgfdf”这样的字符串存放在常量区。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十二、20道必须掌握的C-面试题&quot;&gt;&lt;a href=&quot;#四十二、20道必须掌握的C-面试题&quot; class=&quot;headerlink&quot; title=&quot;四十二、20道必须掌握的C++面试题&quot;&gt;&lt;/a&gt;四十二、20道必须掌握的C++面试题&lt;/h1&gt;&lt;p&gt;在面试C++方面</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十四、C++ vector使用方法</title>
    <link href="https://hexo.tryrun.top/posts/d72ec39.html"/>
    <id>https://hexo.tryrun.top/posts/d72ec39.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十四、C-vector使用方法"><a href="#四十四、C-vector使用方法" class="headerlink" title="四十四、C++ vector使用方法"></a>四十四、C++ vector使用方法</h1><p>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><p><strong>使用vector注意事项：</strong></p><p>1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p><p>2、Vector作为函数的参数或者返回值时，需要注意它的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Distance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a, vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span></span><br></pre></td></tr></table></figure><p>其中的“&amp;”绝对不能少！！！</p><p><strong>实例：</strong></p><p>vectortest;&#x2F;&#x2F;建立一个vector，int为数组元素的数据类型，test为动态数组名</p><p>简单的使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;test;<span class="comment">//建立一个vector</span></span><br><span class="line">test.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">test.<span class="built_in">push_back</span>(<span class="number">2</span>);<span class="comment">//把1和2压入vector，这样test[0]就是1,test[1]就是2</span></span><br></pre></td></tr></table></figure><p>自己见到的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;Point2f&gt; &gt; points; <span class="comment">//定义一个二维数组</span></span><br><span class="line">points[<span class="number">0</span>].<span class="built_in">size</span>();  <span class="comment">//指第一行的列数</span></span><br></pre></td></tr></table></figure><p><strong>1 、基本操作</strong></p><p>(1)头文件#include.</p><p>(2)创建vector对象，<code>vector vec;</code></p><p>(3)尾部插入数字：<code>vec.push_back(a);</code></p><p>(4)使用下标访问元素，<code>cout&lt;&lt;vec[0]&lt;&lt;endl;</code>记住下标是从0开始的。</p><p>(5)使用迭代器访问元素.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>(6)插入元素：<code>vec.insert(vec.begin()+i,a);</code>在第i+1个元素前面插入a;</p><p>(7)删除元素：<code>vec.erase(vec.begin()+2);</code>删除第3个元素</p><p><code>vec.erase(vec.begin()+i,vec.end()+j);</code>删除区间[i,j-1];区间从0开始</p><p>(8)向量大小:<code>vec.size();</code></p><p>(9)清空:<code>vec.clear();</code></p><p>特别提示：这里有begin()与end()函数、front()与back()的差别</p><p><strong>2、重要说明</strong></p><p>vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">rect</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> id;  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">    <span class="type">int</span> width;  </span><br><span class="line">　　<span class="comment">//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。  </span></span><br><span class="line">　　<span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> rect &amp;a)  <span class="type">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(id!=a.id)  </span><br><span class="line">            <span class="keyword">return</span> id&lt;a.id;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(length!=a.length)  </span><br><span class="line">                <span class="keyword">return</span> length&lt;a.length;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="keyword">return</span> width&lt;a.width;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;Rect;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    vector&lt;Rect&gt; vec;  </span><br><span class="line">    Rect rect;  </span><br><span class="line">    rect.id=<span class="number">1</span>;  </span><br><span class="line">    rect.length=<span class="number">2</span>;  </span><br><span class="line">    rect.width=<span class="number">3</span>;  </span><br><span class="line">    vec.<span class="built_in">push_back</span>(rect);  </span><br><span class="line">    vector&lt;Rect&gt;::iterator it=vec.<span class="built_in">begin</span>();  </span><br><span class="line">    cout&lt;&lt;(*it).id&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;(*it).length&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;(*it).width&lt;&lt;endl;      </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>3、算法</strong></p><p>(1) 使用reverse将元素翻转：需要头文件#include</p><p><code>reverse(vec.begin(),vec.end());</code>将元素翻转，即逆序排列！</p><p>(在vector中，如果一个函数中需要两个迭代器，一般后一个都不包含)</p><p>(2)使用sort排序：需要头文件#include，</p><p><code>sort(vec.begin(),vec.end());</code>(默认是按升序排列,即从小到大).</p><p>可以通过重写排序比较函数按照降序比较，如下：</p><p>定义排序比较函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Comp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时<code>:sort(vec.begin(),vec.end(),Comp)</code>，这样就降序排序。</p><p><strong>输出Vector的中的元素</strong></p><p>vector vecClass;</p><p>int nSize &#x3D; vecClass.size();</p><p>&#x2F;&#x2F;打印vecClass,方法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nSize;i++)    </span><br><span class="line">&#123;    </span><br><span class="line">   cout&lt;&lt;vecClass[i]&lt;&lt;<span class="string">&quot;     &quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">   cout&lt;&lt;endl;   </span><br></pre></td></tr></table></figure><p>需要注意的是：以方法一进行输出时，数组的下表必须保证是整数。</p><p>&#x2F;&#x2F;打印vecClass,方法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nSize;i++)    </span><br><span class="line">&#123;    </span><br><span class="line">   cout&lt;&lt;vecClass.<span class="built_in">at</span>(i)&lt;&lt;<span class="string">&quot;     &quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">   cout&lt;&lt;endl;    </span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;打印vecClass,方法三：输出某一指定的数值时不方便</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">float</span>&gt;::iterator it = vecClass.<span class="built_in">begin</span>();it!=vecClass.<span class="built_in">end</span>();it++)    </span><br><span class="line">&#123;    </span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;   &quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    cout&lt;&lt;endl;    </span><br></pre></td></tr></table></figure><p><strong>二维数组的使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">    <span class="type">int</span> out[<span class="number">3</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>,   </span><br><span class="line">             <span class="number">3</span>, <span class="number">4</span>,  </span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span> &#125;;  </span><br><span class="line">    vector &lt;<span class="type">int</span>*&gt; v1;  </span><br><span class="line">    v1.<span class="built_in">push_back</span>(out[<span class="number">0</span>]);  </span><br><span class="line">    v1.<span class="built_in">push_back</span>(out[<span class="number">1</span>]);  </span><br><span class="line">    v1.<span class="built_in">push_back</span>(out[<span class="number">2</span>]);  </span><br><span class="line">    cout &lt;&lt; v1[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//1  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//2  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//3  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//4  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">2</span>][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//5  </span></span><br><span class="line">    cout &lt;&lt; v1[<span class="number">2</span>][<span class="number">1</span>] &lt;&lt; endl;<span class="comment">//6  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十四、C-vector使用方法&quot;&gt;&lt;a href=&quot;#四十四、C-vector使用方法&quot; class=&quot;headerlink&quot; title=&quot;四十四、C++ vector使用方法&quot;&gt;&lt;/a&gt;四十四、C++ vector使用方法&lt;/h1&gt;&lt;p&gt;在c++中，vect</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四十五、常用C++编译器推荐</title>
    <link href="https://hexo.tryrun.top/posts/c46d9b3b.html"/>
    <id>https://hexo.tryrun.top/posts/c46d9b3b.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四十五、常用C-编译器推荐"><a href="#四十五、常用C-编译器推荐" class="headerlink" title="四十五、常用C++编译器推荐"></a>四十五、常用C++编译器推荐</h1><p>本文将为大家带来的是几款简单实用的C++编译器（非IDE），希望大家喜欢。</p><h2 id="GCC（GNU-Compiler-Collection）"><a href="#GCC（GNU-Compiler-Collection）" class="headerlink" title="GCC（GNU Compiler Collection）"></a><strong>GCC（GNU Compiler Collection）</strong></h2><p>官方网站: <a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></p><p>GCC有Windows移植版本，比较出名的就是MinGW和TDM-GCC</p><p>GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。</p><h2 id="llvm-Clang"><a href="#llvm-Clang" class="headerlink" title="llvm+Clang"></a><strong>llvm+Clang</strong></h2><p>LLVM官方网站：<a href="http://llvm.org/">http://llvm.org/</a></p><p>Clang官方网站：<a href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p><p>LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。LLVM计划启动于2000年，最初由University of Illinois at Urbana-Champaign的Chris Lattner主持开展。2006年Chris Lattner加盟Apple Inc.并致力于LLVM在Apple开发体系中的应用。Apple也是LLVM计划的主要资助者.</p><p>Low Level Virtual Machine (LLVM) 是一个开源的编译器架构，它已经被成功应用到多个应用领域。Clang ( 发音为 &#x2F;kl??&#x2F;) 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。</p><p>Clang 的开发目标是提供一个可以替代 GCC 的前端编译器。与 GCC 相比，Clang 是一个重新设计的编译器前端，具有一系列优点，例如模块化，代码简单易懂，占用内存小以及容易扩展和重用等。由于 Clang 在设计上的优异性，使得 Clang 非常适合用于设计源代码级别的分析和转化工具。Clang 也已经被应用到一些重要的开发领域，如 Static Analysis 是一个基于 Clang 的静态代码分析工具。</p><h2 id="Watcom-C-x2F-C"><a href="#Watcom-C-x2F-C" class="headerlink" title="Watcom C&#x2F;C++"></a><strong>Watcom C&#x2F;C++</strong></h2><p>官方网站：<a href="http://www.openwatcom.org/index.php/Download">http://www.openwatcom.org/index.php/Download</a></p><p>在DOS开发环境中，Watcom C&#x2F;C++ 编译器 以编译后的exe运行高速而著称，且首个支持Intel 80386 “保护模式”的编译器。于90年代中期，大批的雄心技术游戏(例如 Doom、Descent、Duke Nukem 3D 都以 Watcom C 写成）</p><p>Watcom C&#x2F;C++ 编译器、Watch Fortran 编译器 经已在不其先前所属公司Sybase售卖, 而被 SciTech 软件公司 作为 Open Watcom 开源包 发行。类似于其他的 开源编译器(例如 [GCC])项目，Watcom C代码小而便携, 其编译器后端(代码生成器)的目标码可变。该编译器可在DOS、OS&#x2F;2、Windows等操作系统上运行，并生成各种可运行的(不必是该操作系统的)代码。该编译器支持Novell NetWare的 NLM 目标码。目前正进行 为 Linux[1] 、modern BSD (例如FreeBSD) 操作系统 重定目标码, 以便在 x86、PowerPC 及　其它处理器上运行。Open Watcom C&#x2F;C++ 的1.4版于2005年12月发行，采用 Linux x86 为实验目标, 支持NT、OS&#x2F;2等host平台. 曾有某被弃置的QNX版本，但其编译所须的库并未开源发行。当前最近的稳定版是1.9版，在2010年6月发行。</p><h2 id="Digital-Mars"><a href="#Digital-Mars" class="headerlink" title="Digital Mars"></a><strong>Digital Mars</strong></h2><p>官方网站：<a href="http://www.digitalmars.com/">http://www.digitalmars.com/</a></p><p>DigitalMars是一款高性能的编译器，功能包含，快速编译&#x2F;链接时、强大的优化技术、Contract设计、完整的资源库、浏览HTML文档，反汇编、库、资源编译器等。命令行及GUI版本、教程、代码示例、在线更新、标准模板库等等。</p><h2 id="MSVC系列"><a href="#MSVC系列" class="headerlink" title="MSVC系列"></a><strong>MSVC系列</strong></h2><p>与Visual Studio集成发布，微软自己的编译器，VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等。所写的目标代码适用于微软支持的所有平台，包括Microsoft Windows、Windows Mobile、Windows CE、.NET Framework、.NET Compact Framework和Microsoft Silverlight 及Windows Phone。</p><h2 id="Borland系列（turbo-c和Borland-C-）"><a href="#Borland系列（turbo-c和Borland-C-）" class="headerlink" title="Borland系列（turbo c和Borland C++）"></a><strong>Borland系列（turbo c和Borland C++）</strong></h2><p>Borland C++ Builder Compiler 是一个 BC编译器。它是用来优化 BC 开发系统的工具。它包括最后版本的 ANSI&#x2F;ISO C++ 语言的支持，包括 RTL，C++ 的 STL框架结构支持。Turbo C（TC）是其早期的命令行编译器作品</p><h2 id="Intel-C"><a href="#Intel-C" class="headerlink" title="Intel C++"></a><strong>Intel C++</strong></h2><p>Intel C++ Compiler （简称 icc 或 icl）是美国 Intel 公司开发的 C&#x2F;C++编译器，适用于 Linux、Microsoft Windows 和 Mac OS X 操作系统。</p><p>Intel 编译支持 IA-32、Intel 64、Itanium 2、Intel Atom 处理器和某些非 Intel 的兼容处理器（例如某些 AMD 处理器）。开发人员应当检查系统需求。适用于 IA-32 和 Intel 64 的 Intel C++ 编译器的主要特点是自动向量化器，它能够生成 SSE、SSE2 和 SSE3 的 SIMD 指令及其适用于 Intel 无线 MMX 和 MMX 2 的嵌入式变种。</p><p>Intel C++ Compiler 进一步支持 OpenMP 3.0 和适用于对称多处理的自动并行化。借助于 Cluster OpenMP 的附加能力，编译器还可为分布存储多处理根据 OpenMP 指示自动生成消息传递接口调用。</p><p>Intel C++ Compiler 可通过四种方式获得，它分别是 Intel Parallel Studio、Intel C++ Compiler 专业版、Intel 编译器套装和 Intel Cluster Toolkit 编译器版的一部分。该编译器的最新发布是 Intel C++ Compiler 14.0 版本</p><h2 id="TCC-Tiny-C-Compiler"><a href="#TCC-Tiny-C-Compiler" class="headerlink" title="TCC(Tiny C Compiler)"></a><strong>TCC(Tiny C Compiler)</strong></h2><p>官方网站：<a href="http://bellard.org/tcc/">http://bellard.org/tcc/</a></p><p>Tiny C Compiler（缩写为TCC, tCc或TinyCC）用于x86（16&#x2F;32位）或是x86-64（64位）系统的C compiler，而开发者为Fabrice Bellard。软件是设计用于低级电脑环境，或是于磁盘容量有限的空间中（1.44磁片或是硬盘）。软件可以适用于Windows、Linux、Unix操作系统，而最新版本为0.9.26（Feb 15, 2013）。TCC是在GNU宽通用公共许可证（LGPL）协议规范下发布。作者是大神法布里斯·贝拉（FabriceBellard）</p><p>TCC符合ANSI C（C89&#x2F;C90）规范，Tiny C Compiler Reference Documentation accessed on 2008-08-07]亦符合新版的ISO C99标准规范，与GNU C扩展的内嵌汇编语言（即inline assembler，内联汇编大陆用语）功能汇编语言。</p><p>而Google Andriod系统内亦曾经内置于其中，于Andriod 2.0版本中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四十五、常用C-编译器推荐&quot;&gt;&lt;a href=&quot;#四十五、常用C-编译器推荐&quot; class=&quot;headerlink&quot; title=&quot;四十五、常用C++编译器推荐&quot;&gt;&lt;/a&gt;四十五、常用C++编译器推荐&lt;/h1&gt;&lt;p&gt;本文将为大家带来的是几款简单实用的C++编译器（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 概述</title>
    <link href="https://hexo.tryrun.top/posts/3c0e80ab.html"/>
    <id>https://hexo.tryrun.top/posts/3c0e80ab.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Swing-概述"><a href="#一、Swing-概述" class="headerlink" title="一、Swing 概述"></a>一、Swing 概述</h1><p>Swing API 是一组可扩展的 GUI 组件，用来创建基于 JAVA 的前端&#x2F; GUI 应用程序。它是建立在 AWT API 之上，并且作为 AWT API 的替代者，因为它的几乎每一个控件都对应 AWT 控件。 Swing 组件遵循模型 – 视图 – 控制器架构来满足下面的准则。</p><ul><li>一个单一的 API 足够支持多种外观和风格。</li><li>API 是模拟驱动的，这样最高层级的 API 不需要有数据。</li><li>API 是使用 Java Bean 模式的，这样 Builder Tools 和 IDE 可以为开发者提供更好的服务来使用它。</li></ul><h2 id="MVC-架构"><a href="#MVC-架构" class="headerlink" title="MVC 架构"></a>MVC 架构</h2><p>Swing API 架构用下列的方式来遵循基于松散的 MVC 架构。</p><ul><li>模型表示组件的数据。</li><li>视图表示组件数据的可视化表示形式。</li><li>控制器接受用户在视图上的输入，并且在组件的数据上反映变化。</li><li>Swing 组件把模型作为一个单独的元素，并且把视图和控制器部分组合成用户界面的元素。使用这种方式，Swing 具有可插拔的外观与风格架构。</li></ul><h2 id="Swing-特点"><a href="#Swing-特点" class="headerlink" title="Swing 特点"></a>Swing 特点</h2><ul><li><strong>轻量级 ——</strong> Swing 组件是独立的本地操作系统的 API，因为 Swing API 控件通常采用纯 JAVA 代码而不是采用底层的操作系统调用来呈现。</li><li><strong>丰富的控件 ——</strong> Swing 提供了一组丰富的先进的控件，如树，页签窗体，滑动条，颜色选择器，表格控件</li><li><strong>高级自定义 ——</strong> Swing 控件可以用非常简单的方法来自定义，因为可视化外观是独立于内部表示的。</li><li><strong>可插拔的外观和风格 ——</strong> 基于 Swing 的 GUI 应用程序的外观和风格可以在运行时根据有效的值改变。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Swing-概述&quot;&gt;&lt;a href=&quot;#一、Swing-概述&quot; class=&quot;headerlink&quot; title=&quot;一、Swing 概述&quot;&gt;&lt;/a&gt;一、Swing 概述&lt;/h1&gt;&lt;p&gt;Swing API 是一组可扩展的 GUI 组件，用来创建基于 JAVA 的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 容器</title>
    <link href="https://hexo.tryrun.top/posts/75aa4e45.html"/>
    <id>https://hexo.tryrun.top/posts/75aa4e45.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十、Swing-容器"><a href="#十、Swing-容器" class="headerlink" title="十、Swing 容器"></a>十、Swing 容器</h1><p>容器是 SWING GUI 组件的组成部分。一个容器提供了一个可以放置组件的空间。在 AWT 中，一个容器是组件本身，并且它增加了功能来添加组件本身。下面是需要考虑的注意事项。</p><ul><li>容器的子类被称为容器。例如 JPanel，JFrame 和 JWindow。</li><li>容器可以仅仅添加组件到自身。</li><li>一个默认的布局使用 setLayout 方法来呈现在每个可以被重写的容器中。</li></ul><h2 id="SWING-容器："><a href="#SWING-容器：" class="headerlink" title="SWING 容器："></a>SWING 容器：</h2><p>下面是当使用 SWING 设计 GUI 事件时常用的容器列表。</p><table><thead><tr><th align="center">序号</th><th align="center">容器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Panel</strong> JPanel 是一个最简单的容器。它提供了任何其他组件可以被放置的空间，包括其他面板。</td></tr><tr><td align="center">2</td><td align="center"><strong>Frame</strong> JFrame 是一个带有标题和边界的顶层窗口。</td></tr><tr><td align="center">3</td><td align="center"><strong>Window</strong> JWindow 对象是一个没有边界和菜单条的顶层窗口。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十、Swing-容器&quot;&gt;&lt;a href=&quot;#十、Swing-容器&quot; class=&quot;headerlink&quot; title=&quot;十、Swing 容器&quot;&gt;&lt;/a&gt;十、Swing 容器&lt;/h1&gt;&lt;p&gt;容器是 SWING GUI 组件的组成部分。一个容器提供了一个可以放置组件的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 环境安装</title>
    <link href="https://hexo.tryrun.top/posts/8ab406ce.html"/>
    <id>https://hexo.tryrun.top/posts/8ab406ce.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Swing-环境安装"><a href="#二、Swing-环境安装" class="headerlink" title="二、Swing 环境安装"></a>二、Swing 环境安装</h1><p>本节将指导你如何在你的机器上下载和设置 Java。请按照以下步骤来设置环境。</p><p>在链接 <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp"><strong>Download Java</strong></a> 上, Java SE 免费提供的。所以你根据你的操作系统下载一个版本。</p><p>在你的机器上，按照说明下载 java 和运行 <strong>.exe</strong> 来安装 Java。一旦在你的机器上安装了 Java，你将需要设置环境变量来指向正确的安装目录：</p><h2 id="设置-windows-2000-x2F-XP-的路径："><a href="#设置-windows-2000-x2F-XP-的路径：" class="headerlink" title="设置 windows 2000&#x2F;XP 的路径："></a>设置 windows 2000&#x2F;XP 的路径：</h2><p>假设你已经在 <em>c:\Program Files\java\jdk</em> 目录上安装了 Java：</p><ul><li>右击 ‘我的电脑’，并且选择 ‘属性’。</li><li>点击 ‘高级’ 标签下的 ‘环境变量’ 按钮。</li><li>现在更改 ‘路径’ 变量，以便它也包含 Java 可执行文件的路径。例如，如果路径当前设置为 <code>C:\WINDOWS\SYSTEM32</code>，然后更改你的路径为 <code>C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin</code>。</li></ul><h2 id="设置-windows-95-x2F-98-x2F-ME-的路径："><a href="#设置-windows-95-x2F-98-x2F-ME-的路径：" class="headerlink" title="设置 windows 95&#x2F;98&#x2F;ME 的路径："></a>设置 windows 95&#x2F;98&#x2F;ME 的路径：</h2><p>假设你已经在 <em>c:\Program Files\java\jdk</em> 目录上安装了 Java：</p><ul><li>编辑 <code>C:\autoexec.bat</code> 文件，并且在最后添加下行： <code>SET PATH=%PATH%;C:\Program Files\java\jdk\bin</code></li></ul><h2 id="设置-Linux，UNIX，Solaris，FreeBSD-的路径："><a href="#设置-Linux，UNIX，Solaris，FreeBSD-的路径：" class="headerlink" title="设置 Linux，UNIX，Solaris，FreeBSD 的路径："></a>设置 Linux，UNIX，Solaris，FreeBSD 的路径：</h2><p>环境变量路径应该设置为指向 java 二进制文件已经安装的位置。如果你在这方面遇到困难，参考你的 shell 文档。</p><p>例如，如果你使用 <em>bash</em> 作为你的 shell，然后你将添加下行到最后 <code>.bashrc: export PATH=/path/to/java:$PATH</code></p><h2 id="流行的-Java-编辑器："><a href="#流行的-Java-编辑器：" class="headerlink" title="流行的 Java 编辑器："></a>流行的 Java 编辑器：</h2><p>为了编写 Java 程序，你将需要一个文本编辑器。在市场上有甚至更复杂的可用 IDE。但是现在，你可以考虑下列之一：</p><ul><li><strong>Notepad：</strong> 在 Windows 机器上，你可以使用任何简单的文本编辑器，如 Notepad（本教程推荐），TextPad。</li><li><strong>Netbeans：</strong>是一个开源而且免费的 Java IDE，它可以从 <a href="http://www.netbeans.org/index.html">http://www.netbeans.org/index.html</a> 下载。</li><li><strong>Eclipse：</strong> 也是一个 Java IDE，它是由 eclipse 开源社区开发的，可以从 <a href="http://www.eclipse.org/">http://www.eclipse.org/</a> 下载。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、Swing-环境安装&quot;&gt;&lt;a href=&quot;#二、Swing-环境安装&quot; class=&quot;headerlink&quot; title=&quot;二、Swing 环境安装&quot;&gt;&lt;/a&gt;二、Swing 环境安装&lt;/h1&gt;&lt;p&gt;本节将指导你如何在你的机器上下载和设置 Java。请按照以下</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 控件</title>
    <link href="https://hexo.tryrun.top/posts/de462237.html"/>
    <id>https://hexo.tryrun.top/posts/de462237.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、Swing-控件"><a href="#三、Swing-控件" class="headerlink" title="三、Swing 控件"></a>三、Swing 控件</h1><p>每个用户界面考虑有以下三个主要方面：</p><ul><li><strong>UI 元素</strong>： 有用户最终看到并且与之交互的核心视觉元素。GWT 提供了一个大量的广泛使用和常见的元素列表，本教程我们将涉及从基本到复杂的变化。</li><li><strong>布局</strong>： 他们定义应该如何在屏幕上组织 UI 元素，并且提供一个最终的外观和风格给 GUI（图形用户界面）。这部分将在布局这一章涉及。</li><li><strong>行为</strong>： 当用户与 UI 元素交互时，这些事件发生。</li></ul><p>每个 SWING 控件从下列组件类的等级继承属性。</p><table><thead><tr><th align="center">序号</th><th align="center">类 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Component</strong> Container 是 SWING 的非菜单用户界面控件的一个抽象基类。组件代表一个用图形表示的对象</td></tr><tr><td align="center">2</td><td align="center"><strong>Container</strong> Container 是一个组件，它可以包含其他 SWING 组件。</td></tr><tr><td align="center">3</td><td align="center"><strong>JComponent</strong> JComponent 是一个所有 swing UI 组件的基类。为了使用继承自 JComponent 的一个 swing 组件，组件必须是一个包容层次结构，它的根是一个顶层的 Swing 容器。</td></tr></tbody></table><h2 id="SWING-UI-元素"><a href="#SWING-UI-元素" class="headerlink" title="SWING UI 元素:"></a>SWING UI 元素:</h2><p>下列是当使用 SWING 来设计 GUI 时常用的控件列表。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>JLabel</strong> JLabel 对象是一个在容器中放置文本的组件。</td></tr><tr><td align="center">2</td><td align="center"><strong>JButton</strong> 该类创建一个有标签的的按钮。</td></tr><tr><td align="center">3</td><td align="center"><strong>JColorChooser</strong> JColorChooser 提供一个控制面板，设计允许用户操作和选择颜色。</td></tr><tr><td align="center">4</td><td align="center"><strong>JCheck Box</strong> JCheckBox 是一个图形化的组件，它的状态要么是 <strong>on</strong>（true）要么是 <strong>off</strong>（false）。</td></tr><tr><td align="center">5</td><td align="center"><strong>JRadioButton</strong> JRadioButton 类是一个图形化的组件，在一个组中，它的状态要么是 <strong>on</strong>（true）要么是<strong>off</strong>（false）。</td></tr><tr><td align="center">6</td><td align="center"><strong>JList</strong> JList 组件呈现给用户一个滚动的文本项列表。</td></tr><tr><td align="center">7</td><td align="center"><strong>JComboBox</strong> JComboBox 组件呈现给用户一个显示菜单的选择。</td></tr><tr><td align="center">8</td><td align="center"><strong>JTextField</strong> JTextField 对象是一个文本组件，它允许编辑单行文本。</td></tr><tr><td align="center">9</td><td align="center"><strong>JPasswordField</strong> JPasswordField 对象是一个专门用于密码输入的文本组件。</td></tr><tr><td align="center">10</td><td align="center"><strong>JTextArea</strong> JTextArea 对象是一个文本组件，它允许编辑多行文本。</td></tr><tr><td align="center">11</td><td align="center"><strong>ImageIcon</strong> ImageIcon 控件是一个图标界面的实现，它从图像描绘图标</td></tr><tr><td align="center">12</td><td align="center"><strong>JScrollbar</strong> Scrollbar 控件代表一个滚动条组件，为了让用户从值的范围中选择。</td></tr><tr><td align="center">13</td><td align="center"><strong>JOptionPane</strong> JOptionPane 提供了一组提示用户输入值的标准对话框，或者通知他们其他东西。</td></tr><tr><td align="center">14</td><td align="center"><strong>JFileChooser</strong> JFileChooser 控件代表一个对话框窗口，用户可以从该对话框窗口选择一个文件。</td></tr><tr><td align="center">15</td><td align="center"><strong>JProgressBar</strong> 随着任务完成的进展，进度条显示任务完成的百分比。</td></tr><tr><td align="center">16</td><td align="center"><strong>JSlider</strong> JSlider 让用户在有界区间内通过滑动旋钮图形化地选择一个值。</td></tr><tr><td align="center">17</td><td align="center"><strong>JSpinner</strong> JSpinner 是一个单行输入字段，它让用户从一个有序序列中选择一个数字或者一个对象值。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、Swing-控件&quot;&gt;&lt;a href=&quot;#三、Swing-控件&quot; class=&quot;headerlink&quot; title=&quot;三、Swing 控件&quot;&gt;&lt;/a&gt;三、Swing 控件&lt;/h1&gt;&lt;p&gt;每个用户界面考虑有以下三个主要方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件类</title>
    <link href="https://hexo.tryrun.top/posts/ccc49d6d.html"/>
    <id>https://hexo.tryrun.top/posts/ccc49d6d.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、Swing-事件类"><a href="#五、Swing-事件类" class="headerlink" title="五、Swing 事件类"></a>五、Swing 事件类</h1><p>事件类代表事件。Java 提供各种事件类，但是我们将讨论更频繁使用的那些事件类。</p><h2 id="EventObject-类"><a href="#EventObject-类" class="headerlink" title="EventObject 类"></a>EventObject 类</h2><p>它是派生所有事件状态对象的根类。所有事件都是用对象，<strong>源</strong>的引用来构造的，即逻辑上认为是问题最初发生的事件的对象。这个类定义在 java.util 包中。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>下面是 <strong>java.util.EventObject</strong> 类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventObject</span></span><br><span class="line">   <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>下面是 <strong>java.util.EventObject</strong> 类的字段：</p><ul><li><strong>protected Object source</strong> –- 事件最初发生的对象。</li></ul><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><table><thead><tr><th align="center">S.N.</th><th align="center">构造函数 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>EventObject(Object source)</strong> 构造一个典型的事件。</td></tr></tbody></table><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th align="center">S.N.</th><th align="center">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Object getSource()</strong> 事件最初发生的对象。</td></tr><tr><td align="center">2</td><td align="center"><strong>String toString()</strong> 返回这个 EventObject 的字符串表示。</td></tr></tbody></table><h2 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h2><p>这个类从下面的类中继承方法：</p><ul><li>java.lang.Object</li></ul><h2 id="SWING-事件类："><a href="#SWING-事件类：" class="headerlink" title="SWING 事件类："></a>SWING 事件类：</h2><p>下面是常用的事件类。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>AWTEvent</strong> 它是所有 SWING 事件的根事件类。这个类和它的子类取代了最初的 java.awt.Event 类。</td></tr><tr><td align="center">2</td><td align="center"><strong>ActionEvent</strong> 当单击按钮或双点击列表的项时，生成 ActionEvent。</td></tr><tr><td align="center">3</td><td align="center"><strong>InputEvent</strong> InputEvent 类是所有组件层输入事件的根事件类。</td></tr><tr><td align="center">4</td><td align="center"><strong>KeyEvent</strong> 在按下一个字符时，按键事件生成。</td></tr><tr><td align="center">5</td><td align="center"><strong>MouseEvent</strong> 这个事件表明一个鼠标动作发生在一个组件中。</td></tr><tr><td align="center">6</td><td align="center"><strong>WindowEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">7</td><td align="center"><strong>AdjustmentEvent</strong> 这个类的对象代表由可调整的对象发出的调整事件。</td></tr><tr><td align="center">8</td><td align="center"><strong>ComponentEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">9</td><td align="center"><strong>ContainerEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">10</td><td align="center"><strong>MouseMotionEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">11</td><td align="center"><strong>PaintEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、Swing-事件类&quot;&gt;&lt;a href=&quot;#五、Swing-事件类&quot; class=&quot;headerlink&quot; title=&quot;五、Swing 事件类&quot;&gt;&lt;/a&gt;五、Swing 事件类&lt;/h1&gt;&lt;p&gt;事件类代表事件。Java 提供各种事件类，但是我们将讨论更频繁使用的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件处理</title>
    <link href="https://hexo.tryrun.top/posts/731f4877.html"/>
    <id>https://hexo.tryrun.top/posts/731f4877.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、Swing-事件处理"><a href="#四、Swing-事件处理" class="headerlink" title="四、Swing 事件处理"></a>四、Swing 事件处理</h1><h2 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h2><p>改变对象的状态被称为事件，即事件描述源的状态变化。事件产生用户与图形用户界面组件交互的结果。例如，点击一个按钮，移动鼠标，通过键盘输入一个字符，从列表中选择一个项目，滚动页面都是导致一个事件发生的活动。</p><h2 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h2><p>事件可以大致分为两类:：</p><ul><li><strong>前台事件</strong> - 这些事件需要用户的直接互动。它们是由在图形用户界面中人与图形组件交互的结果而产生的。例如，点击一个按钮，移动鼠标，通过键盘输入一个字符，从列表中选择一个项目，滚动页面等。</li><li><strong>后台事件</strong> - 这些事件需要最终用户的交互，它们被称为后台事件。操作系统的中断，硬件或软件故障，计时器过期，操作完成都是后台事件的例子。</li></ul><h2 id="什么是事件处理？"><a href="#什么是事件处理？" class="headerlink" title="什么是事件处理？"></a>什么是事件处理？</h2><p>事件处理是一种机制，如果一个事件发生时，它控制该事件，并且决定应该会发生什么。这种机制具有被称为事件处理程序的代码，当一个事件发生时，它是可执行的。Java 使用代理事件模型来处理事件。该模型定义了标准的机制来生成和处理事件。让我们来简要介绍这个模型。</p><p>代理事件模型具有下列主要参与者，即：</p><ul><li><strong>源</strong> - 源是一个对象，事件发生在该对象上。源负责提供发生事件的信息给它的处理器。Java 提供源对象的类。</li><li><strong>监听器</strong> - 它也被称为作为事件处理。监听器负责产生对一个事件的响应。从 Java 实现的角度来看，监听器也是一个对象。监听器等待直到它接收到一个事件。一旦收到该事件，监听器进程的事件就返回。</li></ul><p>这种方法的好处是，用户界面逻辑完全从生成事件的逻辑中分开。用户界面元素能够把事件的处理委派给一段单独的代码。在这个模型中，监听器需要用源对象注册，以便监听器能够接收事件通知。这是一个有效的处理事件的方式，因为这些事件通知只发送给那些想要接收它们的监听器。</p><h2 id="事件处理所涉及的步骤"><a href="#事件处理所涉及的步骤" class="headerlink" title="事件处理所涉及的步骤"></a>事件处理所涉及的步骤</h2><ul><li>用户单击按钮，然后生成事件。</li><li>现在有关事件类的对象是自动创建的，源和事件的信息在同一对象得到填充。</li><li>事件对象被转发到注册监听器类的方法中。</li><li>该方法现在得到执行并且返回。</li></ul><h2 id="有关监听器要记住的要点"><a href="#有关监听器要记住的要点" class="headerlink" title="有关监听器要记住的要点"></a>有关监听器要记住的要点</h2><ul><li>为了设计一个监听器类，我们必须开发一些监听器接口。这些监听器接口预测一些公共的抽象回调方法，这些方法必须由监听器类来实现。</li><li>如果你没有实现任何预定义的接口，那么你的类不能作为源对象的监听器类。</li></ul><h2 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h2><p>这些方法由 API 提供者来提供，由应用程序员来定义，并且由应用程序开发者来调用。这里的回调方法代表一个事件方法。响应一个事件 java jre 将触发回调方法。所有这些回调方法在监听器接口中被提供。</p><p>如果一个组件需要一些监听器监听它的事件，源必须自己注册给监听器。</p><h2 id="事件处理例子"><a href="#事件处理例子" class="headerlink" title="事件处理例子"></a>事件处理例子</h2><p>使用你选择的任何编辑器创建下面的 Java 程序，在 <strong>D:&#x2F; &gt; SWING &gt; com &gt; tutorialspoint &gt; gui &gt;</strong></p><p><em>SwingControlDemo.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint.gui;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwingControlDemo</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> JFrame mainFrame;</span><br><span class="line">   <span class="keyword">private</span> JLabel headerLabel;</span><br><span class="line">   <span class="keyword">private</span> JLabel statusLabel;</span><br><span class="line">   <span class="keyword">private</span> JPanel controlPanel;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SwingControlDemo</span><span class="params">()</span>&#123;</span><br><span class="line">      prepareGUI();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">SwingControlDemo</span> <span class="variable">swingControlDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SwingControlDemo</span>();  </span><br><span class="line">      swingControlDemo.showEventDemo();       </span><br><span class="line">   &#125;      </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareGUI</span><span class="params">()</span>&#123;</span><br><span class="line">      mainFrame = <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Java SWING Examples&quot;</span>);</span><br><span class="line">      mainFrame.setSize(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">      mainFrame.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">      headerLabel = <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;&quot;</span>,JLabel.CENTER );</span><br><span class="line">      statusLabel = <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;&quot;</span>,JLabel.CENTER);        </span><br><span class="line">      statusLabel.setSize(<span class="number">350</span>,<span class="number">100</span>);</span><br><span class="line">      mainFrame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent windowEvent)</span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">         &#125;        </span><br><span class="line">      &#125;);    </span><br><span class="line">      controlPanel = <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">      controlPanel.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());</span><br><span class="line">      mainFrame.add(headerLabel);</span><br><span class="line">      mainFrame.add(controlPanel);</span><br><span class="line">      mainFrame.add(statusLabel);</span><br><span class="line">      mainFrame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showEventDemo</span><span class="params">()</span>&#123;</span><br><span class="line">      headerLabel.setText(<span class="string">&quot;Control in action: Button&quot;</span>); </span><br><span class="line">      <span class="type">JButton</span> <span class="variable">okButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">      <span class="type">JButton</span> <span class="variable">submitButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Submit&quot;</span>);</span><br><span class="line">      <span class="type">JButton</span> <span class="variable">cancelButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Cancel&quot;</span>);</span><br><span class="line">      okButton.setActionCommand(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">      submitButton.setActionCommand(<span class="string">&quot;Submit&quot;</span>);</span><br><span class="line">      cancelButton.setActionCommand(<span class="string">&quot;Cancel&quot;</span>);</span><br><span class="line">      okButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ButtonClickListener</span>()); </span><br><span class="line">      submitButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ButtonClickListener</span>()); </span><br><span class="line">      cancelButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ButtonClickListener</span>()); </span><br><span class="line">      controlPanel.add(okButton);</span><br><span class="line">      controlPanel.add(submitButton);</span><br><span class="line">      controlPanel.add(cancelButton);       </span><br><span class="line">      mainFrame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ButtonClickListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> e.getActionCommand();  </span><br><span class="line">         <span class="keyword">if</span>( command.equals( <span class="string">&quot;OK&quot;</span> ))  &#123;</span><br><span class="line">            statusLabel.setText(<span class="string">&quot;Ok Button clicked.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>( command.equals( <span class="string">&quot;Submit&quot;</span> ) )  &#123;</span><br><span class="line">            statusLabel.setText(<span class="string">&quot;Submit Button clicked.&quot;</span>); </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>  &#123;</span><br><span class="line">            statusLabel.setText(<span class="string">&quot;Cancel Button clicked.&quot;</span>);</span><br><span class="line">         &#125;      </span><br><span class="line">      &#125;     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令提示符编译该程序。转到 <strong>D:&#x2F; &gt; SWING</strong> 并输入下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\AWT&gt;javac com\tutorialspoint\gui\SwingControlDemo.java</span><br></pre></td></tr></table></figure><p>如果没有错误出现，就意味着编译成功。使用下面的命令来运行程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\AWT&gt;java com.tutorialspoint.gui.SwingControlDemo</span><br></pre></td></tr></table></figure><p>验证下面的输出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四、Swing-事件处理&quot;&gt;&lt;a href=&quot;#四、Swing-事件处理&quot; class=&quot;headerlink&quot; title=&quot;四、Swing 事件处理&quot;&gt;&lt;/a&gt;四、Swing 事件处理&lt;/h1&gt;&lt;h2 id=&quot;什么是事件？&quot;&gt;&lt;a href=&quot;#什么是事件？&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件监听器</title>
    <link href="https://hexo.tryrun.top/posts/94a53e1.html"/>
    <id>https://hexo.tryrun.top/posts/94a53e1.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、Swing-事件监听器"><a href="#六、Swing-事件监听器" class="headerlink" title="六、Swing 事件监听器"></a>六、Swing 事件监听器</h1><p>事件监听器代表负责处理事件的接口。Java 提供了各种事件监听器类，但我们将讨论更频繁使用的那些事件监听器类。一个事件监听器的每个方法有一个参数作为一个对象，该对象是 EventObject 类的子类。例如，鼠标事件监听器的方法将接受 MouseEvent 的实例，其中 MouseEvent 是 EventObject 派生的。</p><h2 id="EventListner-接口"><a href="#EventListner-接口" class="headerlink" title="EventListner 接口"></a>EventListner 接口</h2><p>它是一个标记接口，每一个监听器接口必须扩展它。这个类定义在 java.util 包中。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>下面是 <strong>java.util.EventListener</strong> 接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span></span><br></pre></td></tr></table></figure><h2 id="SWING-事件监听器接口："><a href="#SWING-事件监听器接口：" class="headerlink" title="SWING 事件监听器接口："></a>SWING 事件监听器接口：</h2><p>下面是常用的事件监听器列表。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>ActionListener</strong> 这个接口用于接收动作事件。</td></tr><tr><td align="center">2</td><td align="center"><strong>ComponentListener</strong> 这个接口用于接收组件事件。</td></tr><tr><td align="center">3</td><td align="center"><strong>ItemListener</strong> 这个接口用于接收项目事件。</td></tr><tr><td align="center">4</td><td align="center"><strong>KeyListener</strong> 这个接口用于接收按键事件。</td></tr><tr><td align="center">5</td><td align="center"><strong>MouseListener</strong> 这个接口用于接收鼠标事件。</td></tr><tr><td align="center">6</td><td align="center"><strong>WindowListener</strong> 这个接口用于接收窗口事件。</td></tr><tr><td align="center">7</td><td align="center"><strong>AdjustmentListener</strong> 这个接口用于接收调整事件。</td></tr><tr><td align="center">8</td><td align="center"><strong>ContainerListener</strong> 这个接口用于接收容器事件。</td></tr><tr><td align="center">9</td><td align="center"><strong>MouseMotionListener</strong> 这个接口用于接收鼠标移动事件。</td></tr><tr><td align="center">10</td><td align="center"><strong>FocusListener</strong> 这个接口用于接收焦点事件。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、Swing-事件监听器&quot;&gt;&lt;a href=&quot;#六、Swing-事件监听器&quot; class=&quot;headerlink&quot; title=&quot;六、Swing 事件监听器&quot;&gt;&lt;/a&gt;六、Swing 事件监听器&lt;/h1&gt;&lt;p&gt;事件监听器代表负责处理事件的接口。Java 提供了各</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件适配器</title>
    <link href="https://hexo.tryrun.top/posts/7123338f.html"/>
    <id>https://hexo.tryrun.top/posts/7123338f.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、Swing-事件适配器"><a href="#七、Swing-事件适配器" class="headerlink" title="七、Swing 事件适配器"></a>七、Swing 事件适配器</h1><p>适配器是用于接收各种事件的抽象类。这些类中的方法是空的。这些类的存在是为了方便创建监听器对象。</p><h2 id="SWING-适配器："><a href="#SWING-适配器：" class="headerlink" title="SWING 适配器："></a>SWING 适配器：</h2><p>下面是当在 SWING 中监听 GUI 事件时常用的适配器列表。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">适配器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>FocusAdapter</strong> 用于接收焦点事件的抽象适配器类。</td></tr><tr><td align="center">2</td><td align="center"><strong>KeyAdapter</strong> 用于接收按键事件的抽象适配器类。</td></tr><tr><td align="center">3</td><td align="center"><strong>MouseAdapter</strong> 用于接收鼠标事件的抽象适配器类。</td></tr><tr><td align="center">4</td><td align="center"><strong>MouseMotionAdapter</strong> 用于接收鼠标移动事件的抽象适配器类。</td></tr><tr><td align="center">5</td><td align="center"><strong>WindowAdapter</strong> 用于接收窗口事件的抽象适配器类。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、Swing-事件适配器&quot;&gt;&lt;a href=&quot;#七、Swing-事件适配器&quot; class=&quot;headerlink&quot; title=&quot;七、Swing 事件适配器&quot;&gt;&lt;/a&gt;七、Swing 事件适配器&lt;/h1&gt;&lt;p&gt;适配器是用于接收各种事件的抽象类。这些类中的方法是空</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 布局</title>
    <link href="https://hexo.tryrun.top/posts/6d7432f2.html"/>
    <id>https://hexo.tryrun.top/posts/6d7432f2.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八、Swing-布局"><a href="#八、Swing-布局" class="headerlink" title="八、Swing 布局"></a>八、Swing 布局</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>布局意味着容器内组件的安排。我们可以说，用其他方式在容器的特定位置放置组件。布局控件的任务是由布局管理器自动完成的。</p><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><p>布局管理器自动放置容器内的所有组件。如果我们不使用布局管理器，然后组件也能由默认的布局管理器放置。手工布局控件也是可能的，但是由于以下两个原因，它变得非常困难。</p><ul><li>在容器内处理大量的控件是非常繁琐的。</li><li>通常当我们需要安排组件时，没有给出该组件的宽度和高度信息，。</li></ul><p>Java 为我们提供了各种布局管理器来放置控件。属性如大小，形状和排列从一个布局管理器到其他的布局管理器变化。当小应用程序或应用程序窗口的大小改变时，组件的大小，形状和排列的组件也相应的变化，即布局管理器适应小应用程序视图或应用程序窗口的尺寸。</p><p>布局管理器与每一个容器对象相关联。每一个布局管理器是实现布局管理接口的类的一个对象。</p><p>下面是接口定义的布局管理器的功能。</p><table><thead><tr><th align="center">序号</th><th align="center">接口 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>LayoutManager</strong> LayoutManager 接口声明那些需要由类来实现的方法，这些类的对象将充当一个布局管理器。</td></tr><tr><td align="center">2</td><td align="center"><strong>LayoutManager2</strong> LayoutManager2 是 LayoutManager 的子接口。这个接口是为那些知道如何基于布局约束对象来布局容器的类。</td></tr></tbody></table><h2 id="AWT-布局管理器类："><a href="#AWT-布局管理器类：" class="headerlink" title="AWT 布局管理器类："></a>AWT 布局管理器类：</h2><p>下面是当使用 AWT 设计 GUI 时常用的控件列表。</p><table><thead><tr><th align="center">序号</th><th align="center">布局管理器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>BorderLayout</strong> Borderlayout 安排组件适应于五个地区：东、西、北、南和中心。</td></tr><tr><td align="center">2</td><td align="center"><strong>CardLayout</strong> CardLayout 对象把容器中的每一个组件看成一个卡片。一次只有一个卡片是可见的。</td></tr><tr><td align="center">3</td><td align="center"><strong>FlowLayout</strong> FlowLayout 是默认的布局。它用定向流动来布局组件。</td></tr><tr><td align="center">4</td><td align="center"><strong>GridLayout</strong> GridLayout 用一个矩形网格形式来管理组件。</td></tr><tr><td align="center">5</td><td align="center"><strong>GridBagLayout</strong> 这是最灵活的布局管理器类。在不需要相同大小的组件的情况下，GridBagLayout 对象垂直、水平或沿着它们的基线来排列组件。</td></tr><tr><td align="center">6</td><td align="center"><strong>GroupLayout</strong> GroupLayout 分层次地归类组件，为了在一个容器中放置它们。</td></tr><tr><td align="center">7</td><td align="center"><strong>SpringLayout</strong> SpringLayout 根据一组约束安置与它相关的容器的孩子。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八、Swing-布局&quot;&gt;&lt;a href=&quot;#八、Swing-布局&quot; class=&quot;headerlink&quot; title=&quot;八、Swing 布局&quot;&gt;&lt;/a&gt;八、Swing 布局&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 菜单类</title>
    <link href="https://hexo.tryrun.top/posts/121e0f73.html"/>
    <id>https://hexo.tryrun.top/posts/121e0f73.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="九、Swing-菜单类"><a href="#九、Swing-菜单类" class="headerlink" title="九、Swing 菜单类"></a>九、Swing 菜单类</h1><p>正如我们所知道每个顶层窗口有一个菜单栏与它相关联。这个菜单栏包括各种菜单可用的选择给最终用户。而且每个选择包含被称为下拉菜单的选项列表。菜单和菜单项的控件都是 MenuComponent 类的子类。</p><h2 id="菜单控件"><a href="#菜单控件" class="headerlink" title="菜单控件"></a>菜单控件</h2><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>JMenuBar</strong> JMenuBar 对象是与顶层窗口相关联的</td></tr><tr><td align="center">2</td><td align="center"><strong>JMenuItem</strong> 菜单中的项目必须属于 JMenuItem 或任何它的子类。</td></tr><tr><td align="center">3</td><td align="center"><strong>JMenu</strong> JMenu 对象是从菜单栏中显示的一个下拉菜单组件。</td></tr><tr><td align="center">4</td><td align="center"><strong>JCheckBoxMenuItem</strong> JCheckBoxMenuItem 是 JMenuItem 的子类。</td></tr><tr><td align="center">5</td><td align="center"><strong>JRadioButtonMenuItem</strong> JRadioButtonMenuItem 是 JMenuItem 的子类。</td></tr><tr><td align="center">6</td><td align="center"><strong>JPopupMenu</strong> JPopupMenu 可以在一个组件内的指定位置动态地弹出。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;九、Swing-菜单类&quot;&gt;&lt;a href=&quot;#九、Swing-菜单类&quot; class=&quot;headerlink&quot; title=&quot;九、Swing 菜单类&quot;&gt;&lt;/a&gt;九、Swing 菜单类&lt;/h1&gt;&lt;p&gt;正如我们所知道每个顶层窗口有一个菜单栏与它相关联。这个菜单栏包括各种</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 概述</title>
    <link href="https://hexo.tryrun.top/posts/d27442db.html"/>
    <id>https://hexo.tryrun.top/posts/d27442db.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Zookeeper-概述"><a href="#一、Zookeeper-概述" class="headerlink" title="一、Zookeeper 概述"></a>一、Zookeeper 概述</h1><p>ZooKeeper是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。ZooKeeper通过其简单的架构和API解决了这个问题。ZooKeeper允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。</p><p>ZooKeeper框架最初是在“Yahoo!”上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态。</p><p>在进一步深入之前，我们了解关于分布式应用的一两件事情是很重要的。因此，让我们开始分布式应用的概述的快速讨论。</p><h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>分布式应用可以在给定时间（同时）在网络中的多个系统上运行，通过协调它们以快速有效的方式完成特定任务。通常来说，对于复杂而耗时的任务，非分布式应用（运行在单个系统中）需要几个小时才能完成，而分布式应用通过使用所有系统涉及的计算能力可以在几分钟内完成。</p><p>通过将分布式应用配置为在更多系统上运行，可以进一步减少完成任务的时间。分布式应用正在运行的一组系统称为<strong>集群</strong>，而在集群中运行的每台机器被称为<strong>节点</strong>。</p><p>分布式应用有两部分， <strong>Server（服务器）</strong> 和 <strong>Client（客户端）</strong> 应用程序。服务器应用程序实际上是分布式的，并具有通用接口，以便客户端可以连接到集群中的任何服务器并获得相同的结果。 客户端应用程序是与分布式应用进行交互的工具。</p><h3 id="分布式应用的优点"><a href="#分布式应用的优点" class="headerlink" title="分布式应用的优点"></a>分布式应用的优点</h3><ul><li><strong>可靠性</strong> - 单个或几个系统的故障不会使整个系统出现故障。</li><li><strong>可扩展性</strong> - 可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。</li><li><strong>透明性</strong> - 隐藏系统的复杂性，并将其显示为单个实体&#x2F;应用程序。</li></ul><h3 id="分布式应用的挑战"><a href="#分布式应用的挑战" class="headerlink" title="分布式应用的挑战"></a>分布式应用的挑战</h3><ul><li><strong>竞争条件</strong> - 两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。</li><li><strong>死锁</strong> - 两个或多个操作等待彼此无限期完成。</li><li><strong>不一致</strong> - 数据的部分失败。</li></ul><h2 id="什么是Apache-ZooKeeper？"><a href="#什么是Apache-ZooKeeper？" class="headerlink" title="什么是Apache ZooKeeper？"></a>什么是Apache ZooKeeper？</h2><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p><p>ZooKeeper提供的常见服务如下 :</p><ul><li><strong>命名服务</strong> - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。</li><li><strong>配置管理</strong> - 加入节点的最近的和最新的系统配置信息。</li><li><strong>集群管理</strong> - 实时地在集群和节点状态中加入&#x2F;离开节点。</li><li><strong>选举算法</strong> - 选举一个节点作为协调目的的leader。</li><li><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。</li><li><strong>高度可靠的数据注册表</strong> - 即使在一个或几个节点关闭时也可以获得数据。</li></ul><p>分布式应用程序提供了很多好处，但它们也抛出了一些复杂和难以解决的挑战。ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用<strong>故障安全同步方法</strong>进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用<strong>原子性</strong>解析。</p><h2 id="ZooKeeper的好处"><a href="#ZooKeeper的好处" class="headerlink" title="ZooKeeper的好处"></a>ZooKeeper的好处</h2><p>以下是使用ZooKeeper的好处：</p><ul><li><strong>简单的分布式协调过程</strong></li><li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li><li><strong>有序的消息</strong></li><li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li><li><strong>可靠性</strong></li><li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Zookeeper-概述&quot;&gt;&lt;a href=&quot;#一、Zookeeper-概述&quot; class=&quot;headerlink&quot; title=&quot;一、Zookeeper 概述&quot;&gt;&lt;/a&gt;一、Zookeeper 概述&lt;/h1&gt;&lt;p&gt;ZooKeeper是一种分布式协调服务，用于</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 工作流</title>
    <link href="https://hexo.tryrun.top/posts/21b85715.html"/>
    <id>https://hexo.tryrun.top/posts/21b85715.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、Zookeeper-工作流"><a href="#三、Zookeeper-工作流" class="headerlink" title="三、Zookeeper 工作流"></a>三、Zookeeper 工作流</h1><p>一旦ZooKeeper集合启动，它将等待客户端连接。客户端将连接到ZooKeeper集合中的一个节点。它可以是leader或follower节点。一旦客户端被连接，节点将向特定客户端分配会话ID并向该客户端发送确认。如果客户端没有收到确认，它将尝试连接ZooKeeper集合中的另一个节点。 一旦连接到节点，客户端将以有规律的间隔向节点发送心跳，以确保连接不会丢失。</p><ul><li><strong>如果客户端想要读取特定的znode，</strong>它将会向具有znode路径的节点发送<strong>读取请求</strong>，并且节点通过从其自己的数据库获取来返回所请求的znode。为此，在ZooKeeper集合中读取速度很快。</li><li><strong>如果客户端想要将数据存储在ZooKeeper集合中</strong>，则会将znode路径和数据发送到服务器。连接的服务器将该请求转发给leader，然后leader将向所有的follower重新发出写入请求。如果只有大部分节点成功响应，而写入请求成功，则成功返回代码将被发送到客户端。 否则，写入请求失败。绝大多数节点被称为 <strong>Quorum</strong> 。</li></ul><h2 id="ZooKeeper集合中的节点"><a href="#ZooKeeper集合中的节点" class="headerlink" title="ZooKeeper集合中的节点"></a>ZooKeeper集合中的节点</h2><p>让我们分析在ZooKeeper集合中拥有不同数量的节点的效果。</p><ul><li>如果我们有<strong>单个节点</strong>，则当该节点故障时，ZooKeeper集合将故障。它有助于“单点故障”，不建议在生产环境中使用。</li><li>如果我们有<strong>两个节点</strong>而一个节点故障，我们没有占多数，因为两个中的一个不是多数。</li><li>如果我们有<strong>三个节点</strong>而一个节点故障，那么我们有大多数，因此，这是最低要求。ZooKeeper集合在实际生产环境中必须至少有三个节点。</li><li>如果我们有<strong>四个节点</strong>而两个节点故障，它将再次故障。类似于有三个节点，额外节点不用于任何目的，因此，最好添加奇数的节点，例如3，5，7。</li></ul><p>我们知道写入过程比ZooKeeper集合中的读取过程要贵，因为所有节点都需要在数据库中写入相同的数据。因此，对于平衡的环境拥有较少数量（例如3，5，7）的节点比拥有大量的节点要好。</p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">写入（write）</td><td align="center">写入过程由leader节点处理。leader将写入请求转发到所有znode，并等待znode的回复。如果一半的znode回复，则写入过程完成。</td></tr><tr><td align="center">读取（read）</td><td align="center">读取由特定连接的znode在内部执行，因此不需要与集群进行交互。</td></tr><tr><td align="center">复制数据库（replicated database）</td><td align="center">它用于在zookeeper中存储数据。每个znode都有自己的数据库，每个znode在一致性的帮助下每次都有相同的数据。</td></tr><tr><td align="center">Leader</td><td align="center">Leader是负责处理写入请求的Znode。</td></tr><tr><td align="center">Follower</td><td align="center">follower从客户端接收写入请求，并将它们转发到leader znode。</td></tr><tr><td align="center">请求处理器（request processor）</td><td align="center">只存在于leader节点。它管理来自follower节点的写入请求。</td></tr><tr><td align="center">原子广播（atomic broadcasts）</td><td align="center">负责广播从leader节点到follower节点的变化。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、Zookeeper-工作流&quot;&gt;&lt;a href=&quot;#三、Zookeeper-工作流&quot; class=&quot;headerlink&quot; title=&quot;三、Zookeeper 工作流&quot;&gt;&lt;/a&gt;三、Zookeeper 工作流&lt;/h1&gt;&lt;p&gt;一旦ZooKeeper集合启动，它将</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 基础</title>
    <link href="https://hexo.tryrun.top/posts/348a7282.html"/>
    <id>https://hexo.tryrun.top/posts/348a7282.html</id>
    <published>2023-06-23T14:25:26.409Z</published>
    <updated>2023-06-23T14:25:26.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Zookeeper-基础"><a href="#二、Zookeeper-基础" class="headerlink" title="二、Zookeeper 基础"></a>二、Zookeeper 基础</h1><p>在深入了解ZooKeeper的运作之前，让我们来看看ZooKeeper的基本概念。我们将在本章中讨论以下主题：<br>1、Architecture（架构）<br>2、Hierarchical namespace（层次命名空间）<br>3、Session（会话）<br>4、Watches（监视）</p><h2 id="ZooKeeper的架构"><a href="#ZooKeeper的架构" class="headerlink" title="ZooKeeper的架构"></a>ZooKeeper的架构</h2><p>作为ZooKeeper架构的一部分的每个组件在下表中进行了说明。</p><table><thead><tr><th align="center">部分</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Client（客户端）</td><td align="center">客户端，我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。</td></tr><tr><td align="center">Server（服务器）</td><td align="center">服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。</td></tr><tr><td align="center">Ensemble</td><td align="center">ZooKeeper服务器组。形成ensemble所需的最小节点数为3。</td></tr><tr><td align="center">Leader</td><td align="center">服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。</td></tr><tr><td align="center">Follower</td><td align="center">跟随leader指令的服务器节点。</td></tr></tbody></table><h2 id="层次命名空间"><a href="#层次命名空间" class="headerlink" title="层次命名空间"></a>层次命名空间</h2><p>下图描述了用于内存表示的ZooKeeper文件系统的树结构。ZooKeeper节点称为 <strong>znode</strong> 。每个znode由一个名称标识，并用路径(&#x2F;)序列分隔。</p><ul><li>在图中，首先有一个由“&#x2F;”分隔的znode。在根目录下，你有两个逻辑命名空间 <strong>config</strong> 和 <strong>workers</strong> 。</li><li><strong>config</strong> 命名空间用于集中式配置管理，<strong>workers</strong> 命名空间用于命名。</li><li>在 <strong>config</strong> 命名空间下，每个znode最多可存储1MB的数据。这与UNIX文件系统相类似，除了父znode也可以存储数据。这种结构的主要目的是存储同步数据并描述znode的元数据。此结构称为 <strong>ZooKeeper数据模型</strong>。</li></ul><p>ZooKeeper数据模型中的每个znode都维护着一个 <strong>stat</strong> 结构。一个stat仅提供一个znode的<strong>元数据</strong>。它由版本号，操作控制列表(ACL)，时间戳和数据长度组成。</p><ul><li><strong>版本号</strong> - 每个znode都有版本号，这意味着每当与znode相关联的数据发生变化时，其对应的版本号也会增加。当多个zookeeper客户端尝试在同一znode上执行操作时，版本号的使用就很重要。</li><li><strong>操作控制列表(ACL)</strong> - ACL基本上是访问znode的认证机制。它管理所有znode读取和写入操作。</li><li><strong>时间戳</strong> - 时间戳表示创建和修改znode所经过的时间。它通常以毫秒为单位。ZooKeeper从“事务ID”(zxid)标识znode的每个更改。<strong>Zxid</strong> 是唯一的，并且为每个事务保留时间，以便你可以轻松地确定从一个请求到另一个请求所经过的时间。</li><li><strong>数据长度</strong> - 存储在znode中的数据总量是数据长度。你最多可以存储1MB的数据。</li></ul><h3 id="Znode的类型"><a href="#Znode的类型" class="headerlink" title="Znode的类型"></a>Znode的类型</h3><p>Znode被分为持久（persistent）节点，顺序（sequential）节点和临时（ephemeral）节点。</p><ul><li><strong>持久节点</strong> - 即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。</li><li><strong>临时节点</strong> - 客户端活跃时，临时节点就是有效的。当客户端与ZooKeeper集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在leader选举中起着重要作用。</li><li><strong>顺序节点</strong> - 顺序节点可以是持久的或临时的。当一个新的znode被创建为一个顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。例如，如果将具有路径 <strong>&#x2F;myapp</strong> 的znode创建为顺序节点，则ZooKeeper会将路径更改为 <strong>&#x2F;myapp0000000001</strong> ，并将下一个序列号设置为0000000002。如果两个顺序节点是同时创建的，那么ZooKeeper不会对每个znode使用相同的数字。顺序节点在锁定和同步中起重要作用。</li></ul><h2 id="Sessions（会话）"><a href="#Sessions（会话）" class="headerlink" title="Sessions（会话）"></a>Sessions（会话）</h2><p>会话对于ZooKeeper的操作非常重要。会话中的请求按FIFO顺序执行。一旦客户端连接到服务器，将建立会话并向客户端分配<strong>会话ID</strong> 。</p><p>客户端以特定的时间间隔发送<strong>心跳</strong>以保持会话有效。如果ZooKeeper集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。</p><p>会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。</p><h2 id="Watches（监视）"><a href="#Watches（监视）" class="headerlink" title="Watches（监视）"></a>Watches（监视）</h2><p>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。</p><p>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、Zookeeper-基础&quot;&gt;&lt;a href=&quot;#二、Zookeeper-基础&quot; class=&quot;headerlink&quot; title=&quot;二、Zookeeper 基础&quot;&gt;&lt;/a&gt;二、Zookeeper 基础&lt;/h1&gt;&lt;p&gt;在深入了解ZooKeeper的运作之前，让我</summary>
      
    
    
    
    
  </entry>
  
</feed>
