<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云遇未晚</title>
  
  <subtitle>大自然的搬运工</subtitle>
  <link href="https://hexo.tryrun.top/atom.xml" rel="self"/>
  
  <link href="https://hexo.tryrun.top/"/>
  <updated>2023-06-14T14:55:52.249Z</updated>
  <id>https://hexo.tryrun.top/</id>
  
  <author>
    <name>云少</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swing 概述</title>
    <link href="https://hexo.tryrun.top/posts/3c0e80ab.html"/>
    <id>https://hexo.tryrun.top/posts/3c0e80ab.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Swing-概述"><a href="#一、Swing-概述" class="headerlink" title="一、Swing 概述"></a>一、Swing 概述</h1><p>Swing API 是一组可扩展的 GUI 组件，用来创建基于 JAVA 的前端&#x2F; GUI 应用程序。它是建立在 AWT API 之上，并且作为 AWT API 的替代者，因为它的几乎每一个控件都对应 AWT 控件。 Swing 组件遵循模型 – 视图 – 控制器架构来满足下面的准则。</p><ul><li>一个单一的 API 足够支持多种外观和风格。</li><li>API 是模拟驱动的，这样最高层级的 API 不需要有数据。</li><li>API 是使用 Java Bean 模式的，这样 Builder Tools 和 IDE 可以为开发者提供更好的服务来使用它。</li></ul><h2 id="MVC-架构"><a href="#MVC-架构" class="headerlink" title="MVC 架构"></a>MVC 架构</h2><p>Swing API 架构用下列的方式来遵循基于松散的 MVC 架构。</p><ul><li>模型表示组件的数据。</li><li>视图表示组件数据的可视化表示形式。</li><li>控制器接受用户在视图上的输入，并且在组件的数据上反映变化。</li><li>Swing 组件把模型作为一个单独的元素，并且把视图和控制器部分组合成用户界面的元素。使用这种方式，Swing 具有可插拔的外观与风格架构。</li></ul><h2 id="Swing-特点"><a href="#Swing-特点" class="headerlink" title="Swing 特点"></a>Swing 特点</h2><ul><li><strong>轻量级 ——</strong> Swing 组件是独立的本地操作系统的 API，因为 Swing API 控件通常采用纯 JAVA 代码而不是采用底层的操作系统调用来呈现。</li><li><strong>丰富的控件 ——</strong> Swing 提供了一组丰富的先进的控件，如树，页签窗体，滑动条，颜色选择器，表格控件</li><li><strong>高级自定义 ——</strong> Swing 控件可以用非常简单的方法来自定义，因为可视化外观是独立于内部表示的。</li><li><strong>可插拔的外观和风格 ——</strong> 基于 Swing 的 GUI 应用程序的外观和风格可以在运行时根据有效的值改变。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Swing-概述&quot;&gt;&lt;a href=&quot;#一、Swing-概述&quot; class=&quot;headerlink&quot; title=&quot;一、Swing 概述&quot;&gt;&lt;/a&gt;一、Swing 概述&lt;/h1&gt;&lt;p&gt;Swing API 是一组可扩展的 GUI 组件，用来创建基于 JAVA 的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 容器</title>
    <link href="https://hexo.tryrun.top/posts/75aa4e45.html"/>
    <id>https://hexo.tryrun.top/posts/75aa4e45.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十、Swing-容器"><a href="#十、Swing-容器" class="headerlink" title="十、Swing 容器"></a>十、Swing 容器</h1><p>容器是 SWING GUI 组件的组成部分。一个容器提供了一个可以放置组件的空间。在 AWT 中，一个容器是组件本身，并且它增加了功能来添加组件本身。下面是需要考虑的注意事项。</p><ul><li>容器的子类被称为容器。例如 JPanel，JFrame 和 JWindow。</li><li>容器可以仅仅添加组件到自身。</li><li>一个默认的布局使用 setLayout 方法来呈现在每个可以被重写的容器中。</li></ul><h2 id="SWING-容器："><a href="#SWING-容器：" class="headerlink" title="SWING 容器："></a>SWING 容器：</h2><p>下面是当使用 SWING 设计 GUI 事件时常用的容器列表。</p><table><thead><tr><th align="center">序号</th><th align="center">容器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Panel</strong> JPanel 是一个最简单的容器。它提供了任何其他组件可以被放置的空间，包括其他面板。</td></tr><tr><td align="center">2</td><td align="center"><strong>Frame</strong> JFrame 是一个带有标题和边界的顶层窗口。</td></tr><tr><td align="center">3</td><td align="center"><strong>Window</strong> JWindow 对象是一个没有边界和菜单条的顶层窗口。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十、Swing-容器&quot;&gt;&lt;a href=&quot;#十、Swing-容器&quot; class=&quot;headerlink&quot; title=&quot;十、Swing 容器&quot;&gt;&lt;/a&gt;十、Swing 容器&lt;/h1&gt;&lt;p&gt;容器是 SWING GUI 组件的组成部分。一个容器提供了一个可以放置组件的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 环境安装</title>
    <link href="https://hexo.tryrun.top/posts/8ab406ce.html"/>
    <id>https://hexo.tryrun.top/posts/8ab406ce.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Swing-环境安装"><a href="#二、Swing-环境安装" class="headerlink" title="二、Swing 环境安装"></a>二、Swing 环境安装</h1><p>本节将指导你如何在你的机器上下载和设置 Java。请按照以下步骤来设置环境。</p><p>在链接 <a href="http://java.sun.com/javase/downloads/index_jdk5.jsp"><strong>Download Java</strong></a> 上, Java SE 免费提供的。所以你根据你的操作系统下载一个版本。</p><p>在你的机器上，按照说明下载 java 和运行 <strong>.exe</strong> 来安装 Java。一旦在你的机器上安装了 Java，你将需要设置环境变量来指向正确的安装目录：</p><h2 id="设置-windows-2000-x2F-XP-的路径："><a href="#设置-windows-2000-x2F-XP-的路径：" class="headerlink" title="设置 windows 2000&#x2F;XP 的路径："></a>设置 windows 2000&#x2F;XP 的路径：</h2><p>假设你已经在 <em>c:\Program Files\java\jdk</em> 目录上安装了 Java：</p><ul><li>右击 ‘我的电脑’，并且选择 ‘属性’。</li><li>点击 ‘高级’ 标签下的 ‘环境变量’ 按钮。</li><li>现在更改 ‘路径’ 变量，以便它也包含 Java 可执行文件的路径。例如，如果路径当前设置为 <code>C:\WINDOWS\SYSTEM32</code>，然后更改你的路径为 <code>C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin</code>。</li></ul><h2 id="设置-windows-95-x2F-98-x2F-ME-的路径："><a href="#设置-windows-95-x2F-98-x2F-ME-的路径：" class="headerlink" title="设置 windows 95&#x2F;98&#x2F;ME 的路径："></a>设置 windows 95&#x2F;98&#x2F;ME 的路径：</h2><p>假设你已经在 <em>c:\Program Files\java\jdk</em> 目录上安装了 Java：</p><ul><li>编辑 <code>C:\autoexec.bat</code> 文件，并且在最后添加下行： <code>SET PATH=%PATH%;C:\Program Files\java\jdk\bin</code></li></ul><h2 id="设置-Linux，UNIX，Solaris，FreeBSD-的路径："><a href="#设置-Linux，UNIX，Solaris，FreeBSD-的路径：" class="headerlink" title="设置 Linux，UNIX，Solaris，FreeBSD 的路径："></a>设置 Linux，UNIX，Solaris，FreeBSD 的路径：</h2><p>环境变量路径应该设置为指向 java 二进制文件已经安装的位置。如果你在这方面遇到困难，参考你的 shell 文档。</p><p>例如，如果你使用 <em>bash</em> 作为你的 shell，然后你将添加下行到最后 <code>.bashrc: export PATH=/path/to/java:$PATH</code></p><h2 id="流行的-Java-编辑器："><a href="#流行的-Java-编辑器：" class="headerlink" title="流行的 Java 编辑器："></a>流行的 Java 编辑器：</h2><p>为了编写 Java 程序，你将需要一个文本编辑器。在市场上有甚至更复杂的可用 IDE。但是现在，你可以考虑下列之一：</p><ul><li><strong>Notepad：</strong> 在 Windows 机器上，你可以使用任何简单的文本编辑器，如 Notepad（本教程推荐），TextPad。</li><li><strong>Netbeans：</strong>是一个开源而且免费的 Java IDE，它可以从 <a href="http://www.netbeans.org/index.html">http://www.netbeans.org/index.html</a> 下载。</li><li><strong>Eclipse：</strong> 也是一个 Java IDE，它是由 eclipse 开源社区开发的，可以从 <a href="http://www.eclipse.org/">http://www.eclipse.org/</a> 下载。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、Swing-环境安装&quot;&gt;&lt;a href=&quot;#二、Swing-环境安装&quot; class=&quot;headerlink&quot; title=&quot;二、Swing 环境安装&quot;&gt;&lt;/a&gt;二、Swing 环境安装&lt;/h1&gt;&lt;p&gt;本节将指导你如何在你的机器上下载和设置 Java。请按照以下</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 控件</title>
    <link href="https://hexo.tryrun.top/posts/de462237.html"/>
    <id>https://hexo.tryrun.top/posts/de462237.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、Swing-控件"><a href="#三、Swing-控件" class="headerlink" title="三、Swing 控件"></a>三、Swing 控件</h1><p>每个用户界面考虑有以下三个主要方面：</p><ul><li><strong>UI 元素</strong>： 有用户最终看到并且与之交互的核心视觉元素。GWT 提供了一个大量的广泛使用和常见的元素列表，本教程我们将涉及从基本到复杂的变化。</li><li><strong>布局</strong>： 他们定义应该如何在屏幕上组织 UI 元素，并且提供一个最终的外观和风格给 GUI（图形用户界面）。这部分将在布局这一章涉及。</li><li><strong>行为</strong>： 当用户与 UI 元素交互时，这些事件发生。</li></ul><p>每个 SWING 控件从下列组件类的等级继承属性。</p><table><thead><tr><th align="center">序号</th><th align="center">类 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Component</strong> Container 是 SWING 的非菜单用户界面控件的一个抽象基类。组件代表一个用图形表示的对象</td></tr><tr><td align="center">2</td><td align="center"><strong>Container</strong> Container 是一个组件，它可以包含其他 SWING 组件。</td></tr><tr><td align="center">3</td><td align="center"><strong>JComponent</strong> JComponent 是一个所有 swing UI 组件的基类。为了使用继承自 JComponent 的一个 swing 组件，组件必须是一个包容层次结构，它的根是一个顶层的 Swing 容器。</td></tr></tbody></table><h2 id="SWING-UI-元素"><a href="#SWING-UI-元素" class="headerlink" title="SWING UI 元素:"></a>SWING UI 元素:</h2><p>下列是当使用 SWING 来设计 GUI 时常用的控件列表。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>JLabel</strong> JLabel 对象是一个在容器中放置文本的组件。</td></tr><tr><td align="center">2</td><td align="center"><strong>JButton</strong> 该类创建一个有标签的的按钮。</td></tr><tr><td align="center">3</td><td align="center"><strong>JColorChooser</strong> JColorChooser 提供一个控制面板，设计允许用户操作和选择颜色。</td></tr><tr><td align="center">4</td><td align="center"><strong>JCheck Box</strong> JCheckBox 是一个图形化的组件，它的状态要么是 <strong>on</strong>（true）要么是 <strong>off</strong>（false）。</td></tr><tr><td align="center">5</td><td align="center"><strong>JRadioButton</strong> JRadioButton 类是一个图形化的组件，在一个组中，它的状态要么是 <strong>on</strong>（true）要么是<strong>off</strong>（false）。</td></tr><tr><td align="center">6</td><td align="center"><strong>JList</strong> JList 组件呈现给用户一个滚动的文本项列表。</td></tr><tr><td align="center">7</td><td align="center"><strong>JComboBox</strong> JComboBox 组件呈现给用户一个显示菜单的选择。</td></tr><tr><td align="center">8</td><td align="center"><strong>JTextField</strong> JTextField 对象是一个文本组件，它允许编辑单行文本。</td></tr><tr><td align="center">9</td><td align="center"><strong>JPasswordField</strong> JPasswordField 对象是一个专门用于密码输入的文本组件。</td></tr><tr><td align="center">10</td><td align="center"><strong>JTextArea</strong> JTextArea 对象是一个文本组件，它允许编辑多行文本。</td></tr><tr><td align="center">11</td><td align="center"><strong>ImageIcon</strong> ImageIcon 控件是一个图标界面的实现，它从图像描绘图标</td></tr><tr><td align="center">12</td><td align="center"><strong>JScrollbar</strong> Scrollbar 控件代表一个滚动条组件，为了让用户从值的范围中选择。</td></tr><tr><td align="center">13</td><td align="center"><strong>JOptionPane</strong> JOptionPane 提供了一组提示用户输入值的标准对话框，或者通知他们其他东西。</td></tr><tr><td align="center">14</td><td align="center"><strong>JFileChooser</strong> JFileChooser 控件代表一个对话框窗口，用户可以从该对话框窗口选择一个文件。</td></tr><tr><td align="center">15</td><td align="center"><strong>JProgressBar</strong> 随着任务完成的进展，进度条显示任务完成的百分比。</td></tr><tr><td align="center">16</td><td align="center"><strong>JSlider</strong> JSlider 让用户在有界区间内通过滑动旋钮图形化地选择一个值。</td></tr><tr><td align="center">17</td><td align="center"><strong>JSpinner</strong> JSpinner 是一个单行输入字段，它让用户从一个有序序列中选择一个数字或者一个对象值。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、Swing-控件&quot;&gt;&lt;a href=&quot;#三、Swing-控件&quot; class=&quot;headerlink&quot; title=&quot;三、Swing 控件&quot;&gt;&lt;/a&gt;三、Swing 控件&lt;/h1&gt;&lt;p&gt;每个用户界面考虑有以下三个主要方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件处理</title>
    <link href="https://hexo.tryrun.top/posts/731f4877.html"/>
    <id>https://hexo.tryrun.top/posts/731f4877.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、Swing-事件处理"><a href="#四、Swing-事件处理" class="headerlink" title="四、Swing 事件处理"></a>四、Swing 事件处理</h1><h2 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h2><p>改变对象的状态被称为事件，即事件描述源的状态变化。事件产生用户与图形用户界面组件交互的结果。例如，点击一个按钮，移动鼠标，通过键盘输入一个字符，从列表中选择一个项目，滚动页面都是导致一个事件发生的活动。</p><h2 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h2><p>事件可以大致分为两类:：</p><ul><li><strong>前台事件</strong> - 这些事件需要用户的直接互动。它们是由在图形用户界面中人与图形组件交互的结果而产生的。例如，点击一个按钮，移动鼠标，通过键盘输入一个字符，从列表中选择一个项目，滚动页面等。</li><li><strong>后台事件</strong> - 这些事件需要最终用户的交互，它们被称为后台事件。操作系统的中断，硬件或软件故障，计时器过期，操作完成都是后台事件的例子。</li></ul><h2 id="什么是事件处理？"><a href="#什么是事件处理？" class="headerlink" title="什么是事件处理？"></a>什么是事件处理？</h2><p>事件处理是一种机制，如果一个事件发生时，它控制该事件，并且决定应该会发生什么。这种机制具有被称为事件处理程序的代码，当一个事件发生时，它是可执行的。Java 使用代理事件模型来处理事件。该模型定义了标准的机制来生成和处理事件。让我们来简要介绍这个模型。</p><p>代理事件模型具有下列主要参与者，即：</p><ul><li><strong>源</strong> - 源是一个对象，事件发生在该对象上。源负责提供发生事件的信息给它的处理器。Java 提供源对象的类。</li><li><strong>监听器</strong> - 它也被称为作为事件处理。监听器负责产生对一个事件的响应。从 Java 实现的角度来看，监听器也是一个对象。监听器等待直到它接收到一个事件。一旦收到该事件，监听器进程的事件就返回。</li></ul><p>这种方法的好处是，用户界面逻辑完全从生成事件的逻辑中分开。用户界面元素能够把事件的处理委派给一段单独的代码。在这个模型中，监听器需要用源对象注册，以便监听器能够接收事件通知。这是一个有效的处理事件的方式，因为这些事件通知只发送给那些想要接收它们的监听器。</p><h2 id="事件处理所涉及的步骤"><a href="#事件处理所涉及的步骤" class="headerlink" title="事件处理所涉及的步骤"></a>事件处理所涉及的步骤</h2><ul><li>用户单击按钮，然后生成事件。</li><li>现在有关事件类的对象是自动创建的，源和事件的信息在同一对象得到填充。</li><li>事件对象被转发到注册监听器类的方法中。</li><li>该方法现在得到执行并且返回。</li></ul><h2 id="有关监听器要记住的要点"><a href="#有关监听器要记住的要点" class="headerlink" title="有关监听器要记住的要点"></a>有关监听器要记住的要点</h2><ul><li>为了设计一个监听器类，我们必须开发一些监听器接口。这些监听器接口预测一些公共的抽象回调方法，这些方法必须由监听器类来实现。</li><li>如果你没有实现任何预定义的接口，那么你的类不能作为源对象的监听器类。</li></ul><h2 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h2><p>这些方法由 API 提供者来提供，由应用程序员来定义，并且由应用程序开发者来调用。这里的回调方法代表一个事件方法。响应一个事件 java jre 将触发回调方法。所有这些回调方法在监听器接口中被提供。</p><p>如果一个组件需要一些监听器监听它的事件，源必须自己注册给监听器。</p><h2 id="事件处理例子"><a href="#事件处理例子" class="headerlink" title="事件处理例子"></a>事件处理例子</h2><p>使用你选择的任何编辑器创建下面的 Java 程序，在 <strong>D:&#x2F; &gt; SWING &gt; com &gt; tutorialspoint &gt; gui &gt;</strong></p><p><em>SwingControlDemo.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorialspoint.gui;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwingControlDemo</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> JFrame mainFrame;</span><br><span class="line">   <span class="keyword">private</span> JLabel headerLabel;</span><br><span class="line">   <span class="keyword">private</span> JLabel statusLabel;</span><br><span class="line">   <span class="keyword">private</span> JPanel controlPanel;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SwingControlDemo</span><span class="params">()</span>&#123;</span><br><span class="line">      prepareGUI();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">SwingControlDemo</span> <span class="variable">swingControlDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SwingControlDemo</span>();  </span><br><span class="line">      swingControlDemo.showEventDemo();       </span><br><span class="line">   &#125;      </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareGUI</span><span class="params">()</span>&#123;</span><br><span class="line">      mainFrame = <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Java SWING Examples&quot;</span>);</span><br><span class="line">      mainFrame.setSize(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">      mainFrame.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">      headerLabel = <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;&quot;</span>,JLabel.CENTER );</span><br><span class="line">      statusLabel = <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;&quot;</span>,JLabel.CENTER);        </span><br><span class="line">      statusLabel.setSize(<span class="number">350</span>,<span class="number">100</span>);</span><br><span class="line">      mainFrame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent windowEvent)</span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">         &#125;        </span><br><span class="line">      &#125;);    </span><br><span class="line">      controlPanel = <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">      controlPanel.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());</span><br><span class="line">      mainFrame.add(headerLabel);</span><br><span class="line">      mainFrame.add(controlPanel);</span><br><span class="line">      mainFrame.add(statusLabel);</span><br><span class="line">      mainFrame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showEventDemo</span><span class="params">()</span>&#123;</span><br><span class="line">      headerLabel.setText(<span class="string">&quot;Control in action: Button&quot;</span>); </span><br><span class="line">      <span class="type">JButton</span> <span class="variable">okButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">      <span class="type">JButton</span> <span class="variable">submitButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Submit&quot;</span>);</span><br><span class="line">      <span class="type">JButton</span> <span class="variable">cancelButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Cancel&quot;</span>);</span><br><span class="line">      okButton.setActionCommand(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">      submitButton.setActionCommand(<span class="string">&quot;Submit&quot;</span>);</span><br><span class="line">      cancelButton.setActionCommand(<span class="string">&quot;Cancel&quot;</span>);</span><br><span class="line">      okButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ButtonClickListener</span>()); </span><br><span class="line">      submitButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ButtonClickListener</span>()); </span><br><span class="line">      cancelButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ButtonClickListener</span>()); </span><br><span class="line">      controlPanel.add(okButton);</span><br><span class="line">      controlPanel.add(submitButton);</span><br><span class="line">      controlPanel.add(cancelButton);       </span><br><span class="line">      mainFrame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ButtonClickListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> e.getActionCommand();  </span><br><span class="line">         <span class="keyword">if</span>( command.equals( <span class="string">&quot;OK&quot;</span> ))  &#123;</span><br><span class="line">            statusLabel.setText(<span class="string">&quot;Ok Button clicked.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>( command.equals( <span class="string">&quot;Submit&quot;</span> ) )  &#123;</span><br><span class="line">            statusLabel.setText(<span class="string">&quot;Submit Button clicked.&quot;</span>); </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>  &#123;</span><br><span class="line">            statusLabel.setText(<span class="string">&quot;Cancel Button clicked.&quot;</span>);</span><br><span class="line">         &#125;      </span><br><span class="line">      &#125;     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令提示符编译该程序。转到 <strong>D:&#x2F; &gt; SWING</strong> 并输入下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\AWT&gt;javac com\tutorialspoint\gui\SwingControlDemo.java</span><br></pre></td></tr></table></figure><p>如果没有错误出现，就意味着编译成功。使用下面的命令来运行程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\AWT&gt;java com.tutorialspoint.gui.SwingControlDemo</span><br></pre></td></tr></table></figure><p>验证下面的输出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四、Swing-事件处理&quot;&gt;&lt;a href=&quot;#四、Swing-事件处理&quot; class=&quot;headerlink&quot; title=&quot;四、Swing 事件处理&quot;&gt;&lt;/a&gt;四、Swing 事件处理&lt;/h1&gt;&lt;h2 id=&quot;什么是事件？&quot;&gt;&lt;a href=&quot;#什么是事件？&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件类</title>
    <link href="https://hexo.tryrun.top/posts/ccc49d6d.html"/>
    <id>https://hexo.tryrun.top/posts/ccc49d6d.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、Swing-事件类"><a href="#五、Swing-事件类" class="headerlink" title="五、Swing 事件类"></a>五、Swing 事件类</h1><p>事件类代表事件。Java 提供各种事件类，但是我们将讨论更频繁使用的那些事件类。</p><h2 id="EventObject-类"><a href="#EventObject-类" class="headerlink" title="EventObject 类"></a>EventObject 类</h2><p>它是派生所有事件状态对象的根类。所有事件都是用对象，<strong>源</strong>的引用来构造的，即逻辑上认为是问题最初发生的事件的对象。这个类定义在 java.util 包中。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>下面是 <strong>java.util.EventObject</strong> 类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventObject</span></span><br><span class="line">   <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>下面是 <strong>java.util.EventObject</strong> 类的字段：</p><ul><li><strong>protected Object source</strong> –- 事件最初发生的对象。</li></ul><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><table><thead><tr><th align="center">S.N.</th><th align="center">构造函数 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>EventObject(Object source)</strong> 构造一个典型的事件。</td></tr></tbody></table><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th align="center">S.N.</th><th align="center">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>Object getSource()</strong> 事件最初发生的对象。</td></tr><tr><td align="center">2</td><td align="center"><strong>String toString()</strong> 返回这个 EventObject 的字符串表示。</td></tr></tbody></table><h2 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h2><p>这个类从下面的类中继承方法：</p><ul><li>java.lang.Object</li></ul><h2 id="SWING-事件类："><a href="#SWING-事件类：" class="headerlink" title="SWING 事件类："></a>SWING 事件类：</h2><p>下面是常用的事件类。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>AWTEvent</strong> 它是所有 SWING 事件的根事件类。这个类和它的子类取代了最初的 java.awt.Event 类。</td></tr><tr><td align="center">2</td><td align="center"><strong>ActionEvent</strong> 当单击按钮或双点击列表的项时，生成 ActionEvent。</td></tr><tr><td align="center">3</td><td align="center"><strong>InputEvent</strong> InputEvent 类是所有组件层输入事件的根事件类。</td></tr><tr><td align="center">4</td><td align="center"><strong>KeyEvent</strong> 在按下一个字符时，按键事件生成。</td></tr><tr><td align="center">5</td><td align="center"><strong>MouseEvent</strong> 这个事件表明一个鼠标动作发生在一个组件中。</td></tr><tr><td align="center">6</td><td align="center"><strong>WindowEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">7</td><td align="center"><strong>AdjustmentEvent</strong> 这个类的对象代表由可调整的对象发出的调整事件。</td></tr><tr><td align="center">8</td><td align="center"><strong>ComponentEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">9</td><td align="center"><strong>ContainerEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">10</td><td align="center"><strong>MouseMotionEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr><tr><td align="center">11</td><td align="center"><strong>PaintEvent</strong> 这个类的对象代表一个窗口状态的变化。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、Swing-事件类&quot;&gt;&lt;a href=&quot;#五、Swing-事件类&quot; class=&quot;headerlink&quot; title=&quot;五、Swing 事件类&quot;&gt;&lt;/a&gt;五、Swing 事件类&lt;/h1&gt;&lt;p&gt;事件类代表事件。Java 提供各种事件类，但是我们将讨论更频繁使用的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件监听器</title>
    <link href="https://hexo.tryrun.top/posts/94a53e1.html"/>
    <id>https://hexo.tryrun.top/posts/94a53e1.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、Swing-事件监听器"><a href="#六、Swing-事件监听器" class="headerlink" title="六、Swing 事件监听器"></a>六、Swing 事件监听器</h1><p>事件监听器代表负责处理事件的接口。Java 提供了各种事件监听器类，但我们将讨论更频繁使用的那些事件监听器类。一个事件监听器的每个方法有一个参数作为一个对象，该对象是 EventObject 类的子类。例如，鼠标事件监听器的方法将接受 MouseEvent 的实例，其中 MouseEvent 是 EventObject 派生的。</p><h2 id="EventListner-接口"><a href="#EventListner-接口" class="headerlink" title="EventListner 接口"></a>EventListner 接口</h2><p>它是一个标记接口，每一个监听器接口必须扩展它。这个类定义在 java.util 包中。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>下面是 <strong>java.util.EventListener</strong> 接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span></span><br></pre></td></tr></table></figure><h2 id="SWING-事件监听器接口："><a href="#SWING-事件监听器接口：" class="headerlink" title="SWING 事件监听器接口："></a>SWING 事件监听器接口：</h2><p>下面是常用的事件监听器列表。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>ActionListener</strong> 这个接口用于接收动作事件。</td></tr><tr><td align="center">2</td><td align="center"><strong>ComponentListener</strong> 这个接口用于接收组件事件。</td></tr><tr><td align="center">3</td><td align="center"><strong>ItemListener</strong> 这个接口用于接收项目事件。</td></tr><tr><td align="center">4</td><td align="center"><strong>KeyListener</strong> 这个接口用于接收按键事件。</td></tr><tr><td align="center">5</td><td align="center"><strong>MouseListener</strong> 这个接口用于接收鼠标事件。</td></tr><tr><td align="center">6</td><td align="center"><strong>WindowListener</strong> 这个接口用于接收窗口事件。</td></tr><tr><td align="center">7</td><td align="center"><strong>AdjustmentListener</strong> 这个接口用于接收调整事件。</td></tr><tr><td align="center">8</td><td align="center"><strong>ContainerListener</strong> 这个接口用于接收容器事件。</td></tr><tr><td align="center">9</td><td align="center"><strong>MouseMotionListener</strong> 这个接口用于接收鼠标移动事件。</td></tr><tr><td align="center">10</td><td align="center"><strong>FocusListener</strong> 这个接口用于接收焦点事件。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、Swing-事件监听器&quot;&gt;&lt;a href=&quot;#六、Swing-事件监听器&quot; class=&quot;headerlink&quot; title=&quot;六、Swing 事件监听器&quot;&gt;&lt;/a&gt;六、Swing 事件监听器&lt;/h1&gt;&lt;p&gt;事件监听器代表负责处理事件的接口。Java 提供了各</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 事件适配器</title>
    <link href="https://hexo.tryrun.top/posts/7123338f.html"/>
    <id>https://hexo.tryrun.top/posts/7123338f.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、Swing-事件适配器"><a href="#七、Swing-事件适配器" class="headerlink" title="七、Swing 事件适配器"></a>七、Swing 事件适配器</h1><p>适配器是用于接收各种事件的抽象类。这些类中的方法是空的。这些类的存在是为了方便创建监听器对象。</p><h2 id="SWING-适配器："><a href="#SWING-适配器：" class="headerlink" title="SWING 适配器："></a>SWING 适配器：</h2><p>下面是当在 SWING 中监听 GUI 事件时常用的适配器列表。</p><table><thead><tr><th align="center">Sr. No.</th><th align="center">适配器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>FocusAdapter</strong> 用于接收焦点事件的抽象适配器类。</td></tr><tr><td align="center">2</td><td align="center"><strong>KeyAdapter</strong> 用于接收按键事件的抽象适配器类。</td></tr><tr><td align="center">3</td><td align="center"><strong>MouseAdapter</strong> 用于接收鼠标事件的抽象适配器类。</td></tr><tr><td align="center">4</td><td align="center"><strong>MouseMotionAdapter</strong> 用于接收鼠标移动事件的抽象适配器类。</td></tr><tr><td align="center">5</td><td align="center"><strong>WindowAdapter</strong> 用于接收窗口事件的抽象适配器类。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、Swing-事件适配器&quot;&gt;&lt;a href=&quot;#七、Swing-事件适配器&quot; class=&quot;headerlink&quot; title=&quot;七、Swing 事件适配器&quot;&gt;&lt;/a&gt;七、Swing 事件适配器&lt;/h1&gt;&lt;p&gt;适配器是用于接收各种事件的抽象类。这些类中的方法是空</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 布局</title>
    <link href="https://hexo.tryrun.top/posts/6d7432f2.html"/>
    <id>https://hexo.tryrun.top/posts/6d7432f2.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八、Swing-布局"><a href="#八、Swing-布局" class="headerlink" title="八、Swing 布局"></a>八、Swing 布局</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>布局意味着容器内组件的安排。我们可以说，用其他方式在容器的特定位置放置组件。布局控件的任务是由布局管理器自动完成的。</p><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><p>布局管理器自动放置容器内的所有组件。如果我们不使用布局管理器，然后组件也能由默认的布局管理器放置。手工布局控件也是可能的，但是由于以下两个原因，它变得非常困难。</p><ul><li>在容器内处理大量的控件是非常繁琐的。</li><li>通常当我们需要安排组件时，没有给出该组件的宽度和高度信息，。</li></ul><p>Java 为我们提供了各种布局管理器来放置控件。属性如大小，形状和排列从一个布局管理器到其他的布局管理器变化。当小应用程序或应用程序窗口的大小改变时，组件的大小，形状和排列的组件也相应的变化，即布局管理器适应小应用程序视图或应用程序窗口的尺寸。</p><p>布局管理器与每一个容器对象相关联。每一个布局管理器是实现布局管理接口的类的一个对象。</p><p>下面是接口定义的布局管理器的功能。</p><table><thead><tr><th align="center">序号</th><th align="center">接口 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>LayoutManager</strong> LayoutManager 接口声明那些需要由类来实现的方法，这些类的对象将充当一个布局管理器。</td></tr><tr><td align="center">2</td><td align="center"><strong>LayoutManager2</strong> LayoutManager2 是 LayoutManager 的子接口。这个接口是为那些知道如何基于布局约束对象来布局容器的类。</td></tr></tbody></table><h2 id="AWT-布局管理器类："><a href="#AWT-布局管理器类：" class="headerlink" title="AWT 布局管理器类："></a>AWT 布局管理器类：</h2><p>下面是当使用 AWT 设计 GUI 时常用的控件列表。</p><table><thead><tr><th align="center">序号</th><th align="center">布局管理器 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>BorderLayout</strong> Borderlayout 安排组件适应于五个地区：东、西、北、南和中心。</td></tr><tr><td align="center">2</td><td align="center"><strong>CardLayout</strong> CardLayout 对象把容器中的每一个组件看成一个卡片。一次只有一个卡片是可见的。</td></tr><tr><td align="center">3</td><td align="center"><strong>FlowLayout</strong> FlowLayout 是默认的布局。它用定向流动来布局组件。</td></tr><tr><td align="center">4</td><td align="center"><strong>GridLayout</strong> GridLayout 用一个矩形网格形式来管理组件。</td></tr><tr><td align="center">5</td><td align="center"><strong>GridBagLayout</strong> 这是最灵活的布局管理器类。在不需要相同大小的组件的情况下，GridBagLayout 对象垂直、水平或沿着它们的基线来排列组件。</td></tr><tr><td align="center">6</td><td align="center"><strong>GroupLayout</strong> GroupLayout 分层次地归类组件，为了在一个容器中放置它们。</td></tr><tr><td align="center">7</td><td align="center"><strong>SpringLayout</strong> SpringLayout 根据一组约束安置与它相关的容器的孩子。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八、Swing-布局&quot;&gt;&lt;a href=&quot;#八、Swing-布局&quot; class=&quot;headerlink&quot; title=&quot;八、Swing 布局&quot;&gt;&lt;/a&gt;八、Swing 布局&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Swing 菜单类</title>
    <link href="https://hexo.tryrun.top/posts/121e0f73.html"/>
    <id>https://hexo.tryrun.top/posts/121e0f73.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="九、Swing-菜单类"><a href="#九、Swing-菜单类" class="headerlink" title="九、Swing 菜单类"></a>九、Swing 菜单类</h1><p>正如我们所知道每个顶层窗口有一个菜单栏与它相关联。这个菜单栏包括各种菜单可用的选择给最终用户。而且每个选择包含被称为下拉菜单的选项列表。菜单和菜单项的控件都是 MenuComponent 类的子类。</p><h2 id="菜单控件"><a href="#菜单控件" class="headerlink" title="菜单控件"></a>菜单控件</h2><table><thead><tr><th align="center">Sr. No.</th><th align="center">控件 &amp; 描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>JMenuBar</strong> JMenuBar 对象是与顶层窗口相关联的</td></tr><tr><td align="center">2</td><td align="center"><strong>JMenuItem</strong> 菜单中的项目必须属于 JMenuItem 或任何它的子类。</td></tr><tr><td align="center">3</td><td align="center"><strong>JMenu</strong> JMenu 对象是从菜单栏中显示的一个下拉菜单组件。</td></tr><tr><td align="center">4</td><td align="center"><strong>JCheckBoxMenuItem</strong> JCheckBoxMenuItem 是 JMenuItem 的子类。</td></tr><tr><td align="center">5</td><td align="center"><strong>JRadioButtonMenuItem</strong> JRadioButtonMenuItem 是 JMenuItem 的子类。</td></tr><tr><td align="center">6</td><td align="center"><strong>JPopupMenu</strong> JPopupMenu 可以在一个组件内的指定位置动态地弹出。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;九、Swing-菜单类&quot;&gt;&lt;a href=&quot;#九、Swing-菜单类&quot; class=&quot;headerlink&quot; title=&quot;九、Swing 菜单类&quot;&gt;&lt;/a&gt;九、Swing 菜单类&lt;/h1&gt;&lt;p&gt;正如我们所知道每个顶层窗口有一个菜单栏与它相关联。这个菜单栏包括各种</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 概述</title>
    <link href="https://hexo.tryrun.top/posts/d27442db.html"/>
    <id>https://hexo.tryrun.top/posts/d27442db.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Zookeeper-概述"><a href="#一、Zookeeper-概述" class="headerlink" title="一、Zookeeper 概述"></a>一、Zookeeper 概述</h1><p>ZooKeeper是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。ZooKeeper通过其简单的架构和API解决了这个问题。ZooKeeper允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。</p><p>ZooKeeper框架最初是在“Yahoo!”上构建的，用于以简单而稳健的方式访问他们的应用程序。 后来，Apache ZooKeeper成为Hadoop，HBase和其他分布式框架使用的有组织服务的标准。 例如，Apache HBase使用ZooKeeper跟踪分布式数据的状态。</p><p>在进一步深入之前，我们了解关于分布式应用的一两件事情是很重要的。因此，让我们开始分布式应用的概述的快速讨论。</p><h2 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h2><p>分布式应用可以在给定时间（同时）在网络中的多个系统上运行，通过协调它们以快速有效的方式完成特定任务。通常来说，对于复杂而耗时的任务，非分布式应用（运行在单个系统中）需要几个小时才能完成，而分布式应用通过使用所有系统涉及的计算能力可以在几分钟内完成。</p><p>通过将分布式应用配置为在更多系统上运行，可以进一步减少完成任务的时间。分布式应用正在运行的一组系统称为<strong>集群</strong>，而在集群中运行的每台机器被称为<strong>节点</strong>。</p><p>分布式应用有两部分， <strong>Server（服务器）</strong> 和 <strong>Client（客户端）</strong> 应用程序。服务器应用程序实际上是分布式的，并具有通用接口，以便客户端可以连接到集群中的任何服务器并获得相同的结果。 客户端应用程序是与分布式应用进行交互的工具。</p><h3 id="分布式应用的优点"><a href="#分布式应用的优点" class="headerlink" title="分布式应用的优点"></a>分布式应用的优点</h3><ul><li><strong>可靠性</strong> - 单个或几个系统的故障不会使整个系统出现故障。</li><li><strong>可扩展性</strong> - 可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。</li><li><strong>透明性</strong> - 隐藏系统的复杂性，并将其显示为单个实体&#x2F;应用程序。</li></ul><h3 id="分布式应用的挑战"><a href="#分布式应用的挑战" class="headerlink" title="分布式应用的挑战"></a>分布式应用的挑战</h3><ul><li><strong>竞争条件</strong> - 两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。</li><li><strong>死锁</strong> - 两个或多个操作等待彼此无限期完成。</li><li><strong>不一致</strong> - 数据的部分失败。</li></ul><h2 id="什么是Apache-ZooKeeper？"><a href="#什么是Apache-ZooKeeper？" class="headerlink" title="什么是Apache ZooKeeper？"></a>什么是Apache ZooKeeper？</h2><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p><p>ZooKeeper提供的常见服务如下 :</p><ul><li><strong>命名服务</strong> - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。</li><li><strong>配置管理</strong> - 加入节点的最近的和最新的系统配置信息。</li><li><strong>集群管理</strong> - 实时地在集群和节点状态中加入&#x2F;离开节点。</li><li><strong>选举算法</strong> - 选举一个节点作为协调目的的leader。</li><li><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。</li><li><strong>高度可靠的数据注册表</strong> - 即使在一个或几个节点关闭时也可以获得数据。</li></ul><p>分布式应用程序提供了很多好处，但它们也抛出了一些复杂和难以解决的挑战。ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用<strong>故障安全同步方法</strong>进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用<strong>原子性</strong>解析。</p><h2 id="ZooKeeper的好处"><a href="#ZooKeeper的好处" class="headerlink" title="ZooKeeper的好处"></a>ZooKeeper的好处</h2><p>以下是使用ZooKeeper的好处：</p><ul><li><strong>简单的分布式协调过程</strong></li><li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li><li><strong>有序的消息</strong></li><li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li><li><strong>可靠性</strong></li><li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Zookeeper-概述&quot;&gt;&lt;a href=&quot;#一、Zookeeper-概述&quot; class=&quot;headerlink&quot; title=&quot;一、Zookeeper 概述&quot;&gt;&lt;/a&gt;一、Zookeeper 概述&lt;/h1&gt;&lt;p&gt;ZooKeeper是一种分布式协调服务，用于</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 基础</title>
    <link href="https://hexo.tryrun.top/posts/348a7282.html"/>
    <id>https://hexo.tryrun.top/posts/348a7282.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Zookeeper-基础"><a href="#二、Zookeeper-基础" class="headerlink" title="二、Zookeeper 基础"></a>二、Zookeeper 基础</h1><p>在深入了解ZooKeeper的运作之前，让我们来看看ZooKeeper的基本概念。我们将在本章中讨论以下主题：<br>1、Architecture（架构）<br>2、Hierarchical namespace（层次命名空间）<br>3、Session（会话）<br>4、Watches（监视）</p><h2 id="ZooKeeper的架构"><a href="#ZooKeeper的架构" class="headerlink" title="ZooKeeper的架构"></a>ZooKeeper的架构</h2><p>作为ZooKeeper架构的一部分的每个组件在下表中进行了说明。</p><table><thead><tr><th align="center">部分</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Client（客户端）</td><td align="center">客户端，我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。</td></tr><tr><td align="center">Server（服务器）</td><td align="center">服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。</td></tr><tr><td align="center">Ensemble</td><td align="center">ZooKeeper服务器组。形成ensemble所需的最小节点数为3。</td></tr><tr><td align="center">Leader</td><td align="center">服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。</td></tr><tr><td align="center">Follower</td><td align="center">跟随leader指令的服务器节点。</td></tr></tbody></table><h2 id="层次命名空间"><a href="#层次命名空间" class="headerlink" title="层次命名空间"></a>层次命名空间</h2><p>下图描述了用于内存表示的ZooKeeper文件系统的树结构。ZooKeeper节点称为 <strong>znode</strong> 。每个znode由一个名称标识，并用路径(&#x2F;)序列分隔。</p><ul><li>在图中，首先有一个由“&#x2F;”分隔的znode。在根目录下，你有两个逻辑命名空间 <strong>config</strong> 和 <strong>workers</strong> 。</li><li><strong>config</strong> 命名空间用于集中式配置管理，<strong>workers</strong> 命名空间用于命名。</li><li>在 <strong>config</strong> 命名空间下，每个znode最多可存储1MB的数据。这与UNIX文件系统相类似，除了父znode也可以存储数据。这种结构的主要目的是存储同步数据并描述znode的元数据。此结构称为 <strong>ZooKeeper数据模型</strong>。</li></ul><p>ZooKeeper数据模型中的每个znode都维护着一个 <strong>stat</strong> 结构。一个stat仅提供一个znode的<strong>元数据</strong>。它由版本号，操作控制列表(ACL)，时间戳和数据长度组成。</p><ul><li><strong>版本号</strong> - 每个znode都有版本号，这意味着每当与znode相关联的数据发生变化时，其对应的版本号也会增加。当多个zookeeper客户端尝试在同一znode上执行操作时，版本号的使用就很重要。</li><li><strong>操作控制列表(ACL)</strong> - ACL基本上是访问znode的认证机制。它管理所有znode读取和写入操作。</li><li><strong>时间戳</strong> - 时间戳表示创建和修改znode所经过的时间。它通常以毫秒为单位。ZooKeeper从“事务ID”(zxid)标识znode的每个更改。<strong>Zxid</strong> 是唯一的，并且为每个事务保留时间，以便你可以轻松地确定从一个请求到另一个请求所经过的时间。</li><li><strong>数据长度</strong> - 存储在znode中的数据总量是数据长度。你最多可以存储1MB的数据。</li></ul><h3 id="Znode的类型"><a href="#Znode的类型" class="headerlink" title="Znode的类型"></a>Znode的类型</h3><p>Znode被分为持久（persistent）节点，顺序（sequential）节点和临时（ephemeral）节点。</p><ul><li><strong>持久节点</strong> - 即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。</li><li><strong>临时节点</strong> - 客户端活跃时，临时节点就是有效的。当客户端与ZooKeeper集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在leader选举中起着重要作用。</li><li><strong>顺序节点</strong> - 顺序节点可以是持久的或临时的。当一个新的znode被创建为一个顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。例如，如果将具有路径 <strong>&#x2F;myapp</strong> 的znode创建为顺序节点，则ZooKeeper会将路径更改为 <strong>&#x2F;myapp0000000001</strong> ，并将下一个序列号设置为0000000002。如果两个顺序节点是同时创建的，那么ZooKeeper不会对每个znode使用相同的数字。顺序节点在锁定和同步中起重要作用。</li></ul><h2 id="Sessions（会话）"><a href="#Sessions（会话）" class="headerlink" title="Sessions（会话）"></a>Sessions（会话）</h2><p>会话对于ZooKeeper的操作非常重要。会话中的请求按FIFO顺序执行。一旦客户端连接到服务器，将建立会话并向客户端分配<strong>会话ID</strong> 。</p><p>客户端以特定的时间间隔发送<strong>心跳</strong>以保持会话有效。如果ZooKeeper集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。</p><p>会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。</p><h2 id="Watches（监视）"><a href="#Watches（监视）" class="headerlink" title="Watches（监视）"></a>Watches（监视）</h2><p>监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。</p><p>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、Zookeeper-基础&quot;&gt;&lt;a href=&quot;#二、Zookeeper-基础&quot; class=&quot;headerlink&quot; title=&quot;二、Zookeeper 基础&quot;&gt;&lt;/a&gt;二、Zookeeper 基础&lt;/h1&gt;&lt;p&gt;在深入了解ZooKeeper的运作之前，让我</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 工作流</title>
    <link href="https://hexo.tryrun.top/posts/21b85715.html"/>
    <id>https://hexo.tryrun.top/posts/21b85715.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、Zookeeper-工作流"><a href="#三、Zookeeper-工作流" class="headerlink" title="三、Zookeeper 工作流"></a>三、Zookeeper 工作流</h1><p>一旦ZooKeeper集合启动，它将等待客户端连接。客户端将连接到ZooKeeper集合中的一个节点。它可以是leader或follower节点。一旦客户端被连接，节点将向特定客户端分配会话ID并向该客户端发送确认。如果客户端没有收到确认，它将尝试连接ZooKeeper集合中的另一个节点。 一旦连接到节点，客户端将以有规律的间隔向节点发送心跳，以确保连接不会丢失。</p><ul><li><strong>如果客户端想要读取特定的znode，</strong>它将会向具有znode路径的节点发送<strong>读取请求</strong>，并且节点通过从其自己的数据库获取来返回所请求的znode。为此，在ZooKeeper集合中读取速度很快。</li><li><strong>如果客户端想要将数据存储在ZooKeeper集合中</strong>，则会将znode路径和数据发送到服务器。连接的服务器将该请求转发给leader，然后leader将向所有的follower重新发出写入请求。如果只有大部分节点成功响应，而写入请求成功，则成功返回代码将被发送到客户端。 否则，写入请求失败。绝大多数节点被称为 <strong>Quorum</strong> 。</li></ul><h2 id="ZooKeeper集合中的节点"><a href="#ZooKeeper集合中的节点" class="headerlink" title="ZooKeeper集合中的节点"></a>ZooKeeper集合中的节点</h2><p>让我们分析在ZooKeeper集合中拥有不同数量的节点的效果。</p><ul><li>如果我们有<strong>单个节点</strong>，则当该节点故障时，ZooKeeper集合将故障。它有助于“单点故障”，不建议在生产环境中使用。</li><li>如果我们有<strong>两个节点</strong>而一个节点故障，我们没有占多数，因为两个中的一个不是多数。</li><li>如果我们有<strong>三个节点</strong>而一个节点故障，那么我们有大多数，因此，这是最低要求。ZooKeeper集合在实际生产环境中必须至少有三个节点。</li><li>如果我们有<strong>四个节点</strong>而两个节点故障，它将再次故障。类似于有三个节点，额外节点不用于任何目的，因此，最好添加奇数的节点，例如3，5，7。</li></ul><p>我们知道写入过程比ZooKeeper集合中的读取过程要贵，因为所有节点都需要在数据库中写入相同的数据。因此，对于平衡的环境拥有较少数量（例如3，5，7）的节点比拥有大量的节点要好。</p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">写入（write）</td><td align="center">写入过程由leader节点处理。leader将写入请求转发到所有znode，并等待znode的回复。如果一半的znode回复，则写入过程完成。</td></tr><tr><td align="center">读取（read）</td><td align="center">读取由特定连接的znode在内部执行，因此不需要与集群进行交互。</td></tr><tr><td align="center">复制数据库（replicated database）</td><td align="center">它用于在zookeeper中存储数据。每个znode都有自己的数据库，每个znode在一致性的帮助下每次都有相同的数据。</td></tr><tr><td align="center">Leader</td><td align="center">Leader是负责处理写入请求的Znode。</td></tr><tr><td align="center">Follower</td><td align="center">follower从客户端接收写入请求，并将它们转发到leader znode。</td></tr><tr><td align="center">请求处理器（request processor）</td><td align="center">只存在于leader节点。它管理来自follower节点的写入请求。</td></tr><tr><td align="center">原子广播（atomic broadcasts）</td><td align="center">负责广播从leader节点到follower节点的变化。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、Zookeeper-工作流&quot;&gt;&lt;a href=&quot;#三、Zookeeper-工作流&quot; class=&quot;headerlink&quot; title=&quot;三、Zookeeper 工作流&quot;&gt;&lt;/a&gt;三、Zookeeper 工作流&lt;/h1&gt;&lt;p&gt;一旦ZooKeeper集合启动，它将</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>四、Zookeeper leader选举</title>
    <link href="https://hexo.tryrun.top/posts/13f8b425.html"/>
    <id>https://hexo.tryrun.top/posts/13f8b425.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、Zookeeper-leader选举"><a href="#四、Zookeeper-leader选举" class="headerlink" title="四、Zookeeper leader选举"></a>四、Zookeeper leader选举</h1><p>让我们分析如何在ZooKeeper集合中选举leader节点。考虑一个集群中有N个节点。leader选举的过程如下：</p><p>所有节点创建具有相同路径 &#x2F;app&#x2F;leader_election&#x2F;guid_ 的顺序、临时节点。</p><p>ZooKeeper集合将附加10位序列号到路径，创建的znode将是 &#x2F;app&#x2F;leader_election&#x2F;guid_0000000001，&#x2F;app&#x2F;leader_election&#x2F;guid_0000000002等。</p><p>对于给定的实例，在znode中创建最小数字的节点成为leader，而所有其他节点是follower。</p><p>每个follower节点监视下一个具有最小数字的znode。例如，创建znode&#x2F;app&#x2F;leader_election&#x2F;guid_0000000008的节点将监视znode&#x2F;app&#x2F;leader_election&#x2F;guid_0000000007，创建znode&#x2F;app&#x2F;leader_election&#x2F;guid_0000000007的节点将监视znode&#x2F;app&#x2F;leader_election&#x2F;guid_0000000006。</p><p>如果leader关闭，则其相应的znode&#x2F;app&#x2F;leader_electionN会被删除。</p><p>下一个在线follower节点将通过监视器获得关于leader移除的通知。</p><p>下一个在线follower节点将检查是否存在其他具有最小数字的znode。如果没有，那么它将承担leader的角色。否则，它找到的创建具有最小数字的znode的节点将作为leader。</p><p>类似地，所有其他follower节点选举创建具有最小数字的znode的节点作为leader。</p><p>leader选举是一个复杂的过程，但ZooKeeper服务使它非常简单。让我们在下一章中继续学习ZooKeeper安装，以用于开发目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四、Zookeeper-leader选举&quot;&gt;&lt;a href=&quot;#四、Zookeeper-leader选举&quot; class=&quot;headerlink&quot; title=&quot;四、Zookeeper leader选举&quot;&gt;&lt;/a&gt;四、Zookeeper leader选举&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 安装</title>
    <link href="https://hexo.tryrun.top/posts/35565cb.html"/>
    <id>https://hexo.tryrun.top/posts/35565cb.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、Zookeeper-安装"><a href="#五、Zookeeper-安装" class="headerlink" title="五、Zookeeper 安装"></a>五、Zookeeper 安装</h1><p>在安装ZooKeeper之前，请确保你的系统是在以下任一操作系统上运行：</p><ul><li><strong>任意Linux OS</strong> - 支持开发和部署。适合演示应用程序。</li><li><strong>Windows OS</strong> - 仅支持开发。</li><li><strong>Mac OS</strong> - 仅支持开发。</li></ul><p>ZooKeeper服务器是用Java创建的，它在JVM上运行。你需要使用JDK 6或更高版本。</p><p>现在，按照以下步骤在你的机器上安装ZooKeeper框架。</p><h2 id="步骤1：验证Java安装"><a href="#步骤1：验证Java安装" class="headerlink" title="步骤1：验证Java安装"></a>步骤1：验证Java安装</h2><p>相信你已经在系统上安装了Java环境。现在只需使用以下命令验证它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure><p>如果你在机器上安装了Java，那么可以看到已安装的Java的版本。否则，请按照以下简单步骤安装最新版本的Java。</p><h3 id="步骤1-1：下载JDK"><a href="#步骤1-1：下载JDK" class="headerlink" title="步骤1.1：下载JDK"></a>步骤1.1：下载JDK</h3><p>通过访问链接下载最新版本的JDK，并下载最新版本的<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java</a>。</p><p>最新版本（在编写本教程时）是JDK 8u 60，文件是“jdk-8u60-linuxx64.tar.gz”。请在你的机器上下载该文件。</p><h3 id="步骤1-2：提取文件"><a href="#步骤1-2：提取文件" class="headerlink" title="步骤1.2：提取文件"></a>步骤1.2：提取文件</h3><p>通常，文件会下载到<strong>download</strong>文件夹中。验证并使用以下命令提取tar设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /go/to/download/path</span><br><span class="line">$ tar -zxf jdk-8u60-linux-x64.gz</span><br></pre></td></tr></table></figure><h3 id="步骤1-3：移动到opt目录"><a href="#步骤1-3：移动到opt目录" class="headerlink" title="步骤1.3：移动到opt目录"></a>步骤1.3：移动到opt目录</h3><p>要使Java对所有用户可用，请将提取的Java内容移动到“&#x2F;usr&#x2F;local&#x2F;java”文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ su </span><br><span class="line">password: (type password of root user)</span><br><span class="line">$ mkdir /opt/jdk</span><br><span class="line">$ mv jdk-1.8.0_60 /opt/jdk/</span><br></pre></td></tr></table></figure><h3 id="步骤1-4：设置路径"><a href="#步骤1-4：设置路径" class="headerlink" title="步骤1.4：设置路径"></a>步骤1.4：设置路径</h3><p>要设置路径和JAVA_HOME变量，请将以下命令添加到〜&#x2F;.bashrc文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME = /usr/jdk/jdk-1.8.0_60</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>现在，将所有更改应用到当前运行的系统中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="步骤1-5：Java替代"><a href="#步骤1-5：Java替代" class="headerlink" title="步骤1.5：Java替代"></a>步骤1.5：Java替代</h3><p>使用以下命令更改Java替代项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/java java /opt/jdk/jdk1.8.0_60/bin/java 100</span><br></pre></td></tr></table></figure><h3 id="步骤1-6"><a href="#步骤1-6" class="headerlink" title="步骤1.6"></a>步骤1.6</h3><p>使用步骤1中说明的验证命令**(java -version)**验证Java安装。</p><h2 id="步骤2：ZooKeeper框架安装"><a href="#步骤2：ZooKeeper框架安装" class="headerlink" title="步骤2：ZooKeeper框架安装"></a>步骤2：ZooKeeper框架安装</h2><h3 id="步骤2-1：下载ZooKeeper"><a href="#步骤2-1：下载ZooKeeper" class="headerlink" title="步骤2.1：下载ZooKeeper"></a>步骤2.1：下载ZooKeeper</h3><p>要在你的计算机上安装ZooKeeper框架，请访问以下链接并下载最新版本的ZooKeeper。<a href="http://zookeeper.apache.org/releases.html">http://zookeeper.apache.org/releases.html</a></p><p>到目前为止，最新版本的ZooKeeper是3.4.6(ZooKeeper-3.4.6.tar.gz)。</p><h3 id="步骤2-2：提取tar文件"><a href="#步骤2-2：提取tar文件" class="headerlink" title="步骤2.2：提取tar文件"></a>步骤2.2：提取tar文件</h3><p>使用以下命令提取tar文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd opt/</span><br><span class="line">$ tar -zxf zookeeper-3.4.6.tar.gz</span><br><span class="line">$ cd zookeeper-3.4.6</span><br><span class="line">$ mkdir data</span><br></pre></td></tr></table></figure><h3 id="步骤2-3：创建配置文件"><a href="#步骤2-3：创建配置文件" class="headerlink" title="步骤2.3：创建配置文件"></a>步骤2.3：创建配置文件</h3><p>使用命令 <strong>vi conf&#x2F;zoo.cfg</strong> 和所有以下参数设置为起点，打开名为 <strong>conf&#x2F;zoo.cfg</strong> 的配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">tickTime = 2000</span><br><span class="line">dataDir = /path/to/zookeeper/data</span><br><span class="line">clientPort = 2181</span><br><span class="line">initLimit = 5</span><br><span class="line">syncLimit = 2</span><br></pre></td></tr></table></figure><p>一旦成功保存配置文件，再次返回终端。你现在可以启动zookeeper服务器。</p><h3 id="步骤2-4：启动ZooKeeper服务器"><a href="#步骤2-4：启动ZooKeeper服务器" class="headerlink" title="步骤2.4：启动ZooKeeper服务器"></a>步骤2.4：启动ZooKeeper服务器</h3><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p>执行此命令后，你将收到以下响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ JMX enabled by default</span><br><span class="line">$ Using config: /Users/../zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">$ Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><h3 id="步骤2-5：启动CLI"><a href="#步骤2-5：启动CLI" class="headerlink" title="步骤2.5：启动CLI"></a>步骤2.5：启动CLI</h3><p>键入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/zkCli.sh</span><br></pre></td></tr></table></figure><p>键入上述命令后，将连接到ZooKeeper服务器，你应该得到以下响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connecting to localhost:2181</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type: None path:null</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure><h3 id="停止ZooKeeper服务器"><a href="#停止ZooKeeper服务器" class="headerlink" title="停止ZooKeeper服务器"></a>停止ZooKeeper服务器</h3><p>连接服务器并执行所有操作后，可以使用以下命令停止zookeeper服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、Zookeeper-安装&quot;&gt;&lt;a href=&quot;#五、Zookeeper-安装&quot; class=&quot;headerlink&quot; title=&quot;五、Zookeeper 安装&quot;&gt;&lt;/a&gt;五、Zookeeper 安装&lt;/h1&gt;&lt;p&gt;在安装ZooKeeper之前，请确保你的系统</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper CLI</title>
    <link href="https://hexo.tryrun.top/posts/b4d28b16.html"/>
    <id>https://hexo.tryrun.top/posts/b4d28b16.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、Zookeeper-CLI"><a href="#六、Zookeeper-CLI" class="headerlink" title="六、Zookeeper CLI"></a>六、Zookeeper CLI</h1><p>ZooKeeper命令行界面（CLI）用于与ZooKeeper集合进行交互以进行开发。它有助于调试和解决不同的选项。</p><p>要执行ZooKeeper CLI操作，首先打开ZooKeeper服务器（“bin&#x2F;zkServer.sh start”），然后打开ZooKeeper客户端（“bin&#x2F;zkCli.sh”）。一旦客户端启动，你可以执行以下操作：<br>1、创建znode<br>2、获取数据<br>3、监视znode的变化<br>4、设置数据<br>5、创建znode的子节点<br>6、列出znode的子节点<br>7、检查状态<br>8、移除&#x2F;删除znode<br>现在让我们用一个例子逐个了解上面的命令。</p><h2 id="创建Znodes"><a href="#创建Znodes" class="headerlink" title="创建Znodes"></a>创建Znodes</h2><p>用给定的路径创建一个znode。flag参数指定创建的znode是临时的，持久的还是顺序的。默认情况下，所有znode都是持久的。<br>当会话过期或客户端断开连接时， <strong>临时节点</strong> （flag：-e）将被自动删除。<br><strong>顺序节点</strong>保证znode路径将是唯一的。<br>ZooKeeper集合将向znode路径填充10位序列号。例如，znode路径 &#x2F;myapp 将转换为&#x2F;myapp0000000001，下一个序列号将为&#x2F;myapp0000000002。如果没有指定flag，则znode被认为是持久的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /path /data</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /FirstZnode “Myfirstzookeeper-app&quot;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create /FirstZnode “Myfirstzookeeper-app&quot;</span><br><span class="line">Created /FirstZnode</span><br></pre></td></tr></table></figure><p>要创建<strong>顺序节点</strong>，请添加flag：**-s**，如下所示。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /path /data</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /FirstZnode second-data</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -s /FirstZnode “second-data&quot;</span><br><span class="line">Created /FirstZnode0000000023</span><br></pre></td></tr></table></figure><p>要创建<strong>临时节点</strong>，请添加flag：**-e**，如下所示。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /path /data</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /SecondZnode “Ephemeral-data&quot;</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /SecondZnode “Ephemeral-data&quot;</span><br><span class="line">Created /SecondZnode</span><br></pre></td></tr></table></figure><p>记住当客户端断开连接时，临时节点将被删除。你可以通过退出ZooKeeper CLI，然后重新打开CLI来尝试。</p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>它返回znode的关联数据和指定znode的元数据。你将获得信息，例如上次修改数据的时间，修改的位置以及数据的相关信息。此CLI还用于分配监视器以显示数据相关的通知。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /path </span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /FirstZnode</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode</span><br><span class="line">“Myfirstzookeeper-app&quot;</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x7f</span><br><span class="line">mtime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 22</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><p>要访问顺序节点，必须输入znode的完整路径。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /FirstZnode0000000023</span><br></pre></td></tr></table></figure><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode0000000023</span><br><span class="line">“Second-data&quot;</span><br><span class="line">cZxid = 0x80</span><br><span class="line">ctime = Tue Sep 29 16:25:47 IST 2015</span><br><span class="line">mZxid = 0x80</span><br><span class="line">mtime = Tue Sep 29 16:25:47 IST 2015</span><br><span class="line">pZxid = 0x80</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 13</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h2 id="Watch（监视）"><a href="#Watch（监视）" class="headerlink" title="Watch（监视）"></a>Watch（监视）</h2><p>当指定的znode或znode的子数据更改时，监视器会显示通知。你只能在 <strong>get</strong> 命令中设置<strong>watch</strong>。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /path [watch] 1</span><br></pre></td></tr></table></figure><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /FirstZnode 1</span><br></pre></td></tr></table></figure><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode 1</span><br><span class="line">“Myfirstzookeeper-app&quot;</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x7f</span><br><span class="line">mtime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 22</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><p>输出类似于普通的 <strong>get</strong> 命令，但它会等待后台等待znode更改。&lt;从这里开始&gt;</p><h2 id="设置数据"><a href="#设置数据" class="headerlink" title="设置数据"></a>设置数据</h2><p>设置指定znode的数据。完成此设置操作后，你可以使用 <strong>get</strong> CLI命令检查数据。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /path /data</span><br></pre></td></tr></table></figure><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /SecondZnode Data-updated</span><br></pre></td></tr></table></figure><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /SecondZnode “Data-updated&quot;</span><br><span class="line">cZxid = 0x82</span><br><span class="line">ctime = Tue Sep 29 16:29:50 IST 2015</span><br><span class="line">mZxid = 0x83</span><br><span class="line">mtime = Tue Sep 29 16:29:50 IST 2015</span><br><span class="line">pZxid = 0x82</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x15018b47db00000</span><br><span class="line">dataLength = 14</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><p>如果你在 <strong>get</strong> 命令中分配了<strong>watch</strong>选项（如上一个命令），则输出将类似如下所示。</p><h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] get /FirstZnode “Mysecondzookeeper-app&quot;</span><br><span class="line"></span><br><span class="line">WATCHER: :</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/FirstZnode</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x84</span><br><span class="line">mtime = Tue Sep 29 17:14:47 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 23</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h2 id="创建子项-x2F-子节点"><a href="#创建子项-x2F-子节点" class="headerlink" title="创建子项&#x2F;子节点"></a>创建子项&#x2F;子节点</h2><p>创建子节点类似于创建新的znode。唯一的区别是，子znode的路径也将具有父路径。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /parent/path/subnode/path /data</span><br></pre></td></tr></table></figure><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /FirstZnode/Child1 firstchildren</span><br></pre></td></tr></table></figure><h3 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 16] create /FirstZnode/Child1 “firstchildren&quot;</span><br><span class="line">created /FirstZnode/Child1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] create /FirstZnode/Child2 “secondchildren&quot;</span><br><span class="line">created /FirstZnode/Child2</span><br></pre></td></tr></table></figure><h2 id="列出子项"><a href="#列出子项" class="headerlink" title="列出子项"></a>列出子项</h2><p>此命令用于列出和显示znode的子项。</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /path</span><br></pre></td></tr></table></figure><h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /MyFirstZnode</span><br></pre></td></tr></table></figure><h3 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /MyFirstZnode</span><br><span class="line">[mysecondsubnode, myfirstsubnode]</span><br></pre></td></tr></table></figure><h2 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h2><p>状态描述指定的znode的元数据。它包含时间戳，版本号，ACL，数据长度和子znode等细项。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat /path</span><br></pre></td></tr></table></figure><h3 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat /FirstZnode</span><br></pre></td></tr></table></figure><h3 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] stat /FirstZnode</span><br><span class="line">cZxid = 0x7f</span><br><span class="line">ctime = Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid = 0x7f</span><br><span class="line">mtime = Tue Sep 29 17:14:24 IST 2015</span><br><span class="line">pZxid = 0x7f</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 23</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h2 id="移除Znode"><a href="#移除Znode" class="headerlink" title="移除Znode"></a>移除Znode</h2><p>移除指定的znode并递归其所有子节点。只有在这样的znode可用的情况下才会发生。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr /path</span><br></pre></td></tr></table></figure><h3 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr /FirstZnode</span><br></pre></td></tr></table></figure><h3 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] rmr /FirstZnode</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] get /FirstZnode</span><br><span class="line">Node does not exist: /FirstZnode</span><br></pre></td></tr></table></figure><p>删除**(delete&#x2F;path)**命令类似于 <strong>remove</strong> 命令，除了它只适用于没有子节点的znode。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、Zookeeper-CLI&quot;&gt;&lt;a href=&quot;#六、Zookeeper-CLI&quot; class=&quot;headerlink&quot; title=&quot;六、Zookeeper CLI&quot;&gt;&lt;/a&gt;六、Zookeeper CLI&lt;/h1&gt;&lt;p&gt;ZooKeeper命令行界面（CLI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper API</title>
    <link href="https://hexo.tryrun.top/posts/51210225.html"/>
    <id>https://hexo.tryrun.top/posts/51210225.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、Zookeeper-API"><a href="#七、Zookeeper-API" class="headerlink" title="七、Zookeeper API"></a>七、Zookeeper API</h1><p>ZooKeeper有一个绑定Java和C的官方API。Zookeeper社区为大多数语言（.NET，python等）提供非官方API。使用ZooKeeper API，应用程序可以连接，交互，操作数据，协调，最后断开与ZooKeeper集合的连接。</p><p>ZooKeeper API具有丰富的功能，以简单和安全的方式获得ZooKeeper集合的所有功能。ZooKeeper API提供同步和异步方法。</p><p>ZooKeeper集合和ZooKeeper API在各个方面都完全相辅相成，对开发人员有很大的帮助。让我们在本章讨论Java绑定。</p><h2 id="ZooKeeper-API的基础知识"><a href="#ZooKeeper-API的基础知识" class="headerlink" title="ZooKeeper API的基础知识"></a>ZooKeeper API的基础知识</h2><p>与ZooKeeper集合进行交互的应用程序称为 <strong>ZooKeeper客户端</strong>或简称<strong>客户端</strong>。</p><p>Znode是ZooKeeper集合的核心组件，ZooKeeper API提供了一小组方法使用ZooKeeper集合来操纵znode的所有细节。</p><p>客户端应该遵循以步骤，与ZooKeeper集合进行清晰和干净的交互。</p><ul><li>连接到ZooKeeper集合。ZooKeeper集合为客户端分配会话ID。</li><li>定期向服务器发送心跳。否则，ZooKeeper集合将过期会话ID，客户端需要重新连接。</li><li>只要会话ID处于活动状态，就可以获取&#x2F;设置znode。</li><li>所有任务完成后，断开与ZooKeeper集合的连接。如果客户端长时间不活动，则ZooKeeper集合将自动断开客户端。</li></ul><h2 id="Java绑定"><a href="#Java绑定" class="headerlink" title="Java绑定"></a>Java绑定</h2><p>让我们来了解本章中最重要的一组ZooKeeper API。ZooKeeper API的核心部分是<strong>ZooKeeper类</strong>。它提供了在其构造函数中连接ZooKeeper集合的选项，并具有以下方法：</p><ul><li><strong>connect</strong> - 连接到ZooKeeper集合</li><li><strong>create</strong>- 创建znode</li><li><strong>exists</strong>- 检查znode是否存在及其信息</li><li><strong>getData</strong> - 从特定的znode获取数据</li><li><strong>setData</strong> - 在特定的znode中设置数据</li><li><strong>getChildren</strong> - 获取特定znode中的所有子节点</li><li><strong>delete</strong> - 删除特定的znode及其所有子项</li><li><strong>close</strong> - 关闭连接</li></ul><h2 id="连接到ZooKeeper集合"><a href="#连接到ZooKeeper集合" class="headerlink" title="连接到ZooKeeper集合"></a>连接到ZooKeeper集合</h2><p>ZooKeeper类通过其构造函数提供connect功能。构造函数的签名如下 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper(String connectionString, <span class="type">int</span> sessionTimeout, Watcher watcher)</span><br></pre></td></tr></table></figure><ul><li><strong>connectionString</strong> - ZooKeeper集合主机。</li><li><strong>sessionTimeout</strong> - 会话超时（以毫秒为单位）。</li><li><strong>watcher</strong> - 实现“监视器”界面的对象。ZooKeeper集合通过监视器对象返回连接状态。</li></ul><p>让我们创建一个新的帮助类 <strong>ZooKeeperConnection</strong> ，并添加一个方法 <strong>connect</strong> 。 <strong>connect</strong> 方法创建一个ZooKeeper对象，连接到ZooKeeper集合，然后返回对象。</p><p>这里 <strong>CountDownLatch</strong> 用于停止（等待）主进程，直到客户端与ZooKeeper集合连接。</p><p>ZooKeeper集合通过监视器回调来回复连接状态。一旦客户端与ZooKeeper集合连接，监视器回调就会被调用，并且监视器回调函数调用<strong>CountDownLatch</strong>的<strong>countDown</strong>方法来释放锁，在主进程中<strong>await</strong>。</p><p>以下是与ZooKeeper集合连接的完整代码。</p><h3 id="编码：ZooKeeperConnection-java"><a href="#编码：ZooKeeperConnection-java" class="headerlink" title="编码：ZooKeeperConnection.java"></a>编码：ZooKeeperConnection.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import java classes</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import zookeeper classes</span></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.AsyncCallback.StatCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException.Code;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZooKeeperConnection</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// declare zookeeper instance to access ZooKeeper ensemble</span></span><br><span class="line">   <span class="keyword">private</span> ZooKeeper zoo;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">connectedSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to connect zookeeper ensemble.</span></span><br><span class="line">   <span class="keyword">public</span> ZooKeeper <span class="title function_">connect</span><span class="params">(String host)</span> <span class="keyword">throws</span> IOException,InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">      zoo = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(host,<span class="number">5000</span>,<span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent we)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (we.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">               connectedSignal.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      connectedSignal.await();</span><br><span class="line">      <span class="keyword">return</span> zoo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to disconnect from zookeeper server</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      zoo.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存上面的代码，它将在下一节中用于连接ZooKeeper集合。</p><h2 id="创建Znode"><a href="#创建Znode" class="headerlink" title="创建Znode"></a>创建Znode</h2><p>ZooKeeper类提供了在ZooKeeper集合中创建一个新的znode的<strong>create</strong>方法。 <strong>create</strong> 方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create(String path, <span class="type">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span><br></pre></td></tr></table></figure><ul><li><strong>path</strong> - Znode路径。例如，&#x2F;myapp1，&#x2F;myapp2，&#x2F;myapp1&#x2F;mydata1，myapp2&#x2F;mydata1&#x2F;myanothersubdata</li><li><strong>data</strong> - 要存储在指定znode路径中的数据</li><li><strong>acl</strong> - 要创建的节点的访问控制列表。ZooKeeper API提供了一个静态接口 <strong>ZooDefs.Ids</strong> 来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE返回打开znode的acl列表。</li><li><strong>createMode</strong> - 节点的类型，即临时，顺序或两者。这是一个<strong>枚举</strong>。</li></ul><p>让我们创建一个新的Java应用程序来检查ZooKeeper API的 <strong>create</strong> 功能。创建文件 <strong>ZKCreate.java</strong> 。在main方法中，创建一个类型为 <strong>ZooKeeperConnection</strong> 的对象，并调用 <strong>connect</strong> 方法连接到ZooKeeper集合。</p><p>connect方法将返回ZooKeeper对象 <strong>zk</strong> 。现在，请使用自定义<strong>path</strong>和<strong>data</strong>调用 <strong>zk</strong> 对象的 <strong>create</strong> 方法。</p><p>创建znode的完整程序代码如下：</p><h3 id="编码：ZKCreate-java"><a href="#编码：ZKCreate-java" class="headerlink" title="编码：ZKCreate.java"></a>编码：ZKCreate.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKCreate</span> &#123;</span><br><span class="line">   <span class="comment">// create static instance for zookeeper class.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// create static instance for ZooKeeperConnection class.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to create znode in zookeeper ensemble</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String path, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> </span><br><span class="line">      KeeperException,InterruptedException &#123;</span><br><span class="line">      zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">      CreateMode.PERSISTENT);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// znode path</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/MyFirstZnode&quot;</span>; <span class="comment">// Assign path to znode</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// data in byte array</span></span><br><span class="line">      <span class="type">byte</span>[] data = <span class="string">&quot;My first zookeeper app&quot;</span>.getBytes(); <span class="comment">// Declare data</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> <span class="title class_">ZooKeeperConnection</span>();</span><br><span class="line">         zk = conn.connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">         create(path, data); <span class="comment">// Create the data to the specified path</span></span><br><span class="line">         conn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage()); <span class="comment">//Catch error message</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦编译和执行应用程序，将在ZooKeeper集合中创建具有指定数据的znode。你可以使用ZooKeeper CLI <strong>zkCli.sh</strong> 进行检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; get /MyFirstZnode</span><br></pre></td></tr></table></figure><h2 id="Exists-–-检查Znode的存在"><a href="#Exists-–-检查Znode的存在" class="headerlink" title="Exists – 检查Znode的存在"></a>Exists – 检查Znode的存在</h2><p>ZooKeeper类提供了 <strong>exists</strong> 方法来检查znode的存在。如果指定的znode存在，则返回一个znode的元数据。<strong>exists</strong>方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists(String path, <span class="type">boolean</span> watcher)</span><br></pre></td></tr></table></figure><ul><li><strong>path</strong>- Znode路径</li><li><strong>watcher</strong> - 布尔值，用于指定是否监视指定的znode</li></ul><p>让我们创建一个新的Java应用程序来检查ZooKeeper API的“exists”功能。创建文件“ZKExists.java”。在main方法中，使用“ZooKeeperConnection”对象创建ZooKeeper对象“zk”。然后，使用自定义“path”调用“zk”对象的“exists”方法。完整的列表如下：</p><h3 id="编码：ZKExists-java"><a href="#编码：ZKExists-java" class="headerlink" title="编码：ZKExists.java"></a>编码：ZKExists.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKExists</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to check existence of znode and its status, if znode is available.</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stat <span class="title function_">znode_exists</span><span class="params">(String path)</span> <span class="keyword">throws</span></span><br><span class="line">      KeeperException,InterruptedException &#123;</span><br><span class="line">      <span class="keyword">return</span> zk.exists(path, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/MyFirstZnode&quot;</span>; <span class="comment">// Assign znode to the specified path</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> <span class="title class_">ZooKeeperConnection</span>();</span><br><span class="line">         zk = conn.connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">         <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> znode_exists(path); <span class="comment">// Stat checks the path of the znode</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Node exists and the node version is &quot;</span> +</span><br><span class="line">            stat.getVersion());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Node does not exists&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage()); <span class="comment">// Catches error messages</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦编译和执行应用程序，你将获得以下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node exists and the node version is 1.</span><br></pre></td></tr></table></figure><h2 id="getData方法"><a href="#getData方法" class="headerlink" title="getData方法"></a>getData方法</h2><p>ZooKeeper类提供 <strong>getData</strong> 方法来获取附加在指定znode中的数据及其状态。 <strong>getData</strong> 方法的签名如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getData(String path, Watcher watcher, Stat <span class="built_in">stat</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>path</strong> - Znode路径。</li><li><strong>watcher</strong> - 监视器类型的回调函数。当指定的znode的数据改变时，ZooKeeper集合将通过监视器回调进行通知。这是一次性通知。</li><li><strong>stat</strong> - 返回znode的元数据。</li></ul><p>让我们创建一个新的Java应用程序来了解ZooKeeper API的 <strong>getData</strong> 功能。创建文件 <strong>ZKGetData.java</strong> 。在main方法中，使用 <strong>ZooKeeperConnection</strong> 对象创建一个ZooKeeper对象 <strong>zk</strong> 。然后，使用自定义路径调用zk对象的 <strong>getData</strong> 方法。</p><p>下面是从指定节点获取数据的完整程序代码：</p><h3 id="编码：ZKGetData-java"><a href="#编码：ZKGetData-java" class="headerlink" title="编码：ZKGetData.java"></a>编码：ZKGetData.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKGetData</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stat <span class="title function_">znode_exists</span><span class="params">(String path)</span> <span class="keyword">throws</span> </span><br><span class="line">      KeeperException,InterruptedException &#123;</span><br><span class="line">      <span class="keyword">return</span> zk.exists(path,<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, KeeperException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/MyFirstZnode&quot;</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">connectedSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> <span class="title class_">ZooKeeperConnection</span>();</span><br><span class="line">         zk = conn.connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">         <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> znode_exists(path);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] b = zk.getData(path, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent we)</span> &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (we.getType() == Event.EventType.None) &#123;</span><br><span class="line">                     <span class="keyword">switch</span>(we.getState()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> Expired:</span><br><span class="line">                        connectedSignal.countDown();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/MyFirstZnode&quot;</span>;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">byte</span>[] bn = zk.getData(path,</span><br><span class="line">                        <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bn,</span><br><span class="line">                        <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                        System.out.println(data);</span><br><span class="line">                        connectedSignal.countDown();</span><br><span class="line"></span><br><span class="line">                     &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">                        System.out.println(ex.getMessage());</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            connectedSignal.await();</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Node does not exists&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦编译和执行应用程序，你将获得以下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My first zookeeper app</span><br></pre></td></tr></table></figure><p>应用程序将等待ZooKeeper集合的进一步通知。使用ZooKeeper CLI <strong>zkCli.sh</strong> 更改指定znode的数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">set</span> /MyFirstZnode Hello</span><br></pre></td></tr></table></figure><p>现在，应用程序将打印以下输出并退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure><h2 id="setData方法"><a href="#setData方法" class="headerlink" title="setData方法"></a>setData方法</h2><p>ZooKeeper类提供 <strong>setData</strong> 方法来修改指定znode中附加的数据。 <strong>setData</strong> 方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setData(String path, <span class="type">byte</span>[] data, <span class="type">int</span> version)</span><br></pre></td></tr></table></figure><ul><li><strong>path</strong>- Znode路径</li><li><strong>data</strong> - 要存储在指定znode路径中的数据。</li><li><strong>version</strong>- znode的当前版本。每当数据更改时，ZooKeeper会更新znode的版本号。</li></ul><p>现在让我们创建一个新的Java应用程序来了解ZooKeeper API的 <strong>setData</strong> 功能。创建文件 <strong>ZKSetData.java</strong> 。在main方法中，使用 <strong>ZooKeeperConnection</strong> 对象创建一个ZooKeeper对象 <strong>zk</strong> 。然后，使用指定的路径，新数据和节点版本调用 <strong>zk</strong> 对象的 <strong>setData</strong> 方法。</p><p>以下是修改附加在指定znode中的数据的完整程序代码。</p><h3 id="编码：ZKSetData-java"><a href="#编码：ZKSetData-java" class="headerlink" title="编码：ZKSetData.java"></a>编码：ZKSetData.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKSetData</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to update the data in a znode. Similar to getData but without watcher.</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String path, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span></span><br><span class="line">      KeeperException,InterruptedException &#123;</span><br><span class="line">      zk.setData(path, data, zk.exists(path,<span class="literal">true</span>).getVersion());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException &#123;</span><br><span class="line">      String path= <span class="string">&quot;/MyFirstZnode&quot;</span>;</span><br><span class="line">      <span class="type">byte</span>[] data = <span class="string">&quot;Success&quot;</span>.getBytes(); <span class="comment">//Assign data which is to be updated.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> <span class="title class_">ZooKeeperConnection</span>();</span><br><span class="line">         zk = conn.connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">         update(path, data); <span class="comment">// Update znode data to the specified path</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行应用程序后，指定的znode的数据将被改变，并且可以使用ZooKeeper CLI <strong>zkCli.sh</strong> 进行检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; get /MyFirstZnode</span><br></pre></td></tr></table></figure><h2 id="getChildren方法"><a href="#getChildren方法" class="headerlink" title="getChildren方法"></a>getChildren方法</h2><p>ZooKeeper类提供 <strong>getChildren</strong> 方法来获取特定znode的所有子节点。 <strong>getChildren</strong> 方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getChildren(String path, Watcher watcher)</span><br></pre></td></tr></table></figure><ul><li><strong>path</strong> - Znode路径。</li><li><strong>watcher</strong> - 监视器类型的回调函数。当指定的znode被删除或znode下的子节点被创建&#x2F;删除时，ZooKeeper集合将进行通知。这是一次性通知。</li></ul><h3 id="编码：ZKGetChildren-java"><a href="#编码：ZKGetChildren-java" class="headerlink" title="编码：ZKGetChildren.java"></a>编码：ZKGetChildren.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKGetChildren</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to check existence of znode and its status, if znode is available.</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stat <span class="title function_">znode_exists</span><span class="params">(String path)</span> <span class="keyword">throws</span> </span><br><span class="line">      KeeperException,InterruptedException &#123;</span><br><span class="line">      <span class="keyword">return</span> zk.exists(path,<span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/MyFirstZnode&quot;</span>; <span class="comment">// Assign path to the znode</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> <span class="title class_">ZooKeeperConnection</span>();</span><br><span class="line">         zk = conn.connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">         <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> znode_exists(path); <span class="comment">// Stat checks the path</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(stat!= <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//“getChildren&quot; method- get all the children of znode.It has two</span></span><br><span class="line">            args, path and watch</span><br><span class="line">            List &lt;String&gt; children = zk.getChildren(path, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.size(); i++)</span><br><span class="line">            System.out.println(children.get(i)); <span class="comment">//Print children&#x27;s</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Node does not exists&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行程序之前，让我们使用ZooKeeper CLI <strong>zkCli.sh</strong> 为 <strong>&#x2F;MyFirstZnode</strong> 创建两个子节点。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/zookeeper</span><br><span class="line">bin/zkCli.sh</span><br><span class="line">&gt;&gt;&gt; create /MyFirstZnode/myfirstsubnode Hi</span><br><span class="line">&gt;&gt;&gt; create /MyFirstZnode/mysecondsubmode Hi</span><br></pre></td></tr></table></figure><p>现在，编译和运行程序将输出上面创建的znode。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myfirstsubnode</span><br><span class="line">mysecondsubnode</span><br></pre></td></tr></table></figure><h2 id="删除Znode"><a href="#删除Znode" class="headerlink" title="删除Znode"></a>删除Znode</h2><p>ZooKeeper类提供了 <strong>delete</strong> 方法来删除指定的znode。 <strong>delete</strong> 方法的签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(String path, <span class="type">int</span> version)</span><br></pre></td></tr></table></figure><ul><li><strong>path</strong> - Znode路径。</li><li><strong>version</strong> - znode的当前版本。</li></ul><p>让我们创建一个新的Java应用程序来了解ZooKeeper API的 <strong>delete</strong> 功能。创建文件 <strong>ZKDelete.java</strong> 。在main方法中，使用 <strong>ZooKeeperConnection</strong> 对象创建一个ZooKeeper对象 <strong>zk</strong> 。然后，使用指定的路径和版本号调用 <strong>zk</strong> 对象的 <strong>delete</strong> 方法。</p><p>删除znode的完整程序代码如下：</p><h3 id="编码：ZKDelete-java"><a href="#编码：ZKDelete-java" class="headerlink" title="编码：ZKDelete.java"></a>编码：ZKDelete.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKDelete</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zk;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperConnection conn;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Method to check existence of znode and its status, if znode is available.</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String path)</span> <span class="keyword">throws</span> KeeperException,InterruptedException &#123;</span><br><span class="line">      zk.delete(path,zk.exists(path,<span class="literal">true</span>).getVersion());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,KeeperException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/MyFirstZnode&quot;</span>; <span class="comment">//Assign path to the znode</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         conn = <span class="keyword">new</span> <span class="title class_">ZooKeeperConnection</span>();</span><br><span class="line">         zk = conn.connect(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">         delete(path); <span class="comment">//delete the node with the specified path</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage()); <span class="comment">// catches error messages</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、Zookeeper-API&quot;&gt;&lt;a href=&quot;#七、Zookeeper-API&quot; class=&quot;headerlink&quot; title=&quot;七、Zookeeper API&quot;&gt;&lt;/a&gt;七、Zookeeper API&lt;/h1&gt;&lt;p&gt;ZooKeeper有一个绑定Java</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper 应用程序</title>
    <link href="https://hexo.tryrun.top/posts/ea448247.html"/>
    <id>https://hexo.tryrun.top/posts/ea448247.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八、Zookeeper-应用程序"><a href="#八、Zookeeper-应用程序" class="headerlink" title="八、Zookeeper 应用程序"></a>八、Zookeeper 应用程序</h1><p>Zookeeper为分布式环境提供灵活的协调基础架构。ZooKeeper框架支持许多当今最好的工业应用程序。我们将在本章中讨论ZooKeeper的一些最显着的应用。</p><h2 id="雅虎"><a href="#雅虎" class="headerlink" title="雅虎"></a>雅虎</h2><p>ZooKeeper框架最初是在“Yahoo!”中构建的。设计良好的分布式应用程序需要满足诸如数据透明度，更好的性能，稳健性，集中配置和协调等要求。所以，他们设计了ZooKeeper框架来满足这些要求。</p><h2 id="Apache-Hadoop"><a href="#Apache-Hadoop" class="headerlink" title="Apache Hadoop"></a>Apache Hadoop</h2><p>Apache Hadoop是大数据行业发展的推动力。Hadoop依靠ZooKeeper进行配置管理和协调。让我们来了解一下ZooKeeper在Hadoop中的作用。</p><p>假设 <strong>Hadoop集群</strong> 桥接100个或更多的商品服务器。那么，就需要协调和命名服务。因此涉及大量节点的计算，每个节点需要彼此同步，知道在哪里访问服务器，以及知道如何配置它们。在这个时间点，Hadoop集群需要跨节点服务器。ZooKeeper提供<strong>跨节点同步</strong>的功能，并确保跨越Hadoop项目的任务被序列化和同步化。</p><p>多个ZooKeeper服务器支持大型Hadoop集群。每个客户端机器与ZooKeeper服务器之一通信以检索和更新其同步信息。一些实时示例如下：</p><ul><li><strong>人类基因组计划</strong> - 人类基因组计划包含兆兆字节数据。Hadoop MapReduce框架可用于分析数据集并为人类发展找到有趣的事实。</li><li><strong>医疗保健</strong> - 医院可以存储，检索和分析大量患者医疗记录，通常为兆兆字节。</li></ul><h2 id="Apache-HBase"><a href="#Apache-HBase" class="headerlink" title="Apache HBase"></a>Apache HBase</h2><p>Apache HBase是一个开源的，分布式的NoSQL数据库，用于大型数据集的实时读&#x2F;写访问，并在HDFS上运行。HBase遵循<strong>主从架构</strong>，HBase主控制所有从机。从机称为<strong>区域服务器</strong>。</p><p>HBase分布式应用程序安装取决于运行的ZooKeeper集群。Apache HBase使用ZooKeeper通过<strong>集中式配置管理</strong>和<strong>分布式互斥</strong>机制来帮助主机和区域服务器跟踪分布式数据的状态。以下是一些HBase的用例：</p><ul><li><strong>电信</strong> - 电信行业存储数十亿条移动通话记录（约30TB&#x2F;月），实时访问这些通话记录成为一项巨大的任务。HBase可以用来实时，轻松，高效地处理所有记录。</li><li><strong>社交网络</strong> - 与电信行业类似，Twitter，LinkedIn和Facebook等网站通过用户创建的帖子接收大量数据。HBase可以用来查找最近的趋势和其他有趣的事实。</li></ul><h2 id="Apache-Solr"><a href="#Apache-Solr" class="headerlink" title="Apache Solr"></a>Apache Solr</h2><p>Apache Solr是一个用Java编写的快速，开源的搜索平台。它是一个快速，容错的分布式搜索引擎。建立在 <strong>Lucene</strong> 之上，是一个高性能，全功能的文本搜索引擎。</p><p>Solr广泛使用ZooKeeper的每个功能，如配置管理，leader选举，节点管理，数据锁定和同步化。</p><p>Solr有两个不同的部分，<strong>索引</strong>和<strong>搜索</strong>。索引是以适当格式存储数据以便后续可以搜索的过程。Solr使用ZooKeeper对多个节点中的数据进行索引和搜索。ZooKeeper提供以下功能：</p><ul><li>根据需要添加&#x2F;删除节点</li><li>在节点之间复制数据，随后最小化数据丢失</li><li>在多个节点之间共享数据，随后从多个节点搜索以获得更快的搜索结果</li></ul><p>Apache Solr的一些用例包括电子商务，求职搜索等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八、Zookeeper-应用程序&quot;&gt;&lt;a href=&quot;#八、Zookeeper-应用程序&quot; class=&quot;headerlink&quot; title=&quot;八、Zookeeper 应用程序&quot;&gt;&lt;/a&gt;八、Zookeeper 应用程序&lt;/h1&gt;&lt;p&gt;Zookeeper为分布式环</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dubbo 源码分析 – SPI 机制</title>
    <link href="https://hexo.tryrun.top/posts/910f48a0.html"/>
    <id>https://hexo.tryrun.top/posts/910f48a0.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Dubbo-源码分析-–-SPI-机制"><a href="#一、Dubbo-源码分析-–-SPI-机制" class="headerlink" title="一、Dubbo 源码分析 – SPI 机制"></a>一、Dubbo 源码分析 – SPI 机制</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口 加载实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。下面，我们先来了解一下 Java SPI 与 Dubbo SPI 的使用方法，然后再来分析 Dubbo SPI 的源码。</p><h2 id="2-SPI-示例"><a href="#2-SPI-示例" class="headerlink" title="2.SPI 示例"></a>2.SPI 示例</h2><h3 id="2-1-Java-SPI-示例"><a href="#2-1-Java-SPI-示例" class="headerlink" title="2.1 Java SPI 示例"></a>2.1 Java SPI 示例</h3><p>前面简单介绍了 SPI 机制的原理，本节通过一个示例来演示 JAVA SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义两个实现类，分别为擎天柱 OptimusPrime 和大黄蜂 Bumblebee。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来 META-INF&#x2F;services 文件夹下创建一个文件，名称为 Robot 的全限定名 com.tianxiaobo.spi.Robot。文件内容为实现类的全限定的类名，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.tianxiaobo.spi.OptimusPrime</span><br><span class="line">com.tianxiaobo.spi.Bumblebee</span><br></pre></td></tr></table></figure><p>做好了所需的准备工作，接下来编写代码进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;Java SPI&quot;</span>);</span><br><span class="line">        serviceLoader.forEach(Robot::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。关于 Java SPI 的演示先到这，接下来演示 Dubbo SPI。</p><h3 id="2-2-Dubbo-SPI-示例"><a href="#2-2-Dubbo-SPI-示例" class="headerlink" title="2.2 Dubbo SPI 示例"></a>2.2 Dubbo SPI 示例</h3><p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 的实现类配置放置在 META-INF&#x2F;dubbo 路径下，下面来看一下配置内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimusPrime = com.tianxiaobo.spi.<span class="type">OptimusPrime</span></span><br><span class="line"><span class="variable">bumblebee</span> <span class="operator">=</span> com.tianxiaobo.spi.Bumblebee</span><br></pre></td></tr></table></figure><p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们就可以按需加载指定的实现类了。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注 @SPI 注解。下面来演示一下 Dubbo SPI 的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">optimusPrime</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示完 Dubbo SPI，下面来看看 Dubbo SPI 对 Java SPI 做了哪些改进，以下内容引用至 Dubbo 官方文档。</p><ul><li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li><li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li><li>增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li></ul><p>在以上改进项中，第一个改进项比较好理解。第二个改进项没有进行验证，就不多说了。第三个改进项是增加了对 IOC 和 AOP 的支持，这是什么意思呢？这里简单解释一下，Dubbo SPI 加载完拓展实例后，会通过该实例的 setter 方法解析出实例依赖项的名称。比如通过 setProtocol 方法名，可知道目标实例依赖 Protocal。知道了具体的依赖，接下来即可到 IOC 容器中寻找或生成一个依赖对象，并通过 setter 方法将依赖注入到目标实例中。说完 Dubbo IOC，接下来说说 Dubbo AOP。Dubbo AOP 是指使用 Wrapper 类（可自定义实现）对拓展对象进行包装，Wrapper 类中包含了一些自定义逻辑，这些逻辑可在目标方法前行前后被执行，类似 AOP。Dubbo AOP 实现的很简单，其实就是个代理模式。这个官方文档中有所说明，大家有兴趣可以查阅一下。</p><p>关于 Dubbo SPI 的演示，以及与 Java SPI 的对比就先这么多，接下来加入源码分析阶段。</p><h2 id="3-Dubbo-SPI-源码分析"><a href="#3-Dubbo-SPI-源码分析" class="headerlink" title="3. Dubbo SPI 源码分析"></a>3. Dubbo SPI 源码分析</h2><p>上一章，我简单演示了 Dubbo SPI 的使用方法。我们首先通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader 用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。该方法的逻辑比较简单，本章就不就行分析了。下面我们从 ExtensionLoader 的 getExtension 方法作为入口，对拓展类对象的获取过程进行详细的分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Holder 仅用于持有目标对象，没其他什么逻辑</span></span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建拓展实例，并设置到 holder 中</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。下面我们来看一下创建拓展对象的过程是怎样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所有的拓展类，形成配置项名称到配置类的映射关系</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射创建实例</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="literal">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环创建 Wrapper 实例</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 将当前 instance 作为参数创建 Wrapper 实例，然后向 Wrapper 实例中注入属性值，</span></span><br><span class="line">                <span class="comment">// 并将 Wrapper 实例赋值给 instance</span></span><br><span class="line">                instance = injectExtension(</span><br><span class="line">                    (T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p><ol><li>通过 getExtensionClasses 获取所有的拓展类</li><li>通过反射创建拓展对象</li><li>向拓展对象中注入依赖</li><li>将拓展对象包裹在相应的 Wrapper 对象中</li></ol><p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。在接下来的章节中，我将会重点分析 getExtensionClasses 方法的逻辑，以及简单分析 Dubbo IOC 的具体实现。</p><h3 id="3-1-获取所有的拓展类"><a href="#3-1-获取所有的拓展类" class="headerlink" title="3.1 获取所有的拓展类"></a>3.1 获取所有的拓展类</h3><p>我们在通过名称获取拓展类之前，首先需要根据配置文件解析出名称到拓展类的映射，也就是 Map&lt;名称, 拓展类&gt;。之后再从 Map 中取出相应的拓展类即可。相关过程的代码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取已加载的拓展类</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载拓展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则加载拓展类。以上代码的写法是典型的双重检查锁，前面所分析的 getExtension 方法中有相似的代码。关于双重检查就说这么多，下面分析 loadExtensionClasses 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 获取 SPI 注解，这里的 type 是在调用 getExtensionLoader 方法时传入的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SPI</span> <span class="variable">defaultAnnotation</span> <span class="operator">=</span> type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对 SPI 注解内容进行切分</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="comment">// 检测 SPI 注解内容是否合法，不合法则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置默认名称，cachedDefaultName 用于加载默认实现，参考 getDefaultExtension 方法</span></span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">                cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// 加载指定文件夹配置文件</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。SPI 注解解析过程比较简单，无需多说。下面我们来看一下 loadDirectory 做了哪些事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> &#123;</span><br><span class="line">    <span class="comment">// fileName = 文件夹路径 + type 全限定名 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dir + type.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据文件名加载所有的同名文件</span></span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.<span class="type">URL</span> <span class="variable">resourceURL</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载资源</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadDirectory 方法代码不多，理解起来不难。该方法先通过 classLoader 获取所有资源链接，然后再通过 loadResource 方法加载资源。我们继续跟下去，看一下 loadResource 方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, </span></span><br><span class="line"><span class="params">    ClassLoader classLoader, java.net.URL resourceURL)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resourceURL.openStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 截取 # 之前的字符串，# 之后的内容为注释</span></span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以 = 为界，截取键与值。比如 dubbo=com.alibaba....DubboProtocol</span></span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载解析出来的限定类名</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, </span><br><span class="line">                                      Class.forName(line, <span class="literal">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。loadClass 方法有点名不副实，它的功能只是操作缓存，而非加载类。该方法的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, </span></span><br><span class="line"><span class="params">    Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;    <span class="comment">// 检测目标类上是否有 Adaptive 注解</span></span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 cachedAdaptiveClass缓存</span></span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;    <span class="comment">// 检测 clazz 是否是 Wrapper 类型</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="literal">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储 clazz 到 cachedWrapperClasses 缓存中</span></span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 程序进入此分支，表明是一个普通的拓展类</span></span><br><span class="line">        <span class="comment">// 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 name 为空，则尝试从 Extension 注解获取 name，或使用小写的类名作为 name</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切分 name</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="literal">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Activate</span> <span class="variable">activate</span> <span class="operator">=</span> clazz.getAnnotation(Activate.class);</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果类上有 Activate 注解，则使用 names 数组的第一个元素作为键，</span></span><br><span class="line">                <span class="comment">// 存储 name 到 Activate 注解对象的映射关系</span></span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                    <span class="comment">// 存储 Class 到名称的映射关系</span></span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储名称到 Class 的映射关系</span></span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，loadClass 方法操作了不同的缓存，比如 cachedAdaptiveClass、cachedWrapperClasses 和 cachedNames 等等。除此之外，该方法没有其他什么逻辑了，就不多说了。</p><p>到此，关于缓存类加载的过程就分析完了。整个过程没什么特别复杂的地方，大家按部就班的分析就行了，不懂的地方可以调试一下。接下来，我们来聊聊 Dubbo IOC 方面的内容。</p><h3 id="3-2-Dubbo-IOC"><a href="#3-2-Dubbo-IOC" class="headerlink" title="3.2 Dubbo IOC"></a>3.2 Dubbo IOC</h3><p>Dubbo IOC 是基于 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历目标类的所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">// 获取 setter 方法参数类型</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取属性名</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> method.getName().length() &gt; <span class="number">3</span> ? </span><br><span class="line">                            method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + </span><br><span class="line">                                method.getName().substring(<span class="number">4</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="comment">// 从 ObjectFactory 中获取依赖对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射调用 setter 方法设置依赖</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，关于自适应拓展，我将会在下一篇文章中进行说明。SpringExtensionFactory 则是到 Spring 的 IOC 容器中获取所需拓展，该类的实现并不复杂，大家自行分析源码，这里就不多说了。</p><p>Dubbo IOC 的实现比较简单，仅支持 setter 方式注入。总的来说，逻辑简单易懂。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本篇文章简单介绍了 Java SPI 与 Dubbo SPI 用法与区别，并对 Dubbo SPI 的部分源码进行了分析。在 Dubbo SPI 中还有一块重要的逻辑没有进行分析，那就是 Dubbo SPI 的扩展点自适应机制。该机制的逻辑较为复杂，我将会在下一篇文章中进行分析。好了，其他的就不多说了，本篇文件就先到这里了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Dubbo-源码分析-–-SPI-机制&quot;&gt;&lt;a href=&quot;#一、Dubbo-源码分析-–-SPI-机制&quot; class=&quot;headerlink&quot; title=&quot;一、Dubbo 源码分析 – SPI 机制&quot;&gt;&lt;/a&gt;一、Dubbo 源码分析 – SPI 机制&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dubbo 源码分析 – 自适应拓展原理</title>
    <link href="https://hexo.tryrun.top/posts/cf451fe.html"/>
    <id>https://hexo.tryrun.top/posts/cf451fe.html</id>
    <published>2023-06-14T14:55:52.249Z</published>
    <updated>2023-06-14T14:55:52.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Dubbo-源码分析-–-自适应拓展原理"><a href="#二、Dubbo-源码分析-–-自适应拓展原理" class="headerlink" title="二、Dubbo 源码分析 – 自适应拓展原理"></a>二、Dubbo 源码分析 – 自适应拓展原理</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>我在上一篇文章中分析了 Dubbo 的 SPI 机制，Dubbo SPI 是 Dubbo 框架的核心。Dubbo 中的很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并非想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，就无法进行加载，这似乎是个死结。不过好在也有相应的解决办法，通过代理模式就可以解决这个问题，这里我们将具有代理功能的拓展称之为自适应拓展。Dubbo 并未直接通过代理模式实现自适应拓展，而是代理代理模式基础上，封装了一个更炫的实现方式。Dubbo 首先会为拓展接口生成具有代理功能的代码，然后通过 javassist 或 jdk 编译这段代码，得到 Class 类，最后在通过反射创建代理类。整个过程比较复杂、炫丽。如此复杂的过程最终的目的是为拓展生成代理对象，但实际上每个代理对象的代理逻辑基本一致，均是从 URL 中获取欲加载实现类的名称。因此，我们完全可以把代理逻辑抽出来，并通过动态代理的方式实现自适应拓展。这样做的好处显而易见，方便维护，也方便源码学习者学习和调试代码。本文将在随后实现一个动态代理版的自适应拓展，有兴趣的同学可以继续往下读。</p><p>接下来，我们通过一个示例演示自适应拓展类。这个示例取自 Dubbo 官方文档，我这里进行了一定的拓展。这是一个与汽车相关的例子，我们有一个车轮制造厂接口 WheelMaker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WheelMaker</span> &#123;</span><br><span class="line">    Wheel <span class="title function_">makeWheel</span><span class="params">(URL url)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WheelMaker 接口的 Adaptive 实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveWheelMaker</span> <span class="keyword">implements</span> <span class="title class_">WheelMaker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Wheel <span class="title function_">makeWheel</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.从 URL 中获取 WheelMaker 名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">wheelMakerName</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;Wheel.maker&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;wheelMakerName == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过 SPI 加载具体的 WheelMaker</span></span><br><span class="line">        <span class="type">WheelMaker</span> <span class="variable">wheelMaker</span> <span class="operator">=</span> ExtensionLoader</span><br><span class="line">            .getExtensionLoader(WheelMaker.class).getExtension(wheelMakerName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调用目标方法</span></span><br><span class="line">        <span class="keyword">return</span> wheelMaker.makeWheel(URL url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AdaptiveWheelMaker 是一个代理类，它主要做了三件事情：</p><ol><li>从 URL 中获取 WheelMaker 名称</li><li>通过 SPI 加载具体的 WheelMaker</li><li>调用目标方法</li></ol><p>接下来，我们来看看汽车制造厂 CarMaker 接口与其实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarMaker</span> &#123;</span><br><span class="line">    Car <span class="title function_">makeCar</span><span class="params">(URL url)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaceCarMaker</span> <span class="keyword">implements</span> <span class="title class_">CarMaker</span> &#123;</span><br><span class="line">    WheelMaker wheelMaker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 setter 注入 AdaptiveWheelMaker</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">setWheelMaker</span><span class="params">(WheelMaker wheelMaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wheelMaker = wheelMaker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">makeCar</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">        <span class="type">Wheel</span> <span class="variable">wheel</span> <span class="operator">=</span> wheelMaker.makeWheel(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RaceCar</span>(wheel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RaceCarMaker 持有一个 WheelMaker 类型从成员变量，在程序启动时，我们可以将 AdaptiveWheelMaker 通过 setter 方法注入到 RaceCarMaker 中。在运行时，假设有这样一个 URL 类型的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.0.101:20880/XxxService?wheel.maker=MichelinWheelMaker</span><br></pre></td></tr></table></figure><p>RaceCarMaker 的 makeCar 方法将上面的 url 作为参数传给 AdaptiveWheelMaker 的 makeWheel 方法，makeWheel 方法从 url 中提取 wheel.maker 参数，得到 MichelinWheelMaker。之后再通过 SPI 加载名为 MichelinWheelMaker 的实现类，得到具体的 WheelMaker 实例。</p><p>上面这个示例展示了自适应拓展类的核心实现 – 在组件方法被调用时，通过代理的方式加载指定的实现类，并调用被代理的方法。</p><p>经过以上说明，大家应该搞懂了自适应拓展的原理。接下来，我们深入到源码中，探索自适应拓展生成的过程。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><p>在对自适应拓展生成过程进行深入分析之前，我们先来看一下与自适应拓展息息相关的一个注解，即 Adaptive 注解。该注解的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可知，Adaptive 可注解在类或方法上。注解在类上时，Dubbo 不会为该类生成代理类。注解上方法（接口方法）上时，Dubbo 会为为该方法生成代理逻辑。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况表示拓展的加载逻辑由人工编码完成。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成。Adaptive 注解的地方不同，相应的处理逻辑也是不同的。注解在类上时，处理逻辑比较简单，本文就不分析了。注解在接口方法上时，处理逻辑较为复杂，本章将会重点分析此块逻辑。接下来，我们从 getAdaptiveExtension 方法进行分析。代码如下：</p><h3 id="2-1-获取自适应拓展"><a href="#2-1-获取自适应拓展" class="headerlink" title="2.1 获取自适应拓展"></a>2.1 获取自适应拓展</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取自适应拓展</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;    <span class="comment">// 缓存未命中</span></span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建自适应拓展</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        <span class="comment">// 设置拓展到缓存中</span></span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAdaptiveExtension 方法首先会检查缓存，缓存未命中，则调用 createAdaptiveExtension 方法创建自适应拓展。下面，我们看一下 createAdaptiveExtension 方法的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取自适应拓展类，并通过反射实例化</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtension 方法代码比较少，但却包含了三个动作，分别如下：</p><ol><li>调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象</li><li>通过反射进行实例化</li><li>调用 injectExtension 方法向拓展实例中注入依赖</li></ol><p>前两个动作比较好理解，第三个动作不好理解，这里简单说明一下。injectExtension 方法通过 setter 方法向目标对象中注入依赖，可以看做是一个简单 IOC 的实现。前面说过，Dubbo 中有两种类型的自适应拓展，一种是手工编码的，一种是自动生成的。手工编码的 Adaptive 拓展中可能存在着一些依赖，而自动生成的 Adaptive 拓展则不会依赖其他类。这里调用 injectExtension 方法的目的是为手工编码的自适应拓展注入依赖，这一点需要大家注意一下。关于 injectExtension 方法，我在上一篇文章中已经分析过了，这里不再赘述。接下来，分析 getAdaptiveExtensionClass 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 通过 SPI 获取所有的拓展类</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 检查缓存，若缓存不为空，则直接返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建自适应拓展类</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAdaptiveExtensionClass 方法也包含了三个步骤，如下：</p><ol><li>调用 getExtensionClasses 获取所有的拓展类</li><li>检查缓存，若缓存不为空，则返回缓存</li><li>若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类</li></ol><p>这三个步骤看起来平淡无奇，似乎没有多讲的必要。但是这些平淡无奇的代码中隐藏了一些细节，需要说明一下。首先从第一个步骤说起，getExtensionClasses 这个方法用于获取某个接口的所有实现类。比如该方法可以获取 Protocol 接口的 DubboProtocol、HttpProtocol、InjvmProtocol 等实现类。在获取实现类的过程中，如果某个某个实现类被 Adaptive 注解修饰了，那么该类就会被赋值给 cachedAdaptiveClass 变量。此时，上面步骤中的第二步条件成立（缓存不为空），直接返回 cachedAdaptiveClass 即可。如果所有的实现类均未被 Adaptive 注解修饰，那么执行第三步逻辑，创建自适应拓展类。相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 构建自适应拓展代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> createAdaptiveExtensionClassCode();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    <span class="comment">// 获取编译器实现类</span></span><br><span class="line">    com.alibaba.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 编译代码，生成 Class</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtensionClass 方法用于生成自适应拓展类，该方法首先会生成自适应拓展类的源码，然后通过 Compiler 实例（Dubbo 默认使用 javassist 作为编译器）编译源码，得到代理类 Class 实例。接下来，我将重点分析代理类代码生成逻辑。至于代码编译的过程，并非本文范畴，这里就不分析了，大家有兴趣可以自己看看。下面，我们把目光聚焦在 createAdaptiveExtensionClassCode 方法上。</p><h3 id="2-2-自适应拓展类代码生成"><a href="#2-2-自适应拓展类代码生成" class="headerlink" title="2.2 自适应拓展类代码生成"></a>2.2 自适应拓展类代码生成</h3><p>createAdaptiveExtensionClassCode 方法代码略多，约有两百行代码。因此在本节中，我将会对该方法的代码进行拆分分析，以帮助大家更好的理解代码含义。</p><h4 id="2-2-1-Adaptive-注解检测"><a href="#2-2-1-Adaptive-注解检测" class="headerlink" title="2.2.1 Adaptive 注解检测"></a>2.2.1 Adaptive 注解检测</h4><p>在生成代理类源码之前，createAdaptiveExtensionClassCode 方法首先会通过反射检测接口方法是否包含 Adaptive 注解。对于要生成自适应拓展的接口，Dubbo 要求该接口至少有一个方法被 Adaptive 注解修饰。若不满足此条件，就会抛出运行时异常。相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取所有的方法</span></span><br><span class="line">Method[] methods = type.getMethods();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasAdaptiveAnnotation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 遍历方法列表</span></span><br><span class="line"><span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">    <span class="comment">// 检测方法上是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (m.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        hasAdaptiveAnnotation = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!hasAdaptiveAnnotation)</span><br><span class="line">    <span class="comment">// 若所有的方法上均无 Adaptive 注解，则抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-2-生成类"><a href="#2-2-2-生成类" class="headerlink" title="2.2.2 生成类"></a>2.2.2 生成类</h4><p>通过 Adaptive 注解检测后，即可开始生成代码。代码生成的顺序与 Java 文件内容顺序一致，首先会生成 package 语句，然后生成 import 语句，紧接着生成类名等代码。整个逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 package 代码：package + type 所在包</span></span><br><span class="line">codeBuilder.append(<span class="string">&quot;package &quot;</span>).append(type.getPackage().getName()).append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line"><span class="comment">// 生成 import 代码：import + ExtensionLoader 全限定名</span></span><br><span class="line">codeBuilder.append(<span class="string">&quot;\nimport &quot;</span>).append(ExtensionLoader.class.getName()).append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line"><span class="comment">// 生成类代码：public class + type简单名称 + $Adaptive + implements + type全限定名 + &#123;</span></span><br><span class="line">codeBuilder.append(<span class="string">&quot;\npublic class &quot;</span>)</span><br><span class="line">    .append(type.getSimpleName())</span><br><span class="line">    .append(<span class="string">&quot;$Adaptive&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot; implements &quot;</span>)</span><br><span class="line">    .append(type.getCanonicalName())</span><br><span class="line">    .append(<span class="string">&quot; &#123;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;生成方法&#125;</span></span><br><span class="line"></span><br><span class="line">codeBuilder.append(<span class="string">&quot;\n&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，我用 ${…} 占位符代表其他代码的生成逻辑，该部分逻辑我将在随后进行分析。上面代码不是很难理解，这里我直接通过一个例子展示该段代码所生成的内容。以 Dubbo 的 Protocol 接口为例，生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">com</span>.alibaba.dubbo.rpc.Protocol &#123;</span><br><span class="line">    <span class="comment">// 省略方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-生成方法"><a href="#2-2-3-生成方法" class="headerlink" title="2.2.3 生成方法"></a>2.2.3 生成方法</h4><p>一个方法可以被 Adaptive 注解修饰，也可以不被修饰。这里将未被 Adaptive 注解修饰的方法称为“无 Adaptive 注解方法”，下面我们先来看看此种方法的代码生成逻辑是怎样的。</p><h5 id="2-2-3-1-无-Adaptive-注解方法代码生成"><a href="#2-2-3-1-无-Adaptive-注解方法代码生成" class="headerlink" title="2.2.3.1 无 Adaptive 注解方法代码生成"></a>2.2.3.1 无 Adaptive 注解方法代码生成</h5><p>对于接口方法，我们可以按照需求标注 Adaptive 注解。以 Protocol 接口为例，该接口的 destroy 和 getDefaultPort 未标注 Adaptive 注解，其他方法均标注了 Adaptive 注解。Dubbo 不会为没有标注 Adaptive 注解的方法生成代理逻辑，对于该种类型的方法，仅会生成一句抛出异常的代码。生成逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="comment">// 如果方法上无 Adaptive 注解，则生成 throw new UnsupportedOperationException(...) 代码</span></span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成规则：</span></span><br><span class="line">        <span class="comment">// throw new UnsupportedOperationException(</span></span><br><span class="line">        <span class="comment">//     &quot;method &quot; + 方法签名 + of interface + 全限定接口名 + is not adaptive method!”)</span></span><br><span class="line">        code.append(<span class="string">&quot;throw new UnsupportedOperationException(\&quot;method &quot;</span>)</span><br><span class="line">            .append(method.toString()).append(<span class="string">&quot; of interface &quot;</span>)</span><br><span class="line">            .append(type.getName()).append(<span class="string">&quot; is not adaptive method!\&quot;);&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略无关逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 Protocol 接口的 destroy 方法为例，上面代码生成的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">            <span class="string">&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="2-2-3-2-获取-URL-数据"><a href="#2-2-3-2-获取-URL-数据" class="headerlink" title="2.2.3.2 获取 URL 数据"></a>2.2.3.2 获取 URL 数据</h5><p>前面说过方法代理逻辑会从 URL 中提取目标拓展的名称，因此代码生成逻辑的一个重要的任务是从方法的参数列表获取其他参数中获取 URL 数据。举个例子说明一下，我们要为 Protocol 接口的 refer 和 export 方法生成代理逻辑。在运行时，通过反射得到的方法定义大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoker <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; arg0, URL arg1)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">Exporter <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; arg0)</span> <span class="keyword">throws</span> RpcException;</span><br></pre></td></tr></table></figure><p>对于 refer 方法，通过遍历 refer 的参数列表即可获取 URL 数据，这个还比较简单。对于 export 方法，获取 URL 数据则要麻烦一些。export 参数列表中没有 URL 参数，因此需要从 Invoker 参数中获取 URL 数据。获取方式是调用 Invoker 中可返回 URL 的 getter 方法，比如 getUrl。如果 Invoker 中无相关 getter 方法，此时则会抛出异常。整个逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// $&#123;无 Adaptive 注解方法代码生成&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">urlTypeIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历参数列表，确定 URL 参数位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pts[i].equals(URL.class)) &#123;</span><br><span class="line">                urlTypeIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;    <span class="comment">// 参数列表中存在 URL 参数</span></span><br><span class="line">            <span class="comment">// 为 URL 类型参数生成判空代码，格式如下：</span></span><br><span class="line">            <span class="comment">// if (arg + urlTypeIndex == null) </span></span><br><span class="line">            <span class="comment">//     throw new IllegalArgumentException(&quot;url == null&quot;);</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.format(<span class="string">&quot;\nif (arg%d == null) throw new IllegalArgumentException(\&quot;url == null\&quot;);&quot;</span>,</span><br><span class="line">                                     urlTypeIndex);</span><br><span class="line">            code.append(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为 URL 类型参数生成赋值代码，即 URL url = arg1 或 arg2，或 argN</span></span><br><span class="line">            s = String.format(<span class="string">&quot;\n%s url = arg%d;&quot;</span>, URL.class.getName(), urlTypeIndex);</span><br><span class="line">            code.append(s);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 参数列表中不存在 URL 类型参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">attribMethod</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            LBL_PTS:</span><br><span class="line">            <span class="comment">// 遍历方法的参数类型列表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 获取某一类型参数的全部方法</span></span><br><span class="line">                Method[] ms = pts[i].getMethods();</span><br><span class="line">                <span class="comment">// 遍历方法列表，寻找可返回 URL 的 getter 方法</span></span><br><span class="line">                <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line">                    <span class="comment">// 1. 方法名以 get 开头，或方法名大于3个字符</span></span><br><span class="line">                    <span class="comment">// 2. 方法的访问权限为 public</span></span><br><span class="line">                    <span class="comment">// 3. 方法非静态类型</span></span><br><span class="line">                    <span class="comment">// 4. 方法参数数量为0</span></span><br><span class="line">                    <span class="comment">// 5. 方法返回值类型为 URL</span></span><br><span class="line">                    <span class="keyword">if</span> ((name.startsWith(<span class="string">&quot;get&quot;</span>) || name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                        &amp;&amp; Modifier.isPublic(m.getModifiers())</span><br><span class="line">                        &amp;&amp; !Modifier.isStatic(m.getModifiers())</span><br><span class="line">                        &amp;&amp; m.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; m.getReturnType() == URL.class) &#123;</span><br><span class="line">                        urlTypeIndex = i;</span><br><span class="line">                        attribMethod = name;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 结束 for (int i = 0; i &lt; pts.length; ++i) 循环</span></span><br><span class="line">                        <span class="keyword">break</span> LBL_PTS;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (attribMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果所有参数中均不包含可返回 URL 的 getter 方法，则抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为包含可返回 URL 的参数生成判空代码，格式如下：</span></span><br><span class="line">            <span class="comment">// if (arg + urlTypeIndex == null) </span></span><br><span class="line">            <span class="comment">//     throw new IllegalArgumentException(&quot;参数全限定名 + argument == null&quot;);</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.format(<span class="string">&quot;\nif (arg%d == null) throw new IllegalArgumentException(\&quot;%s argument == null\&quot;);&quot;</span>,</span><br><span class="line">                                     urlTypeIndex, pts[urlTypeIndex].getName());</span><br><span class="line">            code.append(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为 getter 方法返回的 URL 生成判空代码，格式如下：</span></span><br><span class="line">            <span class="comment">// if (argN.getter方法名() == null) </span></span><br><span class="line">            <span class="comment">//     throw new IllegalArgumentException(参数全限定名 + argument getUrl() == null);</span></span><br><span class="line">            s = String.format(<span class="string">&quot;\nif (arg%d.%s() == null) throw new IllegalArgumentException(\&quot;%s argument %s() == null\&quot;);&quot;</span>,</span><br><span class="line">                              urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);</span><br><span class="line">            code.append(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成赋值语句，格式如下：</span></span><br><span class="line">            <span class="comment">// URL全限定名 url = argN.getter方法名()，比如 </span></span><br><span class="line">            <span class="comment">// com.alibaba.dubbo.common.URL url = invoker.getUrl();</span></span><br><span class="line">            s = String.format(<span class="string">&quot;%s url = arg%d.%s();&quot;</span>, URL.class.getName(), urlTypeIndex, attribMethod);</span><br><span class="line">            code.append(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有点多，但并不是很难看懂。这段代码主要是为了获取 URL 数据，并为之生成判空和赋值代码。以 Protocol 的 refer 和 export 方法为例，上面代码会为它们生成如下内容（代码已格式化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">refer:</span><br><span class="line"><span class="keyword">if</span> (arg1 == <span class="literal">null</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">com.alibaba.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line"></span><br><span class="line">export:</span><br><span class="line"><span class="keyword">if</span> (arg0 == <span class="literal">null</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;com.alibaba.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">com.alibaba.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br></pre></td></tr></table></figure><h5 id="2-2-3-3-获取-Adaptive-注解值"><a href="#2-2-3-3-获取-Adaptive-注解值" class="headerlink" title="2.2.3.3 获取 Adaptive 注解值"></a>2.2.3.3 获取 Adaptive 注解值</h5><p>Adaptive 注解值 value 类型为 String[]，可填写多个值，默认情况下为空数组。若 value 为非空数组，直接获取数组内容即可。若 value 为空数组，则需进行额外处理。处理的过程是将类名转换为字符数组，然后遍历字符数组，并将字符加入到 StringBuilder 中。若字符为大写字母，则向 StringBuilder 中添加点号，随后将字符变为小写存入 StringBuilder 中。比如 LoadBalance 经过处理后，得到 load.balance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// $&#123;无 Adaptive 注解方法代码生成&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// $&#123;获取 URL 数据&#125;</span></span><br><span class="line"></span><br><span class="line">        String[] value = adaptiveAnnotation.value();</span><br><span class="line">        <span class="comment">// value 为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取类名，并将类名转换为字符数组</span></span><br><span class="line">            <span class="type">char</span>[] charArray = type.getSimpleName().toCharArray();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">128</span>);</span><br><span class="line">            <span class="comment">// 遍历字节数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 检测当前字符是否为大写字母</span></span><br><span class="line">                <span class="keyword">if</span> (Character.isUpperCase(charArray[i])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 向 sb 中添加点号</span></span><br><span class="line">                        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将字符变为小写，并添加到 sb 中</span></span><br><span class="line">                    sb.append(Character.toLowerCase(charArray[i]));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加字符到 sb 中</span></span><br><span class="line">                    sb.append(charArray[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            value = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;sb.toString()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-4-检测-Invocation-参数"><a href="#2-2-3-4-检测-Invocation-参数" class="headerlink" title="2.2.3.4 检测 Invocation 参数"></a>2.2.3.4 检测 Invocation 参数</h5><p>此段逻辑是检测方法列表中是否存在 Invocation 类型的参数，若存在，则为其生成判空代码和其他一些代码。相应的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();    <span class="comment">// 获取参数类型列表</span></span><br><span class="line">    Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// $&#123;无 Adaptive 注解方法代码生成&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// $&#123;获取 URL 数据&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;获取 Adaptive 注解值&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasInvocation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历参数类型列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 判断当前参数名称是否等于 com.alibaba.dubbo.rpc.Invocation</span></span><br><span class="line">            <span class="keyword">if</span> (pts[i].getName().equals(<span class="string">&quot;com.alibaba.dubbo.rpc.Invocation&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 为 Invocation 类型参数生成判空代码</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.format(<span class="string">&quot;\nif (arg%d == null) throw new IllegalArgumentException(\&quot;invocation == null\&quot;);&quot;</span>, i);</span><br><span class="line">                code.append(s);</span><br><span class="line">                <span class="comment">// 生成 getMethodName 方法调用代码，格式为：</span></span><br><span class="line">                <span class="comment">//    String methodName = argN.getMethodName();</span></span><br><span class="line">                s = String.format(<span class="string">&quot;\nString methodName = arg%d.getMethodName();&quot;</span>, i);</span><br><span class="line">                code.append(s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置 hasInvocation 为 true</span></span><br><span class="line">                hasInvocation = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-5-生成拓展名获取逻辑"><a href="#2-2-3-5-生成拓展名获取逻辑" class="headerlink" title="2.2.3.5 生成拓展名获取逻辑"></a>2.2.3.5 生成拓展名获取逻辑</h5><p>本段逻辑用于根据 SPI 和 Adaptive 注解值生成“拓展名获取逻辑”，同时生成逻辑也受 Invocation 类型参数影响，综合因素导致本段逻辑相对复杂。本段逻辑可以会生成但不限于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> url.getMethodParameter(methodName, <span class="string">&quot;loadbalance&quot;</span>, <span class="string">&quot;random&quot;</span>);</span><br></pre></td></tr></table></figure><p>亦或是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;client&quot;</span>, url.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br></pre></td></tr></table></figure><p>本段逻辑复杂指出在于条件分支比较多，大家在阅读源码时需要知道每个条件分支的意义是什么，否则不太容易看懂相关代码。好了，其他的就不多说了，开始分析本段逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// $无 Adaptive 注解方法代码生成&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// $&#123;获取 URL 数据&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;获取 Adaptive 注解值&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;检测 Invocation 参数&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认拓展名，cachedDefaultName = SPI 注解值，比如 Protocol 接口上标注的 </span></span><br><span class="line">        <span class="comment">// SPI 注解值为 dubbo。默认情况下，SPI 注解值为空串，此时 cachedDefaultName = null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">defaultExtName</span> <span class="operator">=</span> cachedDefaultName;</span><br><span class="line">        <span class="type">String</span> <span class="variable">getNameCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 value，这里的 value 是 Adaptive 的注解值，2.2.3.3 节分析过 value 变量的获取过程。</span></span><br><span class="line">        <span class="comment">// 此处循环目的是生成从 URL 中获取拓展名的代码，生成的代码会赋值给 getNameCode 变量。注意这</span></span><br><span class="line">        <span class="comment">// 个循环的遍历顺序是由后向前遍历的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> value.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == value.length - <span class="number">1</span>) &#123;    <span class="comment">// 当 i 为最后一个元素的坐标时</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != defaultExtName) &#123;   <span class="comment">// 默认拓展名非空</span></span><br><span class="line">                    <span class="comment">// protocol 是 url 的一部分，可通过 getProtocol 方法获取，其他的则是从</span></span><br><span class="line">                    <span class="comment">// URL 参数中获取。所以这里要判断 value[i] 是否为 protocol</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i]))</span><br><span class="line">                        <span class="comment">// hasInvocation 用于标识方法参数列表中是否有 Invocation 类型参数</span></span><br><span class="line">                        <span class="keyword">if</span> (hasInvocation)</span><br><span class="line">                            <span class="comment">// 生成的代码功能等价于下面的代码：</span></span><br><span class="line">                            <span class="comment">//   url.getMethodParameter(methodName, value[i], defaultExtName)</span></span><br><span class="line">                            <span class="comment">// 以 LoadBalance 接口的 select 方法为例，最终生成的代码如下：</span></span><br><span class="line">                            <span class="comment">//   url.getMethodParameter(methodName, &quot;loadbalance&quot;, &quot;random&quot;)</span></span><br><span class="line">                            getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="comment">// 生成的代码功能等价于下面的代码：</span></span><br><span class="line">                            <span class="comment">//   url.getParameter(value[i], defaultExtName)</span></span><br><span class="line">                            getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 生成的代码功能等价于下面的代码：</span></span><br><span class="line">                        <span class="comment">//   ( url.getProtocol() == null ? defaultExtName : url.getProtocol() )</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;( url.getProtocol() == null ? \&quot;%s\&quot; : url.getProtocol() )&quot;</span>, defaultExtName);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 默认拓展名为空</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i]))</span><br><span class="line">                        <span class="keyword">if</span> (hasInvocation)</span><br><span class="line">                            <span class="comment">// 生成代码格式同上</span></span><br><span class="line">                            getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="comment">// 生成的代码功能等价于下面的代码：</span></span><br><span class="line">                            <span class="comment">//   url.getParameter(value[i])</span></span><br><span class="line">                            getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;)&quot;</span>, value[i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 生成从 url 中获取协议的代码，比如 &quot;dubbo&quot;</span></span><br><span class="line">                        getNameCode = <span class="string">&quot;url.getProtocol()&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i]))</span><br><span class="line">                    <span class="keyword">if</span> (hasInvocation)</span><br><span class="line">                        <span class="comment">// 生成代码格式同上</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getMethodParameter(methodName, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot;</span>, value[i], defaultExtName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 生成的代码功能等价于下面的代码：</span></span><br><span class="line">                        <span class="comment">//   url.getParameter(value[i], getNameCode)</span></span><br><span class="line">                        <span class="comment">// 以 Transporter 接口的 connect 方法为例，最终生成的代码如下：</span></span><br><span class="line">                        <span class="comment">//   url.getParameter(&quot;client&quot;, url.getParameter(&quot;transporter&quot;, &quot;netty&quot;))</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">&quot;url.getParameter(\&quot;%s\&quot;, %s)&quot;</span>, value[i], getNameCode);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 生成的代码功能等价于下面的代码：</span></span><br><span class="line">                    <span class="comment">//   url.getProtocol() == null ? getNameCode : url.getProtocol()</span></span><br><span class="line">                    <span class="comment">// 以 Protocol 接口的 connect 方法为例，最终生成的代码如下：</span></span><br><span class="line">                    <span class="comment">//   url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol()</span></span><br><span class="line">                    getNameCode = String.format(<span class="string">&quot;url.getProtocol() == null ? (%s) : url.getProtocol()&quot;</span>, getNameCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成 extName 赋值代码</span></span><br><span class="line">        code.append(<span class="string">&quot;\nString extName = &quot;</span>).append(getNameCode).append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成 extName 判空代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.format(<span class="string">&quot;\nif(extName == null) &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;throw new IllegalStateException(\&quot;Fail to get extension(%s) name from url(\&quot; + url.toString() + \&quot;) use keys(%s)\&quot;);&quot;</span>,</span><br><span class="line">                                 type.getName(), Arrays.toString(value));</span><br><span class="line">        code.append(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码已经进行了大量的注释，不过看起来任然不是很好理解。既然如此，那么建议大家写点测试代码，对 Protocol、LoadBalance 以及 Transporter 等接口的自适应拓展类代码生成过程进行调试。这里我以 Transporter 接口的自适应拓展类代码生成过程进行分析。首先看一下 Transporter 接口的定义，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;netty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="comment">// @Adaptive(&#123;server, transporter&#125;)</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span> </span><br><span class="line">    Server <span class="title function_">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Adaptive(&#123;client, transporter&#125;)</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    Client <span class="title function_">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对 connect 方法代理逻辑生成的过程进行分析，此时生成代理逻辑所用到的变量和值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">defaultExtName</span> <span class="operator">=</span> <span class="string">&quot;netty&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasInvocation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">getNameCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">String[] value = [<span class="string">&quot;client&quot;</span>, <span class="string">&quot;transporter&quot;</span>];</span><br></pre></td></tr></table></figure><p>下面对 value 数组进行遍历，此时 i &#x3D; 1, value[i] &#x3D; “transporter”，生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getNameCode = url.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来，for 循环继续执行，此时 i &#x3D; 0, value[i] &#x3D; “client”，生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getNameCode = url.getParameter(<span class="string">&quot;client&quot;</span>, url.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br></pre></td></tr></table></figure><p>for 循环结束运行，现在生成 extName 变量及判空代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;client&quot;</span>, url.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (extName == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">        <span class="string">&quot;Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(&quot;</span> + url.toString()</span><br><span class="line">        + <span class="string">&quot;) use keys([client, transporter])&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，connect 方法的拓展名获取代码就生成好了。如果大家不是很明白，建议自己调试走一遍。好了，本节先到这里。</p><h5 id="2-2-3-6-生成拓展加载与目标方法调用逻辑"><a href="#2-2-3-6-生成拓展加载与目标方法调用逻辑" class="headerlink" title="2.2.3.6 生成拓展加载与目标方法调用逻辑"></a>2.2.3.6 生成拓展加载与目标方法调用逻辑</h5><p>上一节的逻辑生成拓展名 extName 获取逻辑，接下来要做的是根据拓展名加载拓展实例，并调用拓展实例的目标方法。相关逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// $无 Adaptive 注解方法代码生成&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// $&#123;获取 URL 数据&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;获取 Adaptive 注解值&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;检测 Invocation 参数&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;生成拓展名获取逻辑&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成拓展获取代码，格式如下：</span></span><br><span class="line">        <span class="comment">// type全限定名 extension = (type全限定名)ExtensionLoader全限定名</span></span><br><span class="line">        <span class="comment">//     .getExtensionLoader(type全限定名.class).getExtension(extName);</span></span><br><span class="line">        <span class="comment">// Tips: 格式化字符串中的 %&lt;s 表示使用前一个转换符所描述的参数，即 type 全限定名</span></span><br><span class="line">        s = String.format(<span class="string">&quot;\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);&quot;</span>,</span><br><span class="line">                        type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());</span><br><span class="line">        code.append(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果方法有返回值类型非 void，则生成 return 语句。</span></span><br><span class="line">        <span class="keyword">if</span> (!rt.equals(<span class="keyword">void</span>.class)) &#123;</span><br><span class="line">            code.append(<span class="string">&quot;\nreturn &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成目标方法调用逻辑，格式为：</span></span><br><span class="line">        <span class="comment">//     extension.方法名(arg0, arg2, ..., argN);</span></span><br><span class="line">        s = String.format(<span class="string">&quot;extension.%s(&quot;</span>, method.getName());</span><br><span class="line">        code.append(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                code.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            code.append(<span class="string">&quot;arg&quot;</span>).append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        code.append(<span class="string">&quot;);&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 Protocol 接口举例说明，上面代码生成的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader</span><br><span class="line">            .getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line"><span class="keyword">return</span> extension.refer(arg0, arg1);</span><br></pre></td></tr></table></figure><h5 id="2-2-3-7-生成完整的方法"><a href="#2-2-3-7-生成完整的方法" class="headerlink" title="2.2.3.7 生成完整的方法"></a>2.2.3.7 生成完整的方法</h5><p>本节进行代码生成的收尾工作，主要用于生成方法定义的代码。相关逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// $无 Adaptive 注解方法代码生成&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// $&#123;获取 URL 数据&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;获取 Adaptive 注解值&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;检测 Invocation 参数&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;生成拓展名获取逻辑&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// $&#123;生成拓展加载与目标方法调用逻辑&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public + 返回值全限定名 + 方法名 + (</span></span><br><span class="line">codeBuilder.append(<span class="string">&quot;\npublic &quot;</span>)</span><br><span class="line">    .append(rt.getCanonicalName())</span><br><span class="line">    .append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    .append(method.getName())</span><br><span class="line">    .append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加参数列表代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        codeBuilder.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    codeBuilder.append(pts[i].getCanonicalName());</span><br><span class="line">    codeBuilder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    codeBuilder.append(<span class="string">&quot;arg&quot;</span>).append(i);</span><br><span class="line">&#125;</span><br><span class="line">codeBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加异常抛出代码</span></span><br><span class="line"><span class="keyword">if</span> (ets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    codeBuilder.append(<span class="string">&quot; throws &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ets.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            codeBuilder.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        codeBuilder.append(ets[i].getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">codeBuilder.append(<span class="string">&quot; &#123;&quot;</span>);</span><br><span class="line">codeBuilder.append(code.toString());</span><br><span class="line">codeBuilder.append(<span class="string">&quot;\n&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>以 Protocol 的 refer 方法为例，上面代码生成的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.alibaba.dubbo.rpc.Invoker <span class="title function_">refer</span><span class="params">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-基于动态代理实现知识与拓展"><a href="#3-基于动态代理实现知识与拓展" class="headerlink" title="3.基于动态代理实现知识与拓展"></a>3.基于动态代理实现知识与拓展</h2><p>我在第一章介绍自适应拓展原理时说过，Dubbo 通过生成和编译代码实现自适应拓展的方式有点复杂，不利于维护。另外，这样做对源码学习读者来说，也不是很友好。我敢肯定，有同学会像我一样，在开始调试 Dubbo 源码时，不知道如何调试各种自适应拓展类，比如 Protocol$Adaptive。如果你也有类似的困惑，这里教大家一个方法。如下：</p><ol><li>在 createAdaptiveExtensionClass 方法的第一行打个断点</li><li>启动测试代码，代码运行到端点处，单步越过断点，此时可以得到生成的代码。</li><li>拷贝出刚刚获取到的代码，到指定的包下创建同名类，并将代码拷过去，格式化一下即可</li></ol><p>从调试信息中可知，ProtocolAdaptive 所在包为 com.alibaba.dubbo.rpc。因此接下来到 com.alibaba.dubbo.rpc 包下创建 ProtocolAdaptive 类，并把 code 变量值拷贝到刚创建的文件中。</p><p>既然 Dubbo 实现的 Adaptive 机制不利于调试，那么我们可以对其进行改造。改造后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveInvokeHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String defaultExtName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdaptiveInvokeHandler</span><span class="params">(String defaultExtName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultExtName = defaultExtName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!clazz.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Only create the proxy for interface.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clazz&#125;, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Class&lt;?&gt; type = method.getDeclaringClass();</span><br><span class="line">        <span class="keyword">if</span> (type.equals(Object.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Cannot invoke the method of Object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">        <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;method &quot;</span> + method.toString() + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot; is not adaptive method!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 URL 数据</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> getUrlData(method, args);</span><br><span class="line">        <span class="comment">// 获取 Adaptive 注解值</span></span><br><span class="line">        String[] value = getAdaptiveAnnotationValue(method);</span><br><span class="line">        <span class="comment">// 获取 Invocation 参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">invocation</span> <span class="operator">=</span> getInvocationArgument(method, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取拓展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> getExtensionName(url, value, invocation);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(extName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Fail to get extension(&quot;</span> + type.getName() + <span class="string">&quot;) name from url(&quot;</span> + url.toString()</span><br><span class="line">                    + <span class="string">&quot;) use keys(&quot;</span> + Arrays.toString(value) +<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取拓展实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">extension</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(type).getExtension(extName);</span><br><span class="line">        Class&lt;?&gt; extType = extension.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">targetMethod</span> <span class="operator">=</span> extType.getMethod(method.getName(), method.getParameterTypes());</span><br><span class="line">        <span class="comment">// 通过反射调用目标方法</span></span><br><span class="line">        <span class="keyword">return</span> targetMethod.invoke(extension, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来是不是简单了一些，不过这并不是全部的代码。我将 URL 数据以及 Adaptive 注解值的获取逻辑封装在了私有方法中，相应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> URL <span class="title function_">getUrlData</span><span class="params">(Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pts[i].equals(URL.class)) &#123;</span><br><span class="line">            url = (URL) args[i];</span><br><span class="line">            <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">urlTypeIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        LBL_PTS:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">            Method[] ms = pts[i].getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line">                <span class="keyword">if</span> ((name.startsWith(<span class="string">&quot;get&quot;</span>) || name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(m.getModifiers())</span><br><span class="line">                    &amp;&amp; !Modifier.isStatic(m.getModifiers())</span><br><span class="line">                    &amp;&amp; m.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                    &amp;&amp; m.getReturnType() == URL.class) &#123;</span><br><span class="line"></span><br><span class="line">                    urlTypeIndex = i;</span><br><span class="line">                    getter = m;</span><br><span class="line">                    <span class="keyword">break</span> LBL_PTS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urlTypeIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot find URL argument.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args[urlTypeIndex] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(pts[urlTypeIndex].getName() + <span class="string">&quot; argument == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        url = (URL) getter.invoke(args[urlTypeIndex]);</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(pts[urlTypeIndex].getName() + <span class="string">&quot; argument &quot;</span> + getter.getName() + <span class="string">&quot;() == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String[] getAdaptiveAnnotationValue(Method method) &#123;</span><br><span class="line">    <span class="type">Adaptive</span> <span class="variable">adaptiveAnnotation</span> <span class="operator">=</span> method.getAnnotation(Adaptive.class);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> method.getDeclaringClass();</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;method &quot;</span> + method.toString() + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot; is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] value = adaptiveAnnotation.value();</span><br><span class="line">    <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>[] charArray = type.getSimpleName().toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(charArray[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(Character.toLowerCase(charArray[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(charArray[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;sb.toString()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">getInvocationArgument</span><span class="params">(Method method, Object[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pts[i].getName().equals(<span class="string">&quot;com.alibaba.dubbo.rpc.Invocation&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">invocation</span> <span class="operator">=</span> args[i];</span><br><span class="line">            <span class="keyword">if</span> (invocation == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invocation == null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invocation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getExtensionName</span><span class="params">(URL url, String[] value, Invocation invocation)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasInvocation</span> <span class="operator">=</span> invocation != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = invocation.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getMethodName&quot;</span>);</span><br><span class="line">        methodName = (String) method.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;protocol&quot;</span>.equals(value[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasInvocation) &#123;</span><br><span class="line">                extName = url.getMethodParameter(methodName, value[i], defaultExtName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extName = url.getParameter(value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            extName = url.getProtocol();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(extName)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == value.length -<span class="number">1</span> &amp;&amp; StringUtils.isEmpty(extName)) &#123;</span><br><span class="line">            extName = defaultExtName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将 AdaptiveInvokeHandler 放置到 ExtensionLoader 所在包下，并对 ExtensionLoader 的 createAdaptiveExtension 方法代码进行改造。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="type">T</span> <span class="variable">extension</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            extension = (T) cachedAdaptiveClass.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extension == <span class="literal">null</span>) &#123;</span><br><span class="line">            extension = (T) <span class="keyword">new</span> <span class="title class_">AdaptiveInvokeHandler</span>(cachedDefaultName).getProxy(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> injectExtension(extension);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can not create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是改造后的代码，需要特别说明的是，上面的代码仅供演示使用，代码逻辑并不是十分严谨。如果你有更好的写法，欢迎分享。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>到此，关于自适应拓展的原理，实现以及改造过程就分析完了。总的来说自适应拓展整个逻辑还是很复杂的，并不是很容易弄懂。因此，大家在阅读该部分源码时，耐心一些，同时多进行调试。亦或是通过生成好的代码思考生成逻辑。当然，大家也可以将代码生成逻辑看成一个黑盒，不懂细节也没关系，只要知道自适应拓展原理即可。</p><p>好了，本篇文章先到这里，感谢大家的阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、Dubbo-源码分析-–-自适应拓展原理&quot;&gt;&lt;a href=&quot;#二、Dubbo-源码分析-–-自适应拓展原理&quot; class=&quot;headerlink&quot; title=&quot;二、Dubbo 源码分析 – 自适应拓展原理&quot;&gt;&lt;/a&gt;二、Dubbo 源码分析 – 自适应拓展</summary>
      
    
    
    
    
  </entry>
  
</feed>
