<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十九、Java并发 Java wait() 和 notify() 方法</title>
      <link href="/posts/2b1d309b.html"/>
      <url>/posts/2b1d309b.html</url>
      
        <content type="html"><![CDATA[<h1 id="十九、Java并发-Java-wait-和-notify-方法"><a href="#十九、Java并发-Java-wait-和-notify-方法" class="headerlink" title="十九、Java并发 Java wait() 和 notify() 方法"></a>十九、Java并发 Java wait() 和 notify() 方法</h1><p>大家有没有发现，其实 「 一文秒懂 」 系列讲述的都是多线程并发开发的问题。这个话题太大了，估计没有上百篇文章都解释不清楚。</p><p>本文，我们来讲解下 Java 并发中的基础的基础，核心的核心，Java 并发编程中的最基本的机制之一 – 「 线程同步 」</p><p>为了方便你理解并发编程中的各种概念和术语，我们首先会来一阵扫盲，讨论一些基本的并发相关术语和方法。接着，我们将开发一个简单的应用程序，并在合格应用程序里处理并发问题，以方便大家理解和巩固 <code>wait()</code> 和 <code>notify()</code>。</p><h2 id="Java-中的线程同步-Thread-Synchronization"><a href="#Java-中的线程同步-Thread-Synchronization" class="headerlink" title="Java 中的线程同步 ( Thread Synchronization )"></a>Java 中的线程同步 ( Thread Synchronization )</h2><p>在并发编程中，在多线程环境下，多个线程可能会尝试修改同一资源。如果线程管理不当，这显然会导致一致性问题。</p><h3 id="Java-中的哨兵块-guarded-block"><a href="#Java-中的哨兵块-guarded-block" class="headerlink" title="Java 中的哨兵块 ( guarded block )"></a>Java 中的哨兵块 ( guarded block )</h3><p>Java 中，可以用来协调多个线程操作的一个工具是 「 哨兵块 」。这个哨兵块会在恢复执行前检查特定条件。</p><p>基于这种哨兵检查的思想，Java 在所有类的基类 <code>Object</code> 中提供了两个方法</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>Object.wait()</code></td><td align="center">暂停一个线程</td></tr><tr><td align="center"><code>Object.notify()</code></td><td align="center">唤醒一个线程</td></tr></tbody></table><p>是不是有点难以理解，别担心，看下面这个图，这个图描绘了线程的的生命周期。</p><p><img src="https://s3.uuu.ovh/imgs/2022/05/04/52f9c7edb1f91071.png" alt="img_1.png"></p><p>虽然从上图中可以看出，有多个方法可以控制一个线程的生命周期，但本章节，我们只讨论 <code>notify()</code> 方法和 <code>wait()</code> 方法</p><h2 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait() 方法"></a>wait() 方法</h2><p>对照上图，简单的说，当我们调用 <code>wait()</code> 时会强制当前线程等待，直到某个其它线程在同一个对象上调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法。</p><p>因此，当前线程必须拥有对象的监视器。根据 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--">Java docs</a> 的说法，这可能发生在</p><ul><li>我们已经为给定对象执行了同步实例方法</li><li>我们已经在给定对象上执行了 synchronized 块的主体</li><li>通过为 Class 类型的对象执行同步静态方法</li></ul><blockquote><p>请注意，一次只有一个活动线程可以拥有对象的监视器。</p></blockquote><p>除了无参数 wait() 方法外，Java 还重载了另一个 wait() 方法</p><h3 id="wait-方法-1"><a href="#wait-方法-1" class="headerlink" title="wait() 方法"></a>wait() 方法</h3><p><code>wait()</code> 方法导致当前线程无限期地等待，直到另一个线程调用此对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法</p><h3 id="wait-long-timeout-方法"><a href="#wait-long-timeout-方法" class="headerlink" title="wait(long timeout) 方法"></a>wait(long timeout) 方法</h3><p>使用此方法，我们可以指定一个超时，在此之后将自动唤醒线程。</p><p>当然了，我们可以在到达超时之前使用 <code>notify()</code> 或 <code>notifyAll()</code> 提前唤醒线程。</p><p>请注意，调用 <code>wait(0)</code> 与调用 <code>wait()</code> 相同</p><h3 id="wait-long-timeout-int-nanos"><a href="#wait-long-timeout-int-nanos" class="headerlink" title="wait(long timeout, int nanos)"></a>wait(long timeout, int nanos)</h3><p>这是与 <code>wait(long timeout)</code> 提供相同功能的签名，唯一的区别是我们可以提供更高的精度。</p><p>该方法计算超时之间的方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总超时时间（以纳秒为单位）= 1_000_000 * 超时 + nanos</span><br></pre></td></tr></table></figure><h2 id="notify-或-notifyAll-方法"><a href="#notify-或-notifyAll-方法" class="headerlink" title="notify() 或 notifyAll() 方法"></a><code>notify()</code> 或 <code>notifyAll()</code> 方法</h2><p><code>notify()</code> 和 <code>notifyAll()</code> 方法用于唤醒等待访问此对象监视器的线程。</p><p>它们以不同的方式通知等待线程。</p><h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify() 方法"></a>notify() 方法</h3><p>对于在此对象的监视器上等待的所有线程（通过使用任何一个重载 <code>wait()</code> 方法 ），<code>notify()</code> 通知将会随机唤醒任何一个线程。</p><p>也就是说，我们并不能确切知道唤醒了哪个线程，这取决于实现。</p><p>因为 <code>notify()</code> 提供了唤醒一个随机线程的机制，因此它可用于实现线程执行类似任务的互斥锁定。</p><p>但在大多数情况下，使用 <code>notifyAll()</code> 会是一个更可行的方案。</p><h2 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll() 方法"></a>notifyAll() 方法</h2><p><code>notifyAll()</code> 方法用于唤醒正在此对象的监视器上等待的所有线程。唤醒的线程将以常规的方式完成 – 就像任何其他线程一样。</p><p>但，有一点要注意的是，对于任意一个线程，但在我们允许其继续执行之前，请始终快速检查继续执行该线程所需的条件。因为在某些情况下线程被唤醒而没有收到通知（这个场景将在后面的例子中讨论 ）</p><h2 id="发送者-–-接收者同步问题"><a href="#发送者-–-接收者同步问题" class="headerlink" title="发送者 – 接收者同步问题"></a>发送者 – 接收者同步问题</h2><p>线程同步的问题，我们已经有了个大概的了解，接下来，我们看一个简单的 Sender-Receiver ( 发送者 – 接收者 ) 应用程序，这个应用程序将利用<code>wait()</code> 和 <code>notify()</code> 方法建立它们之间的同步。</p><ul><li>发送者应该向接收者发送数据包</li><li>在发送方完成发送之前，接收方无法处理数据包</li><li>同样，发送方不得尝试发送另一个数据包，除非接收方已处理过上一个数据包</li></ul><p>我们首先创建一个 Data 类，用于包含将从 Sender 发送到 Receiver 的数据包，同时，我们将使用 <code>wait()</code> 和 <code>notifyAll()</code> 来设置它们之间的同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True if receiver should wait</span></span><br><span class="line">    <span class="comment">// False if sender should wait</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">transfer</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String packet)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!transfer) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        transfer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.packet = packet;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (transfer) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        transfer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> packet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例有点小长，我们一步一步分析下代码</p><p>1、 私有属性 <code>packet</code> 用于表示通过网络传输的数据<br>2、 布尔类型的私有属性 <code>transfer</code> 用于 Sender 和 Receiver 之间的同步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  如果此变量为 true，则 Receiver 应等待 Sender 发送消息</span><br><span class="line">*  如果它是 `false` ，那么 Sender 应该等待 Receiver 接收消息</span><br></pre></td></tr></table></figure><p>3、 Sender 使用 <code>send()</code> 方法将数据发送给 Receiver：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  如果 `transfer` 为 `false` ，我们将在此线程上调用 `wait()`</span><br><span class="line">*  但如果它为 `true` ，我们需要切换状态，设置我们的消息并调用 `notifyAll()` 来唤醒其他线程以指定发生了重大事件，然后这些线程它们自己可以自查是否可以继续执行。</span><br></pre></td></tr></table></figure><p>4、 同样的， Receiver 将使用 <code>receive()</code> 方法接收数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  如果 Sender 将传输设置为 `false`，那么继续，否则将在此线程上调用 `wait()`</span><br><span class="line">*  满足条件时，我们切换状态，通知所有等待的线程唤醒并返回 Receiver 的数据包</span><br></pre></td></tr></table></figure><h3 id="为什么在-while-循环中包含-wait"><a href="#为什么在-while-循环中包含-wait" class="headerlink" title="为什么在 while 循环中包含 wait()"></a>为什么在 <code>while</code> 循环中包含 <code>wait()</code></h3><p>由于 <code>notify()</code> 和 <code>notifyAll()</code> 随机唤醒正在此对象监视器上等待的线程，因此满足条件并不总是很重要。有时可能会发生线程被唤醒，但实际上并没有满足条件。</p><p>当然了，跟进一步说，我们还可以定义一个检查来避免虚假唤醒 – 线程可以从等待中醒来而不会收到通知。</p><h3 id="我们为什么需要同步-send-和-receive-方法"><a href="#我们为什么需要同步-send-和-receive-方法" class="headerlink" title="我们为什么需要同步 send() 和 receive() 方法"></a>我们为什么需要同步 <code>send()</code> 和 <code>receive()</code> 方法</h3><p>我们将这些方法放在 <code>synchronized</code> 方法是为了提供内部锁。</p><p>如果调用 <code>wait()</code> 方法的线程不拥有固有锁，则会抛出错误。</p><p>现在，是时候创建 Sender 和 Receiver 并在两者上实现 Runnable 接口，以便它们的实例可以由线程执行。</p><p>我们先来看看 Sender 将如何工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Data data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        String packets[] = &#123;</span><br><span class="line">          <span class="string">&quot;First packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Second packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Third packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Fourth packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;End&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packet : packets) &#123;</span><br><span class="line">            data.send(packet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Thread.sleep() to mimic heavy server-side processing</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(ThreadLocalRandom.current().nextInt(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个 Sender ：</p><ul><li>我们正在创建一些随机数据包，这些数据包将通过网络以 <code>packet[]</code> 数组的形式发送</li><li>对于每个数据包，我们只是调用 <code>send()</code> 而不做其它动作</li><li>然后我们用随机时间间隔调用 <code>Thread.sleep()</code> 来模仿繁重的服务器端处理</li></ul><p>接下来，我们来看看如何实现 Receiver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Data load;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> load.receive();</span><br><span class="line">          !<span class="string">&quot;End&quot;</span>.equals(receivedMessage);</span><br><span class="line">          receivedMessage = load.receive()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(receivedMessage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(ThreadLocalRandom.current().nextInt(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码很简单，只是在循环中调用 <code>load.receive()</code> ，直到我们得到最后一个 “End” 数据包。</p><p>最后，我们就可以写一个 <code>main()</code> 方法来运行它们了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Sender</span>(data));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Receiver</span>(data));</span><br><span class="line"></span><br><span class="line">    sender.start();</span><br><span class="line">    receiver.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First packet</span><br><span class="line">Second packet</span><br><span class="line">Third packet</span><br><span class="line">Fourth packet</span><br></pre></td></tr></table></figure><p>完美！</p><p>我们在这里 – 我们以正确的顺序接收所有数据包，并成功建立了发送方和接收方之间的正确通信。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十八、Java并发 Java 之 Runnable 还是 Thread ?</title>
      <link href="/posts/c969ad4b.html"/>
      <url>/posts/c969ad4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="十八、Java并发-Java-之-Runnable-还是-Thread"><a href="#十八、Java并发-Java-之-Runnable-还是-Thread" class="headerlink" title="十八、Java并发 Java 之 Runnable 还是 Thread ?"></a>十八、Java并发 Java 之 Runnable 还是 Thread ?</h1><p>写 Java 代码的时候，我们经常会有这样的疑问：我到底是实现一个 Runnable 呢，还是扩展一个 Thread 类？</p><p>你的答案是什么呢？ 那有没有标准答案呢？</p><p>答案是什么呢？</p><p>我们先来分析下，看看哪种方法在实践中更有意义以及为什么？</p><h2 id="扩展一个线程-（-Thread-类"><a href="#扩展一个线程-（-Thread-类" class="headerlink" title="扩展一个线程 （ Thread 类 )"></a>扩展一个线程 （ Thread 类 )</h2><p>简单起见，我们就来定义一个扩展自 <code>Thread</code> 的 <code>SimpleThread</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard logger, constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也真是简单了，然后我们看看如何运行这个 SimpleThread 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenAThread_whenRunIt_thenResult</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThread</span>(</span><br><span class="line">      <span class="string">&quot;SimpleThread executed using Thread&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以把这个 SimpleThread 放到前面章节 一文秒懂 Java ExecutorService中提到的 ExecutorService 中运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenAThread_whenSubmitToES_thenResult</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> <span class="title class_">SimpleThread</span>(</span><br><span class="line">      <span class="string">&quot;SimpleThread executed using ExecutorService&quot;</span>)).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来感觉是不是有点复杂，我们只想在单独的线程中运行单个日志操作而已，使用 Thread 的方式看起来有点复杂化了，要么是 start() 和 join() ，要么是 ExecutorService。</p><p>当然，这不是最糟糕的，更糟糕的是，SimpleThread 再也不能扩展任何其它类，因为 Java 不支持多重继承。</p><h2 id="实现-implements-一个-Runnable"><a href="#实现-implements-一个-Runnable" class="headerlink" title="实现 ( implements) 一个 Runnable"></a>实现 ( implements) 一个 Runnable</h2><p>同样的简单起见，我们创建一个实现了 <code>java.lang.Runnable</code> 接口的简单任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard logger, constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是不是和上面的 SimpleThread 很相似？</p><p>因为这个 SimpleRunnable 只是一个任务，一个在一个单独的线程中运行的任务。</p><p>为了运行这个任务，有多种方式可供选择，其中之一，就是使用一个 Thread 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenRunnable_whenRunIt_thenResult</span><span class="params">()</span></span><br><span class="line"> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SimpleRunnable</span>(</span><br><span class="line">      <span class="string">&quot;SimpleRunnable executed using Thread&quot;</span>));</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，还可以使用 ExecutorService:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenARunnable_whenSubmitToES_thenResult</span><span class="params">()</span></span><br><span class="line"> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> <span class="title class_">SimpleRunnable</span>(</span><br><span class="line">      <span class="string">&quot;SimpleRunnable executed using ExecutorService&quot;</span>)).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，你是不是很疑惑？Runnable 和继承一个 Thread 没有什么区别啊 ？同样多的代码，同样多的步骤。</p><p>别急，哈哈，重点来了。</p><p>由于我们的 SimpleRunnable 实现了一个接口，因此，如果需要，我们可以自由扩展自另一个基类。</p><p>更简单的是，一个几行代码的 Runnable 还可以写成一个简单的 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenARunnableLambda_whenSubmitToES_thenResult</span><span class="params">()</span> </span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    executorService.submit(</span><br><span class="line">      () -&gt; log.info(<span class="string">&quot;Lambda runnable executed!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这才是 Runnable 的杀手锏。真的是简单的不要太多。</p><h2 id="Runnable-or-Thread"><a href="#Runnable-or-Thread" class="headerlink" title="Runnable or Thread?"></a>Runnable or Thread?</h2><p>看到这里，你想要的是 Runnable 还是 Thread ?</p><p>看我上文的描述，肯定是倾向使用 Runnable 多过 Thread：</p><ul><li>在扩展 Thread 类时，我们并没有被要求覆盖它的任何方法。相反，我们需要覆盖 Runnable 的 <code>run()</code> 方法（ Thread 类已经实现了 ）。这显然违反了 IS-A Thread 原则。</li><li>我们可以创建一个 Runnable 的实现并将其传递给 Thread 类。这利用的是组合而不是继承。这更灵活。</li><li>在扩展了 Thread 类之后，我们无法扩展任何其他类。</li><li>从 Java 8 开始，Runnables 可以重写为 lambda 表达式。</li></ul><p>所以，有了这些之后，你是怎么想的？快告诉我们吧？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十七、Java并发 Java Thread 生命周期</title>
      <link href="/posts/9c8c1a2d.html"/>
      <url>/posts/9c8c1a2d.html</url>
      
        <content type="html"><![CDATA[<h1 id="十七、Java并发-Java-Thread-生命周期"><a href="#十七、Java并发-Java-Thread-生命周期" class="headerlink" title="十七、Java并发 Java Thread 生命周期"></a>十七、Java并发 Java Thread 生命周期</h1><p>本文中，我想详细的讨论下 Java 中的核心概念 – 线程的生命周期。我会使用一张我自制的图片加上实用的代码片段，一步一步的详细剖析线程的各个状态和各个状态之间如何转换。</p><h2 id="Java-中的多线程"><a href="#Java-中的多线程" class="headerlink" title="Java 中的多线程"></a>Java 中的多线程</h2><p>Java 语言中， 多线程是由 Thread 的核心概念驱动的。因为多线程中的每一个线程都相互独立，有着自己的生命周期和状态转换。</p><p>我们先来看一张草图，这图描述了 Java 线程的各种状态和转换过程。</p><p><img src="https://s3.uuu.ovh/imgs/2022/05/04/b5b70b4c71c1fcaa.png" alt="img_1.png"></p><p>是不是很杂乱无章？ 看不懂没关系，我们接下来会详细介绍各个状态。</p><h2 id="Java-线程中的生命周期"><a href="#Java-线程中的生命周期" class="headerlink" title="Java 线程中的生命周期"></a>Java 线程中的生命周期</h2><p>Java 中，每一个线程都是 <code>java.lang.Thread</code> 类的实例。而且，Java 个线程生命周期中的各个状态都定义在 <code>Thread</code> 类的一个静态的 <code>State</code> 枚举中。</p><p><code>State</code> 枚举定义了线程的所有潜在状态。总共有 6 个，分别对应者上图中的 6 个绿色背景的矩形和椭圆型。</p><ul><li><code>NEW</code> : 新创建的，且未调用 <code>start()</code> 方法开始执行的线程。</li><li><code>RUNNABLE</code> : 已经在运行中的线程或正在等待资源分配的准备运行的线程。</li><li><code>BLOCKED</code> : 等待获取进入或重新进入同步块或方法的监视器锁的线程。</li><li><code>WAITING</code> : 等待其他一些线程执行特定操作，没有任何时间限制。</li><li><code>TIMED_WAITING</code>: 等待某个其他线程在指定时间段内执行特定操作</li><li><code>TERMINATED</code> : 线程完成了它的任务。</li></ul><p>需要注意的是： <strong>在任何给定的时间点，线程只能处于这些状态之一</strong>。</p><ul><li><code>NEW</code> 状态，应该很好理解，比如，车，厂家生产出来，只要还没被卖出过，那么它就是新的 ( NEW )</li><li><code>RUNNABLE</code> 只要线程不出于其它状态，它就是 RUNNABLE 状态。怎么理解呢？ 车买来了，只要它没坏没出什么毛病没借给别人，那么它就出于可开状态，不管是呆在家里吃灰还是已经在上路运行。</li><li><code>WAITING</code> : 无时间显示的等待其它线程完成任务时就处于这个状态，怎么理解呢？比如长假告诉公路大堵车，要等待别人前进了几个蜗牛步我们才能往前几个蜗牛步，有时候一等就是昏天暗地，可能长达几天，也可能，一辈子吧。</li><li><code>TIMED_WAITING</code> : 一直处于 <code>WAITING</code> 总不是办法，所以可能会设置一个超时时间，如果过了时间，就不等待了。同样的，如果可以后退，那么我们在堵车的时候可能会等待那么十几分钟，发现确实走不了，就等了呗。</li><li><code>TERMINATED</code> : 当一个线程结束了它的任务（可能完成了，也可能没完成）就会处于这个状态。如果拿车做比喻，那么当车彻底报废，已经再也不能上路了，就处于这个状态。</li></ul><blockquote><p>其实拿车作比喻感觉有点怪，我觉得拿追女朋友来做比喻比较恰当些。</p></blockquote><h2 id="NEW-状态"><a href="#NEW-状态" class="headerlink" title="NEW 状态"></a>NEW 状态</h2><p><strong>NEW</strong>状态的线程（或已经创建的新线程）是已创建但尚未启动的线程。线程会一直保持这个 <code>NEW</code> 状态，直到在该线程上调用了 <code>start()</code> 方法启动它。</p><p>下面的代码，我们创建了一个 <code>NEW</code> 状态的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewState</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">Log.info(t.getState());</span><br></pre></td></tr></table></figure><p>由于我们没有启动线程，因此 <code>t.getState()</code> 方法将打印输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW</span><br></pre></td></tr></table></figure><h2 id="RUNNABLE-状态"><a href="#RUNNABLE-状态" class="headerlink" title="RUNNABLE 状态"></a>RUNNABLE 状态</h2><p>当在一个 <code>NEW</code> 状态的线程上调用 <code>start()</code> 方法时，该线程的状态会从 <code>NEW</code> 转换为 <code>RUNNABLE</code>。处于该状态的线程要么是已经在运行中，那么是在处于正在等待系统的资源分配（准备运行）。</p><p>在多线程环境中，线程调度器 （ Thread-Scheduler，它是 JVM 的一部分）会为每个线程分配固定的时间。线程并不是一直都在执行的，调度器会把暂时空闲的线程的 CPU （ 还是在 RUNNABLE 状态 ）让出来，让其它需要的线程去运行。因此它会运行一段特定的时间，然后将控制权放弃给其他 RUNNABLE 线程。</p><blockquote><p>注意： 这里的等待资源，不是等待其它线程，而是等待 CPU 排队。打个比方，新车上路。要等待的是有没有路，如果没有路，就开不了，这是本质的问题。</p></blockquote><p>例如，让我们将 <code>t.start()</code> 方法添加到我们之前的代码中并尝试访问其当前状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewState</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">t.start();</span><br><span class="line">Log.info(t.getState());</span><br></pre></td></tr></table></figure><p>此代码最有可能返回输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>为什么说是最有可能呢？如果是一个空转线程，除了 CPU 不需要其它资源，那么很大概率就是 <code>RUNNABLE</code> ，但如果需要其它资源，可能会因为竞争资源而处于其它状态。还有一种情况，可能还没运行到 <code>t.getState()</code> ，线程任务就执行完毕了，那么也不会是 <code>RUNNABLE</code> 状态。</p><h2 id="BLOCKED-状态"><a href="#BLOCKED-状态" class="headerlink" title="BLOCKED 状态"></a>BLOCKED 状态</h2><p>当一个线程当前没有资格运行时，它处于 <code>BLOCKED</code> 状态。如果线程在尝试访问由某个其他线程锁定的代码段时，那它会因为需要等待获取监视器锁进入此状态。</p><p>我们使用一小段代码来重现下这个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoThreadB</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoThreadB</span>());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.info(t2.getState());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThreadB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        commonResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">commonResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Infinite loop to mimic heavy processing</span></span><br><span class="line">            <span class="comment">// &#x27;t1&#x27; won&#x27;t leave this method</span></span><br><span class="line">            <span class="comment">// when &#x27;t2&#x27; try to enters this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中</p><ul><li>我们创建了两个不同的线程– <code>t1</code> 和 <code>t2</code> 。</li><li><code>t1</code> 启动后就进入了同步的 <code>commonResource()</code>方法，同步方法意味着一次只能有一个线程可以访问它。尝试访问此方法的所有其他后续线程将被阻止进一步执行，直到当前线程完成处理。</li><li>当 t1 进入这个方法时，它保持了无限循环，这只是为了模仿繁重的处理，以便所有其他线程都无法进入此方法。</li><li>接着我们开启 <code>t2</code> ，它尝试输入已经被 <code>t1</code> 访问的 <code>commonResource()</code> 方法，这时，因为 <code>commonResource()</code> 被 t1 锁定，所以 t2 将保持在 <code>BLOCKED</code> 状态</li></ul><p>在这个状态上，当我们使用 <code>t.getState()</code> 时将输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLOCKED</span><br></pre></td></tr></table></figure><h2 id="WAITTING-状态"><a href="#WAITTING-状态" class="headerlink" title="WAITTING 状态"></a>WAITTING 状态</h2><p>线程在等待某个其他线程执行特定操作时处于 <code>WAITING</code> 状态。根据 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html#WAITING">Oracle 官方文档</a>，任何线程都可以通过调用以下三种方法中的任何一种来进入此状态：</p><p>1、<code>object.wait()</code></p><p>2、<code>thread.join()</code></p><p>3、<code>LockSupport.park()</code></p><p>请注意，我们没有为 <code>wait()</code> 和 <code>join()</code> 定义任何超时时间，因为下一节将介绍该方案。</p><p>我们以后会写一个单独的教程，详细讨论了 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 的使用。</p><p>下面，我们写一段代码尝试重现这种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingState</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitingState</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoThreadWS</span>());</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThreadWS</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.info(WaitingState.t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来讨论一下上面的代码做的事情</p><p>1、首先，我们创建并启动了 <code>t1</code></p><p>2、其次，<code>t1</code> 创建了 <code>t2</code> 并启动它</p><p>3、当 <code>t2</code> 的处理继续时，我们调用 <code>t2.join()</code>，这使 <code>t1</code> 处于 <code>WAITING</code> 状态，直到 <code>t2</code> 完成执行</p><p>4、由于 t1 正在等待 t2 完成，我们从 t2 调用 <code>t1.getState()</code></p><p>输出结果一般为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WAITING</span><br></pre></td></tr></table></figure><p>请留意在哪里调用 <code>t1.getState()</code> 。</p><p>所以，<code>WAITING</code> 和 <code>BLOCKED</code> 两个状态的区别是什么？</p><ul><li><code>BLOCKED</code> 是因为线程竞争不到资源而处于 BLOCKED 状态。这个是被动的。因为别无选择。</li><li><code>WAITING</code> 是因为线程主动等待别人完成而处于 WAITING 状态。这个是主动的。因为它可以不调用那三个方法，不用等待其它人完成。它可以选择挥一挥衣袖，不不带走一片云彩</li></ul><h2 id="TIMED-WAITING-状态"><a href="#TIMED-WAITING-状态" class="headerlink" title="TIMED_WAITING 状态"></a>TIMED_WAITING 状态</h2><p>线程在等待另一个线程在规定的时间内执行特定操作时处于 <code>TIMED_WAITING</code> 状态。根据 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html#TIMED_WAITING">Java Docs 文档</a>，有五种方法可以将线程置于TIMED_WAITING 状态：</p><ul><li><code>thread.sleep(long millis)</code></li><li>``wait(int timeout) or wait(int timeout, int nanos)`</li><li>thread.join(long millis)</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil`</li></ul><p>下面，我们写一段代码尝试重现这种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimedWaitingState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj1);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The following sleep will give enough time for ThreadScheduler</span></span><br><span class="line">        <span class="comment">// to start processing of thread t1</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Log.info(t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码和 <code>WAITING</code> 状态的差不多，我们创建并启动了一个线程 <code>t1</code>，并它进入睡眠状态，超时时间为 <code>5</code> 秒。</p><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure><h2 id="TERMINATED-状态"><a href="#TERMINATED-状态" class="headerlink" title="TERMINATED 状态"></a>TERMINATED 状态</h2><p>这是一个 「 已死 」 线程的状态。当一个线程已经完成执行或异常终止时，它处于 <code>TERMINATED</code> 状态。我们写一段代码尝试重现这种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminatedState</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TerminatedState</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// The following sleep method will give enough time for </span></span><br><span class="line">        <span class="comment">// thread t1 to complete</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Log.info(t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// No processing in this block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们启动线程 <code>t1</code> 时，下一个语句 <code>Thread.sleep(1000)</code> 为 t1 提供了足够的时间来完成。</p><p>因此，上面这个示例输出结果为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在本教程中，我们了解了 Java 中线程的生命周期。我们详细介绍了 <code>Thread.State</code> 枚举定义的所有七个状态，并使用一些示例来演示他们。</p><p>虽然代码片段几乎可以在每台机器上提供相同的输出，但在某些特殊情况下，我们可能会得到一些不同的输出，因为线程调度程序的确切行为无法确定。</p><p>所以，有任何问题，欢迎回帖咨询</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六、Java并发 Java ThreadLocalRandom</title>
      <link href="/posts/9c264667.html"/>
      <url>/posts/9c264667.html</url>
      
        <content type="html"><![CDATA[<h1 id="十六、Java并发-Java-ThreadLocalRandom"><a href="#十六、Java并发-Java-ThreadLocalRandom" class="headerlink" title="十六、Java并发 Java ThreadLocalRandom"></a>十六、Java并发 Java ThreadLocalRandom</h1><p>随机数生成是一个非常常见的操作，而且 Java 也提供了 <code>java.util.Random</code> 类用于生成随机数，而且呢，这个类也是线程安全的，就是有一点不好，在多线程下，它的性能不佳。</p><p>为什么多线程下，Random 的性能不佳？</p><p>因为，它采用了多个线程共享一个 Random 实例。这样就会导致多个线程争用。</p><p>为了解决这个问题，Java 7 引入了 <code>java.util.concurrent.ThreadLocalRandom</code> 类，用于在多线程环境中生成随机数。</p><p>本文接下来的部分，就来看看如何 ThreadLocalRandom 如何执行以及如何在实际应用程序中使用它。</p><h2 id="ThreadLocalRandom-Via-Random"><a href="#ThreadLocalRandom-Via-Random" class="headerlink" title="ThreadLocalRandom Via Random"></a>ThreadLocalRandom Via Random</h2><p>ThreadLocalRandom 是 ThreadLocal 类和 Random 类的组合，它与当前线程隔离，通过简单地避免对 Random 对象的任何并发访问，在多线程环境中实现了更好的性能。</p><p>也就是说，相比于 <code>java.util.Random</code> 类全局的提供随机数生成， 使用 ThreadLocalRandom，一个线程获得的随机数不受另一个线程的影响。</p><p>另一个与 Random 类不同的是，ThreadLocalRandom 不支持显式设置种子。因为它重写了从 Random 继承的 <code>setSeed(long seed)</code> 方法，会在调用时始终抛出 <code>UnsupportedOperationException</code>。</p><p>接下来我们看看如何使用 ThreadLocalRandom 生成随机 <code>int</code>、<code>long</code> 和 <code>double</code> 值。</p><h2 id="使用-ThreadLocalRandom-生成随机数"><a href="#使用-ThreadLocalRandom-生成随机数" class="headerlink" title="使用 ThreadLocalRandom 生成随机数"></a>使用 ThreadLocalRandom 生成随机数</h2><p>根据 Oracle 文档，我们只需要调用 <code>ThreadLocalRandom.current()</code> 方法，就能返回当前线程的 <code>ThreadLocalRandom</code> 实例。然后，我们可以通过实例的相关方法来生成随机值。</p><p>比如下面的代码，生成一个没有任何边界的随机 int 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">unboundedRandomValue</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt());</span><br></pre></td></tr></table></figure><blockquote><p>其实是有边界的，它的边界就是 int 的边界。</p></blockquote><p>接下来，我们看看如何生成有边界的随机 int 值，这意味着我们需要传递边界下限和边界上限作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">boundedRandomValue</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>请注意，这是一个左闭右开区间，也就是说，上面的实例生成的随机数在 <code>[0,100)</code> 之间，包含了 0 但不包含 100。</p><p>同样的，我们可以通过调用 <code>nextLong()</code> 和 <code>nextDouble()</code> 方法生成 long 和 double 类型的随机值，调用方式与上面示例中 <code>nextInt()</code> 类似。</p><p>Java 8 还添加了 <code>nextGaussian()</code> 方法从生成器序列中生成下一个正态分布的值，其值范围在 <code>0.0</code> 和 <code>1.0</code> 之间。</p><p>与 Random 方法类似，ThreadLocalRandom 也提供了 <code>doubles()</code> 、<code>ints()</code> 和 <code>longs()</code> 方法生成一序列流式 ( stream ) 的随机值。</p><h2 id="使用-JMH-比较-ThreadLocalRandom-和-Random"><a href="#使用-JMH-比较-ThreadLocalRandom-和-Random" class="headerlink" title="使用 JMH 比较 ThreadLocalRandom 和 Random"></a>使用 JMH 比较 ThreadLocalRandom 和 Random</h2><p>记下来，我们看看如何在多线程环境中分别使用这两个类生成随机值，然后再使用 JMH 比较它们的性能。</p><p>首先，我们创建一个示例，其中所有线程共享一个 Random 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">List&lt;Callable&lt;Integer&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    callables.add(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> random.nextInt();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.invokeAll(callables);</span><br></pre></td></tr></table></figure><p>上面的代码中，我们把使用 Random 实例生成随机值的任务提交给 ExecutorService 。</p><p>然后，我们使用 JMH 基准测试来检查上面代码的性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:00:36</span><br><span class="line">Benchmark                                            Mode Cnt Score    Error    Units</span><br><span class="line">ThreadLocalRandomBenchMarker.randomValuesUsingRandom avgt 20  771.613 ± 222.220 us/op</span><br></pre></td></tr></table></figure><p>接着，类似地，我们使用 <code>ThreadLocalRandom</code> 而不是 <code>Random</code> 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">List&lt;Callable&lt;Integer&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    callables.add(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextInt();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.invokeAll(callables);</span><br></pre></td></tr></table></figure><p>上面的代码，为线程池中的每个线程单独使用了一个 ThreadLocalRandom 实例。</p><p>下面是使用 JMH 对 ThreadLocalRandom 的测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:00:36</span><br><span class="line">Benchmark                                                       Mode Cnt Score    Error   Units</span><br><span class="line">ThreadLocalRandomBenchMarker.randomValuesUsingThreadLocalRandom avgt 20  624.911 ± 113.268 us/op</span><br></pre></td></tr></table></figure><p>通过 JMH 的测试结果中可以看出，使用 Random 生成 1000 个随机值所花费的平均时间是 772 微秒，但使用 ThreadLocalRandom 只花了 625 微秒。嗯，差距不是很大，但好歹也是有差距的，因为生成 1000 个随机数是瞬间的事情。</p><p>因此，我们可以得出结论，ThreadLocalRandom 在高度并发的环境中更有效。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五、Java并发 Java java.util.concurrent.Future</title>
      <link href="/posts/50778af3.html"/>
      <url>/posts/50778af3.html</url>
      
        <content type="html"><![CDATA[<h1 id="十五、Java并发-Java-java-util-concurrent-Future"><a href="#十五、Java并发-Java-java-util-concurrent-Future" class="headerlink" title="十五、Java并发 Java java.util.concurrent.Future"></a>十五、Java并发 Java java.util.concurrent.Future</h1><p>写了几篇 Java 一文秒懂 XXX 系列的文章后，对 Java 并发编程的设计思想真的是竖然起敬。</p><p>Java 在并发方面引入了 「 将来 」( Future ) 这个概念。把所有不在主线程执行的代码都附加了将来这个灵魂。主线程只负责其它并发线程的创建、启动、监视和处理并发线程完成任务或发生异常时的回调。其它情况，则交给并发线程自己去处理。而双方之间的沟通，就是通过一个个被称之为 「 将来 」 的类出处理。</p><p><code>Future</code> 定义在 <code>java.util.concurrent</code> 包中，这是一个接口，自 Java 1.5 以来一直存在的接口，用于处理异步调用和处理并发编程。</p><h2 id="创建-Future"><a href="#创建-Future" class="headerlink" title="创建 Future"></a>创建 <code>Future</code></h2><p>简单地说，<code>Future</code> 类表示异步计算的未来结果 – 在处理完成后最终将出现在 Future 中的结果。</p><p>是不是又很难理解，文字越少，内容越多。上面这句话的意思，就是主线程会创建一个 Future 接口的对象，然后启动并发线程，并告诉并发线程，一旦你执行完毕，就把结果存储在这个 Future 对象里。</p><p>因此，理解 Future 的第一步，就是要知道如何创建和返回 Future 实例。</p><p>一般情况下，我们会把长时间运行的逻辑放在异步线程中进行处理，这是使用 Future 接口最理想的场景。主线程只要简单的将异步任务封装在 Future 里，然后开始等待 Future 的完成，在这段等待的时间内，可以处理一些其它逻辑，一旦 Future 执行完毕，就可以从中获取执行的结果并进一步处理。</p><p>针对上面这种表述，我们来看看具体哪些场景可以使用 Future :</p><ul><li>计算密集型（ 数学和科学计算 ）</li><li>操纵大数据结构（ 大数据 ）</li><li>远程方法调用（下载文件，HTML 爬取，Web 服务）</li></ul><h3 id="实现了-Future-的-FutureTask"><a href="#实现了-Future-的-FutureTask" class="headerlink" title="实现了 Future 的 FutureTask"></a>实现了 Future 的 FutureTask</h3><p>我们先来看一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareCalculator</span> &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> </span><br><span class="line">      <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;Integer&gt; <span class="title function_">calculate</span><span class="params">(Integer input)</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> input * input;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你认真读过前几个章节，想必对这段代码不陌生了。</p><p>在上面这段代码中，我们创建了一个简单的类用于计算一个整型 ( Integer ) 的平方。当然了，计算平方这个任务肯定不能划到 「 长时间运行 」 这个类别里，所以我们在它之前又添加了 <code>Thread.sleep(1000)</code>。</p><blockquote><p>不要小看 1s。这已经是相当长的任务了。</p></blockquote><p>在上面这段代码中，实际执行的计算是作为 Lambda 表达式参数传递给 <code>call()</code> 方法。当然了，这个实际执行的代码，除了 <code>Thread.sleep()</code> 之外好像也没有什么特别之处。</p><p>好了，现在，我们应该将注意力转移到 Callable 和 ExecutorService 的使用，因为它们才是最有趣的。</p><p><code>Callable</code> 是一个接口，用于表示一个任务，这个任务可以返回值。<code>Callable</code> 接口只有一个方法 <code>call()</code>。上面的示例中。那个 Lambda 其实就是一个 Callable 实例。</p><blockquote><p>啥？ 不会看不懂吧？ 好吧，我找个时间好好写一些 Java Lambda 方面的文章。</p></blockquote><p>Callable 实例创建完成后并不会立即执行，我们仍然需要将它传递给一个 「 执行器 」( Executor , 执行程序 ) ，这个执行器将负责在新线程中启动该任务并返回一个包含了值的 Future 对象。</p><p>这个执行器，是 <code>Executor</code> 的实例，通常，它是一个 ExecutorService 类的实例。</p><p>Java 其实提供了很多方法创建 <code>ExecutorService</code> 的实例，但最常用的，也是最推荐的做法是使用 Executors 的静态工厂方法。上面的示例中，我们就使用了 <code>Executors.newSingleThreadExecutor()</code> 方法创建了一个能够处理单个线程的 ExecutorService。</p><p>一旦我们有了一个 ExecutorService 对象，我们只需要调用它的 <code>submit()</code> 并传递我们的 Callable 作为参数即可。 <code>submit()</code> 会启动任务并返回一个 FutureTask 对象。</p><p>FutureTask 是一个类，实现了 Future 接口， 在 <code>java.util.concurrent</code> 包中定义。</p><h2 id="消费-使用-Future"><a href="#消费-使用-Future" class="headerlink" title="消费( 使用 ) Future"></a>消费( 使用 ) Future</h2><p>用了相当长的篇幅，我们终于讲完了如何创建一个 Future 实例，接下来，我们将进入如何消费(使用) 刚刚创建的 Future 实例。</p><h3 id="使用-isDone-和-get-方法来获取结果"><a href="#使用-isDone-和-get-方法来获取结果" class="headerlink" title="使用 isDone() 和 get() 方法来获取结果"></a>使用 <code>isDone()</code> 和 <code>get()</code> 方法来获取结果</h3><p>现在，是时候调用 <code>calculate()</code> 方法获取返回的 Future 实例了，通过 Future 实例，我们就能进一步获取计算的整型结果。</p><p>要从 Future 实例中获取结果，我们需要用到两个方法：<code>isDone()</code> 和 <code>get()</code>。</p><p>1、 <code>Future.isDone()</code> 方法用于获取我们的执行器是否已完成任务处理。如果任务完成，则返回 <code>true</code>，否则返回 <code>false</code>。<br>2、 从计算中返回实际结果的方法是 <code>Future.get()</code>。但要注意的是，<code>Future.get()</code> 方法是一个阻塞方法。如果任务还没执行完毕，那么会一直阻塞直到直到任务完成，</p><p>为了防止调用 <code>Future.get()</code> 方法阻塞当前线程，推荐的做法是先调用 <code>Future.isDone()</code> 判断任务是否完成，然后再调用 <code>Future.get()</code> 从完成的任务中获取任务执行的结果。</p><p>因为 <code>Future.isDone()</code> 和 <code>Future.get()</code> 的存在，我们就可以在等待任务完成时运行其它一些代码，就像下面示例中所演示的那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">SquareCalculator</span>().calculate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!future.isDone()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br></pre></td></tr></table></figure><p>上面这段代码，我们在等待计算任务完成的同时执行了一条输出语句，用于提醒用户当前程序还是在运行的，并没有僵死。</p><p>我们使用了一个 <code>while</code> 循环，使用 <code>future.isDone()</code> 来检查任务是否完成，一旦完成，就会立即终止循环，并调用 <code>future.get()</code> 方法获取计算的结果。</p><p>因为实现使用了 <code>isDone()</code> 判断任务是否完成，所以 <code>future.get()</code> 并不会发生阻塞，想法，简直就是立即返回。</p><p>使用 <code>isDone()</code> 和 <code>get()</code> 方法来获取结果，这应该是消费 Future 最常见的方式。</p><p>当然了，值得一提的是，<code>Future.get()</code> 方法有一个可以超时等待的重载版本，这个重载版本接收两个参数，一个是超时的时间，另一个是超时时间的单位。方法原型如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException</span><br></pre></td></tr></table></figure><p>而使用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><code>get(long, TimeUnit)</code> 和 <code>get()</code> 的不同之处，是前者在经过指定的超时时间后任务仍未返回，那么就会抛出一个 <code>TimeoutException</code> 异常，表示执行超时。</p><h3 id="使用-Future-cancel-方法取消-Future"><a href="#使用-Future-cancel-方法取消-Future" class="headerlink" title="使用 Future.cancel() 方法取消 Future"></a>使用 <code>Future.cancel()</code> 方法取消 Future</h3><p>假设我们已经触发了一项任务，但由于某种原因，我们不再关心结果了。我们可以使用 <code>Future.cancel(boolean)</code> 告诉执行器停止操作并中断其底层线程。该方法很简单，使用演示如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">SquareCalculator</span>().calculate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>上面这两行代码，我们的 Future 实例永远不会完成它的操作。实际上，如果我们尝试在调用了 <code>cancel()</code> 方法之后立即调用 <code>get()</code> 方法，将会获得一个 <code>CancellationException</code> 异常。</p><p>为了防止 <code>Future.get()</code> 抛出一个 <code>CancellationException</code> 异常，我们可以使用 <code>Future.isCancelled()</code> 检查 Future 是否已被取消。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1、 对 <code>cancel()</code> 的调用可能会失败。如果调用失败，那么它会返回 <code>false</code>。<br>2、 cancel() 方法接受一个布尔值作为参数，该参数用于控制执行此任务的线程是否应该被中断。</p><h2 id="多线程-vs-线程池"><a href="#多线程-vs-线程池" class="headerlink" title="多线程 vs 线程池"></a>多线程 vs 线程池</h2><p>上面的示例中，我们的 <code>ExecutorService</code> 实例是单线程的，因为它是使用 <code>Executors.newSingleThreadExecutor()</code> 方法获得的。</p><p>为了突出演示它是 「 单线程 」，我们改一下代码同时触发两个计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SquareCalculator</span> <span class="variable">squareCalculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SquareCalculator</span>();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future1 = squareCalculator.calculate(<span class="number">10</span>);</span><br><span class="line">Future&lt;Integer&gt; future2 = squareCalculator.calculate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(future1.isDone() &amp;&amp; future2.isDone())) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">      String.format(</span><br><span class="line">        <span class="string">&quot;future1 is %s and future2 is %s&quot;</span>, </span><br><span class="line">        future1.isDone() ? <span class="string">&quot;done&quot;</span> : <span class="string">&quot;not done&quot;</span>, </span><br><span class="line">        future2.isDone() ? <span class="string">&quot;done&quot;</span> : <span class="string">&quot;not done&quot;</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result1</span> <span class="operator">=</span> future1.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result2</span> <span class="operator">=</span> future2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(result1 + <span class="string">&quot; and &quot;</span> + result2);</span><br><span class="line"></span><br><span class="line">squareCalculator.shutdown();</span><br></pre></td></tr></table></figure><p>然后我们就会获得类似下面的输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calculating square <span class="keyword">for</span>: 10</span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">calculating square <span class="keyword">for</span>: 100</span><br><span class="line">future1 is <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">100 and 10000</span><br></pre></td></tr></table></figure><p>很明显，整个过程并不是并行执行的。因为第二个任务仅在第一个任务完成后才开始，所以，整个过程大约需要 2 秒钟才能完成。</p><p>为了使我们的程序真正具有多线程，我们应该使用不同风格的 <code>ExecutorService</code> 。例如下面这段代码，我们使用工厂方法<code>Executors.newFixedThreadPool()</code> 创建一个固定大小的线程池，并观察输出的结果有何变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我比较懒，你把相应的代码替换下即可，省略号那段就不用替换了。</p></blockquote><p>这段代码，对 SquareCalculator 类的做了一处简单的更改，使得我们的执行器拥有了 2 个同步线程。</p><p>如果我们再次运行完全相同的客户端代码，我们获得的输出可能如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calculating square <span class="keyword">for</span>: 10</span><br><span class="line">calculating square <span class="keyword">for</span>: 100</span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">100 and 10000</span><br></pre></td></tr></table></figure><p>现在看起来心情是否愉快多了，你应该留意到了， 2 个任务是如何同时开始和结束运行的，整个过程大约需要 1 秒钟就能完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四、Java并发 Java 守护线程 ( Daemon Thread )</title>
      <link href="/posts/a36784de.html"/>
      <url>/posts/a36784de.html</url>
      
        <content type="html"><![CDATA[<h1 id="十四、Java并发-Java-守护线程-Daemon-Thread"><a href="#十四、Java并发-Java-守护线程-Daemon-Thread" class="headerlink" title="十四、Java并发 Java 守护线程 ( Daemon Thread )"></a>十四、Java并发 Java 守护线程 ( Daemon Thread )</h1><p>在这篇简短的文章中，我们将讲解下 Java 中的守护线程，看看它们可以做什么。我们还将解释守护线程和用户线程之间的区别。</p><h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p>Java 提供了两种类型的线程：<strong>守护线程</strong> 和 <strong>用户线程</strong></p><ul><li><strong>用户线程</strong> 是高优先级线程。JVM 会在终止之前等待任何用户线程完成其任务。</li><li><strong>用户线程</strong> 是低优先级线程。其唯一作用是为用户线程提供服务。</li></ul><p>由于守护线程的作用是为用户线程提供服务，并且仅在用户线程运行时才需要，因此一旦所有用户线程完成执行，JVM 就会终止。也就是说 <strong>守护线程不会阻止 JVM 退出</strong>。</p><p>这也是为什么通常存在于守护线程中的无限循环不会导致问题，因为任何代码（包括 finally 块 ）都不会在所有用户线程完成执行后执行。</p><p>这也是为什么我们并不推荐 <strong>在守护线程中执行 I/O 任务</strong> 。因为可能导致无法正确关闭资源。</p><p>但是，守护线程并不是 100% 不能阻止 JVM 退出的。守护线程中设计不良的代码可能会阻止 JVM 退出。例如，在正在运行的守护线程上调用<code>Thread.join()</code> 可以阻止应用程序的关闭。</p><h2 id="守护线程能用来做什么？"><a href="#守护线程能用来做什么？" class="headerlink" title="守护线程能用来做什么？"></a>守护线程能用来做什么？</h2><p>常见的做法，就是将守护线程用于后台支持任务，比如垃圾回收、释放未使用对象的内存、从缓存中删除不需要的条目。</p><p>咦，按照这个解释，那么大多数 JVM 线程都是守护线程。</p><h2 id="如何创建守护线程-？"><a href="#如何创建守护线程-？" class="headerlink" title="如何创建守护线程 ？"></a>如何创建守护线程 ？</h2><p>守护线程也是一个线程，因此它的创建和启动其实和普通线程没什么区别？</p><p>要将普通线程设置为守护线程，方法很简单，只需要调用 <code>Thread.setDaemon()</code> 方法即可。</p><p>例如下面这段代码，假设我们继承 <code>Thread</code> 类创建了一个新类 <code>NewThread</code> 。那么我们就可以创建这个类的实例并设置为守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NewThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><p>在 Java 语言中，线程的状态是自动继承的。任何线程都会继承创建它的线程的守护程序状态。怎么理解呢？</p><p>1、 如果一个线程是普通线程（ 用户线程） ，那么它创建的子线程默认也是普通线程（ 用户线程 ）。<br>2、 如果一个线程是守护线程，那么它创建的子线程默认也是守护线程。</p><p>因此，我们可以推演出： 由于主线程是用户线程，因此在 <code>main()</code> 方法内创建的任何线程默认为用户线程。</p><p>需要注意的是调用 <code>setDaemon()</code> 方法的时机，该方法只能在创建 Thread 对象并且在启动线程前调用。在线程运行时尝试调用 <code>setDaemon()</code> 将抛出 IllegalThreadStateException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IllegalThreadStateException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenSetDaemonWhileRunning_thenIllegalThreadStateException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">NewThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">    daemonThread.start();</span><br><span class="line">    daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何检查一个线程是守护线程还是用户线程？"><a href="#如何检查一个线程是守护线程还是用户线程？" class="headerlink" title="如何检查一个线程是守护线程还是用户线程？"></a>如何检查一个线程是守护线程还是用户线程？</h2><p>检查一个线程是否是守护线程，可以简单地调用方法 <code>isDaemon()</code> ，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCallIsDaemon_thenCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">NewThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">    <span class="type">NewThread</span> <span class="variable">userThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">    daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">    userThread.start();</span><br><span class="line"></span><br><span class="line">    assertTrue(daemonThread.isDaemon());</span><br><span class="line">    assertFalse(userThread.isDaemon());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>守护线程的概念是不是很简单？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三、Java并发 Java java.util.concurrent.Locks</title>
      <link href="/posts/e2353faf.html"/>
      <url>/posts/e2353faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="十三、Java并发-Java-java-util-concurrent-Locks"><a href="#十三、Java并发-Java-java-util-concurrent-Locks" class="headerlink" title="十三、Java并发 Java java.util.concurrent.Locks"></a>十三、Java并发 Java java.util.concurrent.Locks</h1><p>对于 Java 来讲，锁 （ Lock ) 是一种比标准同步块 （ synchronized block ） 更灵活，更复杂的线程同步机制。</p><p>其实，Java 1.5 就已经存在 Lock 接口了。这个 Lock 接口在 <code>java.util.concurrent.lock</code> 包中定义，提供了大量的锁操作。</p><p>本文中，我们将讲解 Lock 接口的不同实现并介绍如何在应用程序中使用锁。</p><h2 id="锁-lock-和同步块-synchronized-block-之间的差异"><a href="#锁-lock-和同步块-synchronized-block-之间的差异" class="headerlink" title="锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异"></a>锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异</h2><p>使用 synchronized 块和使用 Lock API 之间几乎没有区别：</p><ul><li><strong>同步块完全包含在方法中</strong> : 在独立的方法中，我们可以使用 Lock 提供的 <code>lock()</code> 和 <code>unlock()</code> 实现锁和解锁操作。</li><li>同步块不支持公平竞争，任何线程都可以获取释放的锁定，且不能指定优先级。但锁 ( Lock ) 就不一样了，可以通过指定公平属性来实现 Lock 中的公平性。这可以确保最长的等待线程被授予锁定权限。</li><li>如果线程无法访问同步块，则会阻塞该线程。Lock 则提供了 <code>tryLock()</code> 方法。线程只有在可用且不被任何其他线程保持时才获取锁定。这减少了线程等待锁定的阻塞时间。</li><li>处于 「 等待 」 状态以获取对同步块的访问的线程不能被中断。Lock 提供了一个 <code>lockInterruptibly()</code> 方法，可用于在等待锁定时中断线程。</li></ul><p>从上面的对比来看，同步块的所有机制，锁 ( Lock ) 都有相应的 API 对应。</p><h2 id="Lock-API"><a href="#Lock-API" class="headerlink" title="Lock API"></a>Lock API</h2><p>我们来看看 Lock 接口提供了哪些方法：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void lock()</td><td align="center">尝试获取锁（如果可用），如果锁不可用，则线程会被阻塞，直到锁被释放</td></tr><tr><td align="center">oid lockInterruptibly()</td><td align="center">类似于 <code>lock()</code>，但它允许被阻塞的线程被中断并通过抛出的 <code>java.lang.InterruptedException</code> 恢复执行</td></tr><tr><td align="center">boolean tryLock()</td><td align="center"><code>lock()</code> 方法的非阻塞版本，它会立即尝试获取锁定，如果锁定成功则返回 true</td></tr><tr><td align="center">boolean tryLock(long timeout, TimeUnit timeUnit)</td><td align="center">类似于 <code>tryLock()</code>，但它可以指定超时，达到超时之后就会自动放弃获取锁</td></tr><tr><td align="center">void unlock()</td><td align="center">解锁 Lock 实例</td></tr></tbody></table><p>锁定的实例应该始终被解锁以避免死锁情况。</p><p>锁的推荐使用方式是将锁相关的代码块放在 <code>try/catch</code> 和 <code>finally</code> 块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...; </span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access to the shared resource</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 Lock 接口之外，<code>java.util.concurrent.lock</code> 包还提供了一个 ReadWriteLock 接口，俗称 「读写锁」，它维护一对锁，一个用于只读操作，一个用于写操作。</p><p>对于读写锁，只要没有写入，读锁定可以由多个线程同时保持。</p><p>ReadWriteLock 声明了两个方法用于获取读取或写入锁</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Lock readLock()</td><td align="center">返回一个用于读取的锁</td></tr><tr><td align="center">Lock writeLock()</td><td align="center">返回一个用于写的锁</td></tr></tbody></table><h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><h3 id="ReentrantLock-锁"><a href="#ReentrantLock-锁" class="headerlink" title="ReentrantLock 锁"></a>ReentrantLock 锁</h3><p>ReentrantLock 类实现了 <code>Lock</code> 接口。它提供了相同的并发和内存语义，如使用 synchronized 方法和语句访问的隐式监视器锁，而且可以被子类化。</p><p>我们写一个范例演示下如何使用 ReenrtantLock 来实现同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedObject</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Critical section here</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的示例所示，我们需要确保在 <code>try-finally</code> 块中包装 <code>lock()</code> 和 <code>unlock()</code> 调用以避免死锁情况。</p><p>现在，让我们来看看 <code>tryLock()</code> 的工作原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTryLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLockAcquired</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLockAcquired) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Critical section here</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个范例中，调用 <code>tryLock()</code> 的线程将等待一秒钟，如果锁定不可用则放弃等待。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock 类实现了 ReadWriteLock 接口。</p><p>我们来看一下线程获取 ReadLock 或 WriteLock 的规则：</p><ul><li><strong>读锁</strong> : 如果没有线程获得写锁定或请求它，则多个线程可以获取读锁定。</li><li><strong>写锁</strong> : 如果没有线程正在读或写，则只有一个线程可以获取写锁。</li></ul><p>我们写一个范例演示下如何使用 ReadWriteLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedHashMapWithReadWriteLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String&gt;  syncHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            syncHashMap.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">return</span> syncHashMap.remove(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这两种 “写” 操作，我们需要使用写锁定来包围临界区，只有一个线程可以访问它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">return</span> syncHashMap.get(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">return</span> syncHashMap.containsKey(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这两种 “读” 操作，我们需要使用读锁定来包围临界区。如果没有正在进行的写操作，多个线程可以访问此部分。</p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock 是 Java 8 中引入的。它支持读写锁定。不同的是，锁的获取方法返回的戳记 （ stamp ） 可以用于释放锁定或检查锁定是否仍然有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockDemo</span> &#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StampedLock 提供的另一个功能是 「 乐观锁 」 。大多数时候，读操作不需要等待写操作完成，因此不需要完全成熟的读锁。相反，我们可以升级到读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">readWithOptimisticLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!lock.validate(stamp)) &#123;</span><br><span class="line">        stamp = lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(stamp);               </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><p>Condition 类让线程能够在执行临界区时等待某些条件发生。当线程获得对临界区的访问但没有执行其操作的必要条件时，可能会发生这种情况。</p><p>例如，读线程可以访问共享队列的锁，该队列仍然没有任何数据可供使用。</p><p>传统上，Java 为线程互通提供了 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法。</p><p>Condition 类有类似的机制，而且，还允许我们指定多个条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockWithCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">stackEmptyCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">stackFullCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushToStack</span><span class="params">(String item)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(stack.size() == CAPACITY)&#123;</span><br><span class="line">                stackFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(item);</span><br><span class="line">            stackEmptyCondition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">popFromStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(stack.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                stackEmptyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack.pop();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stackFullCondition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二、Java并发 Java BlockingQueue</title>
      <link href="/posts/deede7ad.html"/>
      <url>/posts/deede7ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="十二、Java并发-Java-BlockingQueue"><a href="#十二、Java并发-Java-BlockingQueue" class="headerlink" title="十二、Java并发 Java BlockingQueue"></a>十二、Java并发 Java BlockingQueue</h1><p>本文中，我们将介绍一个 <code>java.util.concurrent</code> 包提供的用于解决并发生产者 – 消费者问题的最有用的类 – BlockQueue。我们将介绍BlockingQueue 接口的 API 以及如何使用该接口的方法使编写并发程序更容易。</p><p>在本文的后面，我们将展示一个具有多个生产者线程和多个消费者线程的简单程序的示例。</p><h2 id="BlockingQueue-的队列类型"><a href="#BlockingQueue-的队列类型" class="headerlink" title="BlockingQueue 的队列类型"></a>BlockingQueue 的队列类型</h2><p>java.util.concurrent 提供了两种类型的 BlockingQueue：</p><p>1、 无限队列 （unbounded queue ） – 几乎可以无限增长<br>2、 有限队列 （ bounded queue ） – 定义了最大容量</p><h2 id="无限队列"><a href="#无限队列" class="headerlink" title="无限队列"></a>无限队列</h2><p>创建一个无限队列的方法很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>上面这段代码中，<code>blockingQueue</code> 的容量将设置为 <code>Integer.MAX_VALUE</code> 。</p><p>向无限队列添加元素的所有操作都将永远不会阻塞，因此它可以增长到非常大的容量。</p><p>使用无限 BlockingQueue 设计生产者 – 消费者模型时最重要的是 <strong>消费者应该能够像生产者向队列添加消息一样快地消费消息</strong> 。否则，内存可能会填满，然后就会得到一个 <code>OutOfMemory</code> 异常。</p><h2 id="有限队列"><a href="#有限队列" class="headerlink" title="有限队列"></a>有限队列</h2><p>第二种类型的队列是有限队列。我们可以通过将容量作为参数传递给构造函数来创建这样的队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = new LinkedBlockingDeque&lt;&gt;(10);</span><br></pre></td></tr></table></figure><p>上面这句代码中，我们设置了 <code>blockingQueue</code> 的容量为 10 。这意味着当消费者尝试将元素添加到已经满了的队列时，结果取决于添加元素的方法（ <code>offer()</code> 、<code>add()</code> 、<code>put()</code> ) ，它将阻塞，直到有足够的空间可以插入元素。否则，添加操作将会失败。</p><p>使用有限队列是设计并发程序的好方法，因为当我们将元素插入到已经满了的队列时，这些操作需要等到消费者赶上并在队列中提供一些空间。这种机制可以让那个我们不做任何其它更改就可以实现节流。</p><h2 id="BlockingQueue-API"><a href="#BlockingQueue-API" class="headerlink" title="BlockingQueue API"></a>BlockingQueue API</h2><p>BlockingQueue 接口的所有方法可以分为两大类：负责向队列添加元素的方法和检索这些元素的方法。</p><p>在队列满/空的情况下，来自这两个组的每个方法的行为都不同。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><code>BlockingQueue</code> 提供了以下方法用于添加元素</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">add()</td><td align="center">如果插入成功则返回 true，否则抛出 IllegalStateException 异常</td></tr><tr><td align="center">put()</td><td align="center">将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入</td></tr><tr><td align="center">offer()</td><td align="center">如果插入成功则返回 true，否则返回 false</td></tr><tr><td align="center">offer(E e, long timeout, TimeUnit unit)</td><td align="center">尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入</td></tr></tbody></table><h3 id="检索元素"><a href="#检索元素" class="headerlink" title="检索元素"></a>检索元素</h3><p><code>BlockingQueue</code> 提供了以下方法用于检索元素</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">take()</td><td align="center">获取队列的头部元素并将其删除，如果队列为空，则阻塞并等待元素变为可用</td></tr><tr><td align="center">poll(long timeout, TimeUnit unit)</td><td align="center">检索并删除队列的头部，如有必要，等待指定的等待时间以使元素可用，如果超时，则返回 null</td></tr></tbody></table><p>在构建生产者 – 消费者程序时，这些方法是 BlockingQueue 接口中最重要的构建块。</p><h2 id="多线程生产者-–-消费者示例"><a href="#多线程生产者-–-消费者示例" class="headerlink" title="多线程生产者 – 消费者示例"></a>多线程生产者 – 消费者示例</h2><p>接下来我们创建一个由两部分组成的程序 – 生产者 ( Producer ) 和消费者 ( Consumer ) 。</p><p>生产者将生成一个 0 到 100 的随机数，并将该数字放在 BlockingQueue 中。我们将创建 4 个线程用于生成随机数并使用 <code>put()</code> 方法阻塞，直到队列中有可用空间。</p><p>需要记住的重要一点是，我们需要阻止我们的消费者线程无限期地等待元素出现在队列中。</p><p>从生产者向消费者发出信号的好方法是，不需要处理消息，而是发送称为毒 （ poison ） 丸 （ pill ） 的特殊消息。 我们需要发送尽可能多的毒 （ poison ） 丸 （ pill ） ，因为我们有消费者。然后当消费者从队列中获取特殊的毒 （ poison ） 丸 （ pill ）消息时，它将优雅地完成执行。</p><p>我们来看以下生产者的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumbersProducer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; numbersQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poisonPill;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poisonPillPerProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumbersProducer</span><span class="params">(BlockingQueue&lt;Integer&gt; numbersQueue, <span class="type">int</span> poisonPill, <span class="type">int</span> poisonPillPerProducer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numbersQueue = numbersQueue;</span><br><span class="line">        <span class="built_in">this</span>.poisonPill = poisonPill;</span><br><span class="line">        <span class="built_in">this</span>.poisonPillPerProducer = poisonPillPerProducer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            generateNumbers();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">generateNumbers</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numbersQueue.put(ThreadLocalRandom.current().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; poisonPillPerProducer; j++) &#123;</span><br><span class="line">            numbersQueue.put(poisonPill);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的生成器构造函数将 BlockingQueue 作为参数，用于协调生产者和使用者之间的处理。我们看到方法 <code>generateNumbers()</code> 将 100 个元素放入队列中。它还需要有毒 （ poison ） 丸 （ pill ） 消息，以便知道在执行完成时放入队列的消息类型。该消息需要将 poisonPillPerProducer 次放入队列中。</p><p>每个消费者将使用 <code>take()</code> 方法从 BlockingQueue 获取一个元素，因此它将阻塞，直到队列中有一个元素。从队列中取出一个 Integer 后，它会检查该消息是否是毒 （ poison ） 丸 （ pill ） ，如果是，则完成一个线程的执行。否则，它将在标准输出上打印出结果以及当前线程的名称。</p><p>这将使我们深入了解消费者的内部运作机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumbersConsumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poisonPill;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumbersConsumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue, <span class="type">int</span> poisonPill)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        <span class="built_in">this</span>.poisonPill = poisonPill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                <span class="keyword">if</span> (number.equals(poisonPill)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; result: &quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的重要事项是队列的使用。与生成器构造函数中的相同，队列作为参数传递。我们可以这样做，是因为 BlockingQueue 可以在线程之间共享而无需任何显式同步。</p><p>既然我们有生产者和消费者，我们就可以开始我们的计划。我们需要定义队列的容量，并将其设置为 100 个元素。</p><p>我们希望有 4 个生产者线程，并且有许多消费者线程将等于可用处理器的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">BOUND</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N_PRODUCERS</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N_CONSUMERS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="type">int</span> <span class="variable">poisonPill</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">poisonPillPerProducer</span> <span class="operator">=</span> N_CONSUMERS / N_PRODUCERS;</span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> N_CONSUMERS % N_PRODUCERS;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(BOUND);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N_PRODUCERS; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NumbersProducer</span>(queue, poisonPill, poisonPillPerProducer)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N_CONSUMERS; j++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NumbersConsumer</span>(queue, poisonPill)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NumbersProducer</span>(queue, poisonPill, poisonPillPerProducer + mod)).start();</span><br></pre></td></tr></table></figure><p>BlockingQueue 是使用具有容量的构造创建的。我们正在创造 4 个生产者和 N 个消费者。我们将我们的毒 （ poison ） 丸 （ pill ）消息指定为 <code>Integer.MAX_VALUE</code>，因为我们的生产者在正常工作条件下永远不会发送这样的值。这里要注意的最重要的事情是 BlockingQueue 用于协调它们之间的工作。</p><p>当我们运行程序时，4 个生产者线程将随机整数放入 BlockingQueue 中，消费者将从队列中获取这些元素。每个线程将打印到标准输出线程的名称和结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一、Java并发 Java CountDownLatch</title>
      <link href="/posts/92030527.html"/>
      <url>/posts/92030527.html</url>
      
        <content type="html"><![CDATA[<h1 id="十一、Java并发-Java-CountDownLatch"><a href="#十一、Java并发-Java-CountDownLatch" class="headerlink" title="十一、Java并发 Java CountDownLatch"></a>十一、Java并发 Java CountDownLatch</h1><p>本章节我们来讨论下 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html">java.util.concurrent.CountDownLatch</a> 这个类，顺带演示下如何在一些实际例子中使用它。</p><p>CountDownLatch 类的作用呢？ 怎么说呢？ 简单来说，我们可以使用它来阻塞线程，直到其他线程完成给定任务。</p><h2 id="并发编程中使用-CountDownLatch"><a href="#并发编程中使用-CountDownLatch" class="headerlink" title="并发编程中使用 CountDownLatch"></a>并发编程中使用 CountDownLatch</h2><p>简而言之，CountDownLatch 有一个计数器字段，我们可以根据需要减少它，因此，我们可以使用它来阻止调用线程，直到它被计数到零。</p><p>如果我们正在进行一些并行处理，我们可以使用与计数器相同的值来实例化 CountDownLatch，因为我们想要处理多个线程。然后，我们可以在每个线程完成后调用 <code>countdown()</code>，保证调用 <code>await()</code> 的依赖线程将阻塞，直到工作线程完成。</p><h2 id="使用-CountDownLatch-等待线程池完成"><a href="#使用-CountDownLatch-等待线程池完成" class="headerlink" title="使用 CountDownLatch 等待线程池完成"></a>使用 CountDownLatch 等待线程池完成</h2><p>我们通过创建一个 Worker 来尝试这个模式，并使用 CountDownLatch 字段来指示它何时完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; outputScraper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(List&lt;String&gt; outputScraper, CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.outputScraper = outputScraper;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doSomeWork();</span><br><span class="line">        outputScraper.add(<span class="string">&quot;Counted down&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个测试，以证明我们可以让 CountDownLatch 等待 Worker 实例完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenParallelProcessing_thenMainThreadWillBlockUntilCompletion</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; outputScraper = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    List&lt;Thread&gt; workers = Stream</span><br><span class="line">      .generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(outputScraper, countDownLatch)))</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(toList());</span><br><span class="line"></span><br><span class="line">      workers.forEach(Thread::start);</span><br><span class="line">      countDownLatch.await(); </span><br><span class="line">      outputScraper.add(<span class="string">&quot;Latch released&quot;</span>);</span><br><span class="line"></span><br><span class="line">      assertThat(outputScraper)</span><br><span class="line">        .containsExactly(</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Latch released&quot;</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个示例中，<code>&quot;Latch release&quot;</code> 将始终是最后一个输出 – 因为它取决于 CountDownLatch 的释放。</p><p>注意，如果我们没有调用 <code>await()</code> 方法，我们将无法保证线程执行的顺序，因此测试会随机失败。</p><h2 id="在等待开始的线程池中使用-CountDownLatch"><a href="#在等待开始的线程池中使用-CountDownLatch" class="headerlink" title="在等待开始的线程池中使用 CountDownLatch"></a>在等待开始的线程池中使用 CountDownLatch</h2><p>我们重用前面的示例，但是这次开启了了数千个线程而不是 5 个线程，很可能许多早期的线程在后面的线程上调用 <code>start()</code> 之前已经完成了处理。这可能会使尝试重现并发问题变得困难，因为我们无法让所有线程并行运行。</p><p>为了解决这个问题，我们让 CountdownLatch 的工作方式与上一个示例有所不同。在某些子线程完成之前，我们可以阻止每个子线程直到所有其他子线程都启动，而不是阻塞父线程。</p><p>我们把上一个示例的 <code>run()</code> 方法修改下，使其在处理之前阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; outputScraper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch readyThreadCounter;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch callingThreadBlocker;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch completedThreadCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitingWorker</span><span class="params">(</span></span><br><span class="line"><span class="params">      List&lt;String&gt; outputScraper,</span></span><br><span class="line"><span class="params">      CountDownLatch readyThreadCounter,</span></span><br><span class="line"><span class="params">      CountDownLatch callingThreadBlocker,</span></span><br><span class="line"><span class="params">      CountDownLatch completedThreadCounter)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.outputScraper = outputScraper;</span><br><span class="line">        <span class="built_in">this</span>.readyThreadCounter = readyThreadCounter;</span><br><span class="line">        <span class="built_in">this</span>.callingThreadBlocker = callingThreadBlocker;</span><br><span class="line">        <span class="built_in">this</span>.completedThreadCounter = completedThreadCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        readyThreadCounter.countDown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callingThreadBlocker.await();</span><br><span class="line">            doSomeWork();</span><br><span class="line">            outputScraper.add(<span class="string">&quot;Counted down&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            completedThreadCounter.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们修改下测试，直到所有工人都已启动，解锁工人，然后阻止，直到工人完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenDoingLotsOfThreadsInParallel_thenStartThemAtTheSameTime</span><span class="params">()</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; outputScraper = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">readyThreadCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">callingThreadBlocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">completedThreadCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    List&lt;Thread&gt; workers = Stream</span><br><span class="line">      .generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitingWorker</span>(</span><br><span class="line">        outputScraper, readyThreadCounter, callingThreadBlocker, completedThreadCounter)))</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(toList());</span><br><span class="line"></span><br><span class="line">    workers.forEach(Thread::start);</span><br><span class="line">    readyThreadCounter.await(); </span><br><span class="line">    outputScraper.add(<span class="string">&quot;Workers ready&quot;</span>);</span><br><span class="line">    callingThreadBlocker.countDown(); </span><br><span class="line">    completedThreadCounter.await(); </span><br><span class="line">    outputScraper.add(<span class="string">&quot;Workers complete&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assertThat(outputScraper)</span><br><span class="line">      .containsExactly(</span><br><span class="line">        <span class="string">&quot;Workers ready&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Workers complete&quot;</span></span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式对于尝试重现并发错误非常有用，可以用来强制数千个线程尝试并行执行某些逻辑。</p><h2 id="让-CountdownLatch-尽早结束"><a href="#让-CountdownLatch-尽早结束" class="headerlink" title="让 CountdownLatch 尽早结束"></a>让 CountdownLatch 尽早结束</h2><p>有时，我们可能会遇到一个情况，即在 CountdownLatch 倒计时之前，Workers 已经终止了错误。这可能导致它永远不会达到零并且 <code>await()</code> 永远不会终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oh dear, I&#x27;m a BrokenWorker&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    outputScraper.add(<span class="string">&quot;Counted down&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改下之前的测试以使用 BrokenWorker，来演示 <code>await()</code> 将如何永久阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFailingToParallelProcess_thenMainThreadShouldGetNotGetStuck</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; outputScraper = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    List&lt;Thread&gt; workers = Stream</span><br><span class="line">      .generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BrokenWorker</span>(outputScraper, countDownLatch)))</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(toList());</span><br><span class="line"></span><br><span class="line">    workers.forEach(Thread::start);</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这不是我们想要的行为 – 应用程序继续比无限阻塞要好得多。</p><p>为了解决这个问题，我们在调用 <code>await()</code> 时添加一个超时参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">completed</span> <span class="operator">=</span> countDownLatch.await(<span class="number">3L</span>, TimeUnit.SECONDS);</span><br><span class="line">assertThat(completed).isFalse();</span><br></pre></td></tr></table></figure><p>然后，我们可以看到，测试最终会超时，<code>await()</code> 将返回 false</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、Java并发系列之 Java 并发编程面试题</title>
      <link href="/posts/774c589b.html"/>
      <url>/posts/774c589b.html</url>
      
        <content type="html"><![CDATA[<h1 id="十、Java并发系列之-Java-并发编程面试题"><a href="#十、Java并发系列之-Java-并发编程面试题" class="headerlink" title="十、Java并发系列之 Java 并发编程面试题"></a>十、Java并发系列之 Java 并发编程面试题</h1><p>应聘 Java 岗，总是免不了几个 Java 并发编程的面试题，不过大多数都局限在 <code>java.util.concurrent</code> 包下的知识和实现问题。本文针对 Java 并发相关的常见的面试题做一些解释。</p><h2 id="Q1-进程和线程的区别？"><a href="#Q1-进程和线程的区别？" class="headerlink" title="Q1: 进程和线程的区别？"></a><strong>Q1: 进程和线程的区别？</strong></h2><blockquote><p>这是一个非常基础的面试题，如果这道题没有回答的比较满意，一般情况下，面试官会认为应聘者在并发方面的基础只是不牢固，就不会继续深入询问其它并发问题了。</p></blockquote><p>1、进程和线程都是并发单元，但它们有一个根本区别：<strong>进程不共享公共内存，而线程则共享</strong>。<br>2、从操作系统的角度来看，进程是一个独立的软件，在其自己的虚拟内存空间中运行。任何一个多任务操作系统（这几乎意味着任何现代操作系统）都必须将内存中的进程分开，这样一个失败的进程就不会通过加扰公共内存来拖累所有其它进程。因此，进程通常是隔离的，它们通过进程间通信进行协作，进程间通信由操作系统定义为一种中间 API。<br>3、相反，线程是应用程序的一部分，它与同一应用程序的其他线程共享公共内存。使用公共内存可以减少大量开销，因此使用线程可以更快的交换数据和进行线程间协作。</p><blockquote><p>关于进程间通讯那一块可以不用回答，如果你不懂的话，不必然会导致接下来的某个问题是 进程间通讯的的原理.</p></blockquote><h2 id="Q2-如何创建一个线程实例并且运行它？"><a href="#Q2-如何创建一个线程实例并且运行它？" class="headerlink" title="Q2: 如何创建一个线程实例并且运行它？"></a><strong>Q2: 如何创建一个线程实例并且运行它？</strong></h2><blockquote><p>这道题考察的是对 Runnable 的理解。</p></blockquote><p>创建一个线程的实例，有两种方法可供选择:</p><p>1、把 Runnable 的实例传递给 Thread 的构造函数并调用 <code>start()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;</span><br><span class="line">  System.out.println(<span class="string">&quot;Hello World from Runnable!&quot;</span>));</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure><p>Runnable是一个函数接口，因此可以作为 lambda 表达式传递<br>2、因为线程本身也实现了 Runnable 接口，所以另一种创建线程的方法是创建一个匿名子类，覆写它的 <code>run()</code> 方法，然后调用 <code>start()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World from subclass!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><h2 id="Q3-描述线程的不同状态以及何时发生状态转换-？"><a href="#Q3-描述线程的不同状态以及何时发生状态转换-？" class="headerlink" title="Q3: 描述线程的不同状态以及何时发生状态转换 ？"></a><strong>Q3: 描述线程的不同状态以及何时发生状态转换 ？</strong></h2><blockquote><p>这道题考察的是对线程生命周期的理解。</p></blockquote><p>1、一般情况下，我们会使用 <code>Thread.getState()</code> 方法检查线程 ( Thread ) 的状态。<br>2、线程的不同状态都定义在 <code>Thread.State</code> 枚举中。<br>3、线程的所有状态如下所示</p><p>1、<strong>NEW</strong> : 一个尚未调用 <code>Thread.start()</code> 方法启动的新 Thread 实例。<br>2、<strong>RUNNABLE</strong> : 一个正在运行的线程。它被称为 runnable，因为在任何给定时间，它要么正在运行要么在等待线程调度。当调用<code>Thread.start()</code> 方法时，会将一个 <code>NEW</code> 线程进入 <code>RUNNABLE</code> 状态。<br>3、<strong>BLOCKED</strong> : 如果正在运行的线程需要进入同步部分但由于另一个线程持有此部分的监视器而无法执行此操作，则该线程将被阻塞。<br>4、<strong>WAITING</strong> : 如果线程等待另一个线程执行特定操作，则该线程进入此状态。例如，一个线程在它持有的监视器上调用 <code>Object.wait()</code> 法时进入此状态，或者在另一个线程上调用 <code>Thread.join()</code> 方法也会进入此状态。<br>5、<strong>IMED_WAITING</strong> : 跟 <strong>WAITING</strong> 状态差不多。但线程在调用 <code>Thread.sleep()</code>、<code>Object.wait()</code>、或 <code>Thread.join()</code> 和其他一些方法的定时版本后进入此状态<br>6、<strong>TERMINATED</strong> ： 当一个线程已经完成它的 <code>Runnable.run()</code> 方法的执行并终止时进入此状态。</p><h2 id="Q4-Runnable-和-Callable-接口有什么区别？它们是如何使用的？"><a href="#Q4-Runnable-和-Callable-接口有什么区别？它们是如何使用的？" class="headerlink" title="Q4: Runnable 和 Callable 接口有什么区别？它们是如何使用的？"></a>Q4: Runnable 和 Callable 接口有什么区别？它们是如何使用的？</h2><p>1、Runnable 接口表示必须在单独的线程中运行的计算单位，它只有一个 <code>run()</code> 方法。Runnable 接口不允许此方法返回值或抛出未经检查的异常。<br>2、Callable 接口表示具有返回值的任务，它只有一个 <code>call()</code> 方法。<code>call()</code> 方法可以返回一个值 ( 可以是 Void )，也可以抛出一个异常。Callable 通常在 <code>ExecutorService</code> 实例中用于启动异步任务，然后调用返回的 Future 实例以获取其值。</p><h2 id="Q5-什么是守护线程，它的使用场景是什么？如何创建守护线程-？"><a href="#Q5-什么是守护线程，它的使用场景是什么？如何创建守护线程-？" class="headerlink" title="Q5: 什么是守护线程，它的使用场景是什么？如何创建守护线程 ？"></a>Q5: 什么是守护线程，它的使用场景是什么？如何创建守护线程 ？</h2><p>1、守护线程是一个不阻止 Java 虚拟机 ( JVM ) 退出的线程。当所有非守护线程终止时，JVM 只是放弃所有剩余的守护线程。<br>2、守护线程通常用于为其他线程执行一些支持或服务任务，但我们应该考虑到它们可能随时被放弃。<br>3、要将一个线程作为守护线程启动，应该在调用 <code>start()</code> 之前使用 <code>setDaemon()</code>方法设置为守护线程。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()</span><br><span class="line">  -&gt; System.out.println(<span class="string">&quot;Hello from daemon!&quot;</span>));</span><br><span class="line">daemon.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure><h3 id="额外的"><a href="#额外的" class="headerlink" title="额外的"></a>额外的</h3><p>奇怪的是，如果将上面的代码放在 <code>main()</code> 内运行，则可能无法打印该消息。而发生这种情况的原因，是因为 <code>main()</code> 线程在守护线程运行到打印消息之前就已经终止。</p><p>我们不应该在守护线程中执行任何 I/O 操作，因为它们甚至无法执行其 finally 块并在被放弃时关闭资源。</p><h2 id="Q6-什么是-Thread-的中断标志？怎么设置和检查它？它与-InterruptedException-有什么关系？"><a href="#Q6-什么是-Thread-的中断标志？怎么设置和检查它？它与-InterruptedException-有什么关系？" class="headerlink" title="Q6: 什么是 Thread 的中断标志？怎么设置和检查它？它与 InterruptedException 有什么关系？"></a>Q6: 什么是 Thread 的中断标志？怎么设置和检查它？它与 InterruptedException 有什么关系？</h2><p>1、中断 ( interrupt ) 标志或中断状态是线程中断时设置的内部线程标志 ( <code>flag</code> 属性 ）。<br>2、要设置一个线程的中断标志，只需要简单的在线程对象上调用 <code>thread.interrupt()</code> 方法。<br>3、如果在某个方法内部的一个线程抛出了 <code>InterruptedException</code>（ <code>wait</code>、<code>join</code>、<code>sleep</code> 等 ），那么此方法会立即抛出InterruptedException。线程可以根据自己的逻辑自由处理此异常。如果一个线程不在这样的方法中并且调用了 <code>thread.interrupt()</code>，则不会发生任何特殊情况。<br>4、线程的中断状态可以通过使用静态 <code>Thread.interrupted()</code> 方法或实例的 <code>isInterrupted()</code> 方法定期检查。这两个方法的区别是静态<code>Thread.interrupt()</code> 会清除了中断标志，而 <code>isInterrupted()</code> 则不会。</p><h2 id="Q7-什么是-Executor-和-ExecutorService-？这两个接口有什么区别？"><a href="#Q7-什么是-Executor-和-ExecutorService-？这两个接口有什么区别？" class="headerlink" title="Q7: 什么是 Executor 和 ExecutorService ？这两个接口有什么区别？"></a>Q7: 什么是 Executor 和 ExecutorService ？这两个接口有什么区别？</h2><p>1、<code>Executor</code> 和 <code>ExecutorService</code> 是 <code>java.util.concurrent</code> 框架提供的两个相关接口。<br>2、<code>Executor</code> 是一个非常简单的接口，只有一个 <code>execute()</code> 方法接受 Runnable 实例来执行。在大多数情况下，这是我们的任务执行代码应该依赖的接口。<br>3、<code>ExecutorService</code> 扩展了 <code>Executor</code> 接口，并且添加了许多其它方法以处理和检查并发任务执行服务的生命周期（在关闭时终止任务）和更复杂的异步任务处理，包括 Futures。</p><blockquote><p>更多 Executor 和 ExecutorService 的知识，可以访问 一文秒懂 Java ExecutorService。</p></blockquote><h2 id="Q8-java-util-concurrent-标准库中-ExecutorService-的可用实现是什么-？"><a href="#Q8-java-util-concurrent-标准库中-ExecutorService-的可用实现是什么-？" class="headerlink" title="Q8: java.util.concurrent 标准库中 ExecutorService 的可用实现是什么 ？"></a>Q8: java.util.concurrent 标准库中 ExecutorService 的可用实现是什么 ？</h2><blockquote><p>这是一个非常变 tai 的问题。问这个问题的面试官，你想咋样啊 ？</p></blockquote><p>ExecutorService 接口有三个标准实现</p><p>1、<code>ThreadPoolExecutor</code> : 使用线程池执行任务。一旦某个线程完成执行任务，它就会回到线程池中。如果池中的所有线程都忙，则任务必须等待轮到它。<br>2、<code>ScheduledThreadPoolExecutor</code> : 允许安排任务执行，而不是简单的在线程可用时立即运行任务。它还可以按固定频率或固定延迟安排任务。<br>3、<code>ForkJoinPool</code> : 是一个特殊的 ExecutorService，用于处理递归算法任务。如果你使用常规 ThreadPoolExecutor 进行递归算法，那么你很快发现所有线程都在忙着等待较低级别的递归完成。ForkJoinPool 实现了所谓的工作窃取算法，允许它更有效地使用可用线程。</p><h2 id="Q9-什么是-Java-内存模型（-JMM-）？描述下其目的和基本思想"><a href="#Q9-什么是-Java-内存模型（-JMM-）？描述下其目的和基本思想" class="headerlink" title="Q9: 什么是 Java 内存模型（ JMM ）？描述下其目的和基本思想"></a>Q9: 什么是 Java 内存模型（ JMM ）？描述下其目的和基本思想</h2><p>Java 内存模式是 Java 语言规范的一部分</p><p>JMM 规定了多个线程如何访问并发 Java 应用程序中的公共内存，以及一个线程的数据更改如何对其他线程可见。</p><p>是不是很简单，虽然简短又简洁，但如果没有强大的数学背景，JMM 可能很难掌握。</p><p>对内存模型的需求源于这样一个事实：<strong>Java 代码访问数据的方式并不像它在底层实际发生的那样</strong>。</p><p>在保证内存读写的可观察结果是相同的情况下，Java 编译器，JIT 编译器甚至 CPU 都可以对内存读写进行重新排序或优化。</p><p>当我们的应用程序扩展到多个线程时，这会导致反直觉的结果，因为大多数这些优化只会考虑单个执行线程（ 跨线程优化器仍然非常难以实现 ）。</p><p>另一个可怕的问题是现代系统中的内存是多层的：<strong>处理器的多个内核可能会在其缓存或读/写缓冲区中保留一些非刷新数据，这也会影响从其它内核观察到的内存状态</strong>。</p><p>更糟糕的是，不同内存访问架构的存在将打破Java 「 一次编写，随处运行 」 的承诺。</p><p>但另所有 Java 程序员高兴的是，JMM 指定了在设计多线程应用程序时可能依赖的一些保证。坚持这些保证有助于程序员编写在各种体系结构之间稳定且可移植的多线程代码。</p><p>JMM 的主要概念是：</p><ul><li><strong>动作 ( Action )</strong> : 这些是线程间的动作，可以由一个线程执行并由另一个线程检测，如读取或写入变量，锁定/解锁监视器等等。</li><li><strong>同步动作 ( Synchronization actions )</strong> : 某个动作子集，例如读取/写入易失性变量，或锁定/解锁监视器。</li><li><strong>程序顺序 ( Program Order )</strong> : 俗称 <code>PO</code>，单个线程内可观察的动作总顺序。</li><li><strong>同步顺序 ( Synchronization Order )</strong> : 俗称 <code>SO</code>，所有同步操作之间的总顺序 – 它必须与程序顺序一致，也就是说，如果两个同步操作在PO 中一个接一个地出现，它们在 SO 中以相同的顺序出现 。</li><li><strong>同步与（ synchronizes-with）</strong> : 俗称 <code>SW</code> ，某些同步操作之间的关系，例如解锁监视器和锁定同一监视器（ 在另一个或同一个线程中 ）。</li><li><strong>发生在顺序之前 ( Happens-before Order )</strong> : 将 PO 与 SW 结合（ 在集合论中称为传递闭包 ），以创建线程之间所有动作的部分排序。如果一个动作发生在另一个动作之前，则第二个动作可以观察到第一个动作的结果（ 例如，在一个线程中写入变量并在另一个线程中读取 ）。</li><li><strong>发生在一致性之前 ( Happens-before consistency )</strong> : 如果每次读取都遵循先前发生的顺序中对该位置的最后一次写入，或者通过数据竞争进行其他一些写入操作，则一组操作是 HB 一致的。</li><li><strong>执行 ( Execution )</strong> : 它们之间有一组有序的动作和一致性规则</li></ul><p>对于给定的程序，我们可以观察到具有各种结果的多个不同的执行.但是如果一个程序正确同步，那么它的所有执行似乎都是顺序一致的，这意味着我们可以将多线程程序推断为一系列按顺序发生的动作。这样可以省去考虑引擎盖下重新排序，优化或数据缓存的麻烦。</p><blockquote><p>如果你了解协程，相关的概念和协程很相像的。</p></blockquote><h2 id="Q10-什么是易失-（-volatile-）-字段，JMM-对这样的领域有什么保证？"><a href="#Q10-什么是易失-（-volatile-）-字段，JMM-对这样的领域有什么保证？" class="headerlink" title="Q10: 什么是易失 （ volatile ） 字段，JMM 对这样的领域有什么保证？"></a>Q10: 什么是易失 （ volatile ） 字段，JMM 对这样的领域有什么保证？</h2><p>根据 Java 内存模型 （ 参见 Q9 ） ，<code>volatile</code> 字段具有特殊属性。<code>volatile</code> 变量的读取和写入是同步操作，这意味着它们具有总排序（ 所有线程将遵循这些操作的一致顺序 ）。根据此顺序，保证读取 volatile 变量可以观察到对此变量的最后一次写入。</p><p>如果你有一个从多个线程访问的字段，且至少有一个线程写入它，那么你应该考虑使它变得 <code>volatile</code> ，否则某个线程从这个字段读取的内容并不会得到一丝的保证。</p><p><code>volatile</code> 的另一个保证是写入和读取 64 位值（ <code>long</code> 类型和 <code>double</code> 类型 ）的原子性。如果没有 <code>volatile</code> 修饰符，读取此类字段可能会观察到另一个线程部分写入的值。</p><h2 id="Q11-以下哪项操作是原子操作"><a href="#Q11-以下哪项操作是原子操作" class="headerlink" title="Q11: 以下哪项操作是原子操作 ?"></a>Q11: 以下哪项操作是原子操作 ?</h2><ul><li>写入一个非 volatile int 类型</li><li>写入一个 volatile int 类型</li><li>写入一个非 volatile long 类型</li><li>写入一个 volatile long 类型</li><li>递增一个 volatile long 类型</li></ul><p>是不是瞬间蒙了？我们来解释一下</p><p>1、对 int 类型（ 32位 ）变量的写入保证是原子的，无论它是否是易失性的。<br>2、long 类型（ 64位 ）变量可能需要在两个单独的步骤中写入，例如，在 32 位体系结构上，因此默认情况下，没有原子性保证。但是，如果添加了 <code>volatile</code> 修饰符，则保证以原子方式访问 long 变量。<br>3、递增操作通常由多个步骤完成（ 检索值，更改它并写回 ），因此它永远不会保证是原子的，变量是易变的。如果要实现值的原子增量，则应使用类<code>AtomicInteger</code>， <code>AtomicLong</code> 等。</p><h2 id="Q12-JMM-对添加了-final-修饰符的类的字段有什么特殊保证-？"><a href="#Q12-JMM-对添加了-final-修饰符的类的字段有什么特殊保证-？" class="headerlink" title="Q12: JMM 对添加了 final 修饰符的类的字段有什么特殊保证 ？"></a>Q12: JMM 对添加了 <code>final</code> 修饰符的类的字段有什么特殊保证 ？</h2><p>JVM 基本上会保证在任何线程获取对象之前初始化类的 <code>final</code> 字段。</p><p>如果没有这种保证，由于重新排序或其他优化，在初始化该对象的所有字段之前，可以向另一个线程发布对象的引用，即变得可见。这可能会导致对这些字段的访问。</p><p>这就是为什么在创建不可变对象时，应始终将其所有字段设为 <code>final</code>，即使它们不能通过 getter 方法访问。</p><h2 id="Q13-方法定义中-synchronized-关键字的含义是什么？静态方法？在一个块之前-？"><a href="#Q13-方法定义中-synchronized-关键字的含义是什么？静态方法？在一个块之前-？" class="headerlink" title="Q13: 方法定义中 synchronized 关键字的含义是什么？静态方法？在一个块之前 ？"></a>Q13: 方法定义中 synchronized 关键字的含义是什么？静态方法？在一个块之前 ？</h2><p>块 ( block ) 之前的 synchronized 关键字表示进入该块的任何线程都必须获取监视器（ 括号中的对象 ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">如果监视器已被另一个线程获取，则前一个线程将进入 BLOCKED 状态并等待监视器被释放。</span><br><span class="line"></span><br><span class="line">同步实例方法具有相同的语义，但会使用实例本身充当监视器。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态同步方法，监视器是表示声明类的 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q14-如果两个线程同时在不同的对象实例上调用-synchronized-方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办"><a href="#Q14-如果两个线程同时在不同的对象实例上调用-synchronized-方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办" class="headerlink" title="Q14: 如果两个线程同时在不同的对象实例上调用 synchronized 方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办?"></a>Q14: 如果两个线程同时在不同的对象实例上调用 synchronized 方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办?</h2><p>如果方法是实例方法，则实例充当方法的监视器。在不同实例上调用该方法的两个线程获取不同的监视器，因此它们都不会被阻塞。</p><p>如果方法是静态的，则监视器是 <code>Class</code> 对象。对于两个线程，监视器是相同的，因此其中一个可能会阻塞并等待另一个退出 <code>synchronized</code> 方法。</p><h2 id="Q15-Object类的-wait，notify-和-notifyAll-方法的目的是什么-？"><a href="#Q15-Object类的-wait，notify-和-notifyAll-方法的目的是什么-？" class="headerlink" title="Q15: Object类的 wait，notify 和 notifyAll 方法的目的是什么 ？"></a>Q15: Object类的 wait，notify 和 notifyAll 方法的目的是什么 ？</h2><p>拥有对象监视器的线程（ 例如，已进入由对象保护的同步部分的线程 ）可以调用 <code>object.wait()</code> 来临时释放监视器并为其他线程提供获取监视器的机会。例如，这可以在等待某个条件的情况下完成。</p><p>当另一个获取监视器的线程满足条件时，它可以调用 <code>object.notify()</code> 或 <code>object.notifyAll()</code> 并释放监视器。<code>notify()</code> 方法唤醒处于等待状态的单个线程，<code>notifyAll()</code> 方法唤醒等待此监视器的所有线程，并且它们都竞争重新获取锁定。</p><p>下面的 BlockingQueue 实现演示了多个线程如何通过 <code>wait-notify</code> 模式一起工作。如果我们将一个元素放入一个空队列，那么在 <code>take()</code> 方法中等待的所有线程都会唤醒并尝试接收该值。如果我们将一个元素放入一个已经满了的队列，<code>put()</code> 方法将等待对 <code>get()</code> 方法的调用。<code>get()</code> 方法删除一个元素，并通知在 <code>put()</code> 方法中等待队列对新项目有空位置的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == limit) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == limit) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q16-描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因"><a href="#Q16-描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因" class="headerlink" title="Q16: 描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因 ?"></a>Q16: 描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因 ?</h2><ul><li>死锁 （ <code>DeadLock</code> ） 是一组无法进行的线程中的条件，因为组中的每个线程都必须获取已由组中的另一个线程获取的某些资源。最简单的情况是两个线程需要锁定两个资源才能进行，第一个资源已被一个线程锁定，第二个资源已被另一个线程锁定。因为这些线程永远不会获得对两个资源的锁定，因此永远不会进展。</li><li>存活锁 ( <code>LiveLock</code> ) 是多线程对自己生成的条件或事件做出反应的一种情况。事件发生在一个线程中，必须由另一个线程处理。在此处理期间，发生的新事件必须在第一个线程中处理，依此类推。这样的线程是活着的并且没有被阻挡，但是仍然没有取得任何进展，因为它们用无用的工作压倒了对方</li><li>饥饿锁 ( <code>Starvation</code> ) 是线程无法获取资源的情况，因为其他线程（或多个线程）占用它太长时间或具有更高的优先级。线程无法取得进展，因此无法完成有用的工作。</li></ul><h2 id="Q17-描述-fork-join-框架的用途和用例"><a href="#Q17-描述-fork-join-框架的用途和用例" class="headerlink" title="Q17: 描述 fork/join 框架的用途和用例"></a>Q17: 描述 fork/join 框架的用途和用例</h2><p>fork/join 框架允许并行化递归算法。使用 ThreadPoolExecutor 之类的并行递归的主要问题是，可能会快速耗尽线程，因为每个递归步骤都需要自己的线程，而堆栈中的线程将处于空闲状态并等待。</p><p>fork/join 框架入口点是 ForkJoinPool 类，它是 ExecutorService 的一个实现。它实现了工作窃取算法，空闲线程会试图从忙线程中 「 窃取 」 工作。这允许在不同线程之间传播计算并在使用比通常的线程池所需的更少的线程时取得进展</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、Java并发 Java CompletableFuture ( 下 )</title>
      <link href="/posts/47722b62.html"/>
      <url>/posts/47722b62.html</url>
      
        <content type="html"><![CDATA[<h1 id="九、Java并发-Java-CompletableFuture-下"><a href="#九、Java并发-Java-CompletableFuture-下" class="headerlink" title="九、Java并发 Java CompletableFuture ( 下 )"></a>九、Java并发 Java CompletableFuture ( 下 )</h1><p>上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果</p><h2 id="组合-Futures"><a href="#组合-Futures" class="headerlink" title="组合 Futures"></a>组合 Futures</h2><p>CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。</p><p>这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。</p><p>CompletableFuture 提供了方法 <code>thenCompose()</code> 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。</p><p>例如下面这个示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;简单&quot;</span>)</span><br><span class="line">    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;教程&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;云遇未晚&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p><code>thenCompose()</code> 方法与 <code>thenApply()</code> 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。</p><p>两个方法都接收一个函数并将其应用于计算结果，但 <code>thenCompose()</code> （ <code>flatMap()</code> ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。</p><p>如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 <code>thenCombine()</code> 并传递能够接收两个参数的函数或表达式来处理这两个结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line">      () -&gt; <span class="string">&quot; World&quot;</span>), (s1, s2) -&gt; s1 + s2));</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello World&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p>更简单的情况是，当你想要使用两个 Futures 的结果时，但有不想把任何结果值传递给 Future 链，则可以使用 <code>thenAcceptBoth()</code> 方法，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompletableFuture</span> <span class="variable">future</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">  .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot; World&quot;</span>),</span><br><span class="line">    (s1, s2) -&gt; System.out.println(s1 + s2));</span><br></pre></td></tr></table></figure><h2 id="并行执行多个-Future"><a href="#并行执行多个-Future" class="headerlink" title="并行执行多个 Future"></a>并行执行多个 Future</h2><p>当我们需要并行执行多个 Futures 时，通常是希望等待所有 Futures 执行完成然后处理它们的组合结果。</p><p><code>CompletableFuture.allOf()</code> 静态方法允许等待作为 var-arg 提供的所有 Future 的完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future2  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Beautiful&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future3  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; combinedFuture </span><br><span class="line">  = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">combinedFuture.get();</span><br><span class="line"></span><br><span class="line">assertTrue(future1.isDone());</span><br><span class="line">assertTrue(future2.isDone());</span><br><span class="line">assertTrue(future3.isDone());</span><br></pre></td></tr></table></figure><blockquote><p>var-arg 的意思是：参数数量不定的意思。也就是可以传递任意相同类型的参数。</p></blockquote><p>上面的示例中，你应该留意到了 <code>CompletableFuture.allOf()</code> 方法的返回类型是 <code>CompletableFuture &lt;Void&gt;</code>，这个方法的局限是它不会返回所有 Future 的综合结果。相反，你必须手动从 Futures 获取结果。幸运的是，<code>CompletableFuture.join()</code> 方法和 Java 8 Streams API 可以做到这一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">combined</span> <span class="operator">=</span> Stream.of(future1, future2, future3)</span><br><span class="line">  .map(CompletableFuture::join)</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello Beautiful World&quot;</span>, combined);</span><br></pre></td></tr></table></figure><p><code>CompletableFuture.join()</code> 方法类似于 <code>get()</code> 方法，但是如果 Future 未正常完成，它会抛出未经检查的异常，这种机制，使得它可以作为 <code>Stream.map()</code> 的参数。</p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>对于异步计算步骤链中的错误处理，惯用的方法是调整 <code>throw/catch</code> 。</p><p>怎么个调整法呢 ？</p><p>CompletableFuture 类允许我们在特殊的 <code>handle()</code> 方法中处理它，而不是在语法块中捕获异常。</p><p>此 <code>handle()</code> 方法接收接收两个参数：计算结果（ 如果成功完成 ）和抛出异常（ 如果某些计算步骤未正常完成 ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">  &#125;)&#125;).handle((s, t) -&gt; s != <span class="literal">null</span> ? s : <span class="string">&quot;Hello, Stranger!&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello, Stranger!&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p>上面这个示例中，我们使用 <code>handle()</code> 方法在问候语的异步计算完成时提供默认值，因为没有提供 <code>name</code> 。</p><p>作为替代方案，假设我们想要手动使用某个值完成 Future ，就像第一个示例中所示，但同时又需要有能力通过异常完成它。那么，可以使用 <code>completeExceptionally()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">completableFuture.completeExceptionally(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Calculation failed!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">completableFuture.get(); <span class="comment">// ExecutionException</span></span><br></pre></td></tr></table></figure><p>上面这个示例的 <code>completableFuture.get()</code> 方法会抛出 <code>ExecutionException</code>，并使用<code>RuntimeException</code> 作为异常发生的原因。</p><p>在上面的例子中，我们也可以使用 <code>handle()</code> 方法异步处理异常，但使用 <code>get()</code> 方法是更典型的同步异常处理机制。</p><h2 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h2><p>CompletableFuture 类中的大多数流式 API 方法都又两个带有 <code>Async</code> 后缀的变体。这些变体方法通常用于在另一个线程中运行相应的执行步骤。</p><ul><li>没有 <code>Async</code> 后缀的方法使用当前调用线程运行下一个执行阶段。</li><li>不带 Executor 参数的 Async 后缀方法使用 <code>ForkJoinPool.commonPool()</code> 方法访问 Executor 的公共 fork/join 线程池实现运行一个步骤。</li><li>带有 Executor 参数的 Async 后缀方法使用传递的 Executor 运行一个步骤。</li></ul><p>下面这个范例中，我们使用了 Function 实例处理计算结果。和之前范例的唯一可见的区别就是 <code>thenApplyAsync()</code> 方法。但在幕后，函数的应用程序被包装到 ForkJoinTask 实例中（ 有关 fork/join 框架的更多信息，请阅读我们的 一文秒懂 Java Fork/Join ），这样可以进一步并行化我们的计算并更有效地使用系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class="line">  .thenApplyAsync(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello World&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><h2 id="Java-9-CompletableFuture-新增的-API"><a href="#Java-9-CompletableFuture-新增的-API" class="headerlink" title="Java 9 CompletableFuture 新增的 API"></a>Java 9 CompletableFuture 新增的 API</h2><p>Java 9 提供了一下变更进一步强化了 CompletableFuture：</p><ul><li>添加了新的工厂方法</li><li>支持延时和超时</li><li>改进了对子类化的支持</li></ul><p>Java 9 同时也引入了新的 CompletableFuture 实例 API</p><ul><li>Executor defaultExecutor()</li><li>CompletableFuture newIncompleteFuture()</li><li>CompletableFuture copy()CompletionStage minimalCompletionStage()</li><li>CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)C</li><li>ompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier)</li><li>CompletableFuture orTimeout(long timeout, TimeUnit unit)</li><li>CompletableFuture completeOnTimeout(T value, long timeout, TimeUnit unit)</li></ul><p>还添加了一些静态的使用方法</p><ul><li>Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)</li><li>Executor delayedExecutor(long delay, TimeUnit unit)</li><li>CompletionStage completedStage(U value)</li><li>CompletionStage failedStage(Throwable ex)</li><li>CompletableFuture failedFuture(Throwable ex)</li></ul><p>最后，为了解决超时问题，Java 9 引入了另外两个新功能</p><ul><li><code>orTimeout()</code></li><li><code>completeOnTimeout()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、Java并发 Java CompletableFuture ( 上 )</title>
      <link href="/posts/1e640cc2.html"/>
      <url>/posts/1e640cc2.html</url>
      
        <content type="html"><![CDATA[<h1 id="八、Java并发-Java-CompletableFuture-上"><a href="#八、Java并发-Java-CompletableFuture-上" class="headerlink" title="八、Java并发 Java CompletableFuture ( 上 )"></a>八、Java并发 Java CompletableFuture ( 上 )</h1><p>本文我们来了解下 Java 8 引入的 CompletableFuture 类，了解下该类提供的功能和用例。</p><h2 id="Java-中的异步计算"><a href="#Java-中的异步计算" class="headerlink" title="Java 中的异步计算"></a>Java 中的异步计算</h2><p>异步计算很难推理的，因为我们的大脑是同步的，会将任何计算看成是一系列的同步计算。</p><p>我们在实现异步计算时，往往会把回调的动作分散在代码中或者深深地嵌套在彼此内部，这种情况下，当我们需要处理其中一个步骤中可能发生的错误时，情况变得更糟。</p><p>人生的一大悲剧是，尽管 Java 5 已经看到了这种恶性循环，提供了<code>Future</code> 接口作为异步计算的结果，但它没有提供任何方法来组合这些计算或处理可能的错误。</p><p>直到 Java 8，才引入了 CompletableFuture 类。该类不仅实现了 <code>Future</code> 接口，还实现了 <code>CompletionStage</code> 接口。此接口定义了可与异步计算步骤组合的异步计算步骤契约。</p><p>官方文档真是拗口，简单来说，<code>CompletionStage</code> 接口规范了一个异步计算步骤如何与另一个异步计算步骤组合。</p><p>CompletableFuture 类还是一个集大成者，即是一个构建块，也是一个框架，提供了大约 50 种不同的方法来构造，组合，执行异步计算步骤和处理错误。</p><p>API 数量如此之多，第一眼看到简直就傻眼了，不过好在它们可以分门别类，因为它们大多属于几个明确且不同的用例。</p><h2 id="将-CompletableFuture-当作简单的-Future-使用"><a href="#将-CompletableFuture-当作简单的-Future-使用" class="headerlink" title="将 CompletableFuture 当作简单的 Future 使用"></a>将 CompletableFuture 当作简单的 Future 使用</h2><p>为什么可以 ？</p><p>因为 CompletableFuture 类实现了 Future 接口，因此我们可以将其用作 Future 实现，但需要自己实现额外的完成逻辑。</p><p>例如，我们可以使用无任何参数的构造函数来创建此类的实例，用于表示未来的某些结果，然后将其交给使用者，并在将来的某个时间调用 <code>complete()</code> 方法完成。消费者可以使用 <code>get()</code> 方法来阻止当前线程，直到提供此结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">calculateAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">      = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        completableFuture.complete(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例中，我们创建了一个创建 <code>CompletableFuture</code> 实例的方法，把计算分离到另一个线程中并立即返回 Future。当计算完成后，该方法通过将结果提供给 <code>complete()</code> 方法来完成 Future。</p><p>为了分离计算，我们使用了前几章节 一文秒懂 Java 线程池 ( Thread Pool ) （上） 中提到的 Executor API。这种创建和完成 CompletableFuture 的方法可以与任何并发机制或 API（ 包括原始线程 ）一起使用。</p><p>请注意，calculateAsync() 方法返回 Future 实例。</p><p>接下来，我们只要调用此方法，接收 Future 实例并在我们准备阻塞结果时调用它的 get() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = calculateAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> completableFuture.get();</span><br><span class="line">assertEquals(<span class="string">&quot;Hello&quot;</span>, result);</span><br></pre></td></tr></table></figure><p>注意: <code>get()</code> 方法会抛出一些已检查的异常，即 <code>ExecutionException</code>（ 封装计算期间发生的异常 ）和 <code>InterruptedException</code>（ 表示执行方法的线程被中断的异常 )。</p><p>如果你已经知道计算的结果，可以将表示此计算的结果作为参数传递给 <code>completedFuture()</code> 静态方法，这样，Future 的 get() 方法永远不会阻塞，而是立即返回此结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = </span><br><span class="line">  CompletableFuture.completedFuture(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> completableFuture.get();</span><br><span class="line">assertEquals(<span class="string">&quot;Hello&quot;</span>, result);</span><br></pre></td></tr></table></figure><p>当然了，有时候，你可能希望取消 Future 的执行。</p><p>假设我们没有找到结果并决定完全取消异步执行，这可以通过调用 Future 的 cancel() 方法完成。此方法接收一个布尔参数 <code>mayInterruptIfRunning</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">calculateAsyncWithCancellation</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        completableFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个异步方法的修改版本的范例中，当我们使用 <code>Future.get()</code> 方法阻塞结果时，如果 future 取消了，那么将抛出CancellationException 异常。</p><p>但是，在类型为 CompletableFuture 的情况下，cancel() 方法没有任何效果，因为 CompletableFuture 并不会响应中断也不会处理中断。</p><h2 id="用于封装计算逻辑的-CompletableFuture"><a href="#用于封装计算逻辑的-CompletableFuture" class="headerlink" title="用于封装计算逻辑的 CompletableFuture"></a>用于封装计算逻辑的 CompletableFuture</h2><p>上面讲解的这些代码，都允许我们选择任何并发执行机制，但是，如果我们想跳过这个样板代码并简单地异步执行一些代码呢？</p><p><code>CompletableFuture</code> 的静态方法 <code>runAsync()</code> 和 <code>supplyAsync()</code> 允许我们从 Runnable 和 Supplier 中创建 CompletableFuture 实例。 Runnable 和 Supplier 都是功能接口，由 Java 8 的新功能，可以将它们的实例作为lambda 表达式传递：</p><ul><li>Runnable 接口与线程中使用的旧接口相同，不允许返回值</li><li>Supplier 接口是一个通用的功能接口，只有一个没有参数的方法，并返回一个参数化类型的值</li></ul><p>下面的代码演示了如何将 Supplier 的实例作为 lambda 表达式参数，该表达式执行计算并返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><h2 id="处理异步计算的结果"><a href="#处理异步计算的结果" class="headerlink" title="处理异步计算的结果"></a>处理异步计算的结果</h2><p>处理计算结果的最通用方法是将其提供给函数。<code>CompletableFuture.thenApply()</code> 方法就是这样做的： <strong>接受一个 Function 实例，用它来处理结果并返回一个用于保存函数返回的值 Future</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class="line">  .thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello World&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p>如果你不需要在 Future 链中返回值，则可以使用 Consumer 功能接口的实例。它只有一个方法，该方法接受一个参数并返回 void。而相应的，CompletableFuture 也提供了一个使用 Consumer 实例的方法 <code>thenAccept()</code> 。该方法接收一个 Consumer 并将其传递给计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class="line">  .thenAccept(s -&gt; System.out.println(<span class="string">&quot;Computation returned: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><p>上面这个示例中，最后的 <code>future.get()</code> 方法会返回空值 <code>Void</code> 。</p><p>最后，如果你既不需要计算的值也不想在链的末尾返回一些值，那么你可以将 <code>Runnable</code> lambda 传递给 <code>thenRun()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class="line">  .thenRun(() -&gt; System.out.println(<span class="string">&quot;计算完成&quot;</span>));</span><br><span class="line"></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><p>上面这个示例中，调用 <code>future.get()</code> 方法之后会在控制台打印一行 <code>计算完成</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、Java并发 Java Google Guava 实现</title>
      <link href="/posts/cb5d7b3f.html"/>
      <url>/posts/cb5d7b3f.html</url>
      
        <content type="html"><![CDATA[<h1 id="七、Java并发-Java-Google-Guava-实现"><a href="#七、Java并发-Java-Google-Guava-实现" class="headerlink" title="七、Java并发 Java Google Guava 实现"></a>七、Java并发 Java Google Guava 实现</h1><p><a href="https://github.com/google/guava">Guava</a> 是托管在 <a href="https://github.com/">Github.com</a> 上的流行的 Google 开源的 Java 线程池库。</p><p>Guava 包含了许多有用的并发类，同时还包含了几个方便的 <code>ExecutorService</code> 实现，但这些实现类都无法通过直接实例化或子类化来创建实例。取而代之的是提供了 MoreExecutors 助手类来创建它们的实例。</p><h2 id="给-Maven-添加-Guava-依赖"><a href="#给-Maven-添加-Guava-依赖" class="headerlink" title="给 Maven 添加 Guava 依赖"></a>给 Maven 添加 Guava 依赖</h2><p>为了将 Google Guava 库包含进当前的项目中，需要将下面的依赖项添加到 Maven pom 文件中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>26.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在 [Maven 中央仓库](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.guava&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.guava&quot;</a> AND a%3A”guava”) 中找到最新版本的 Guava 库</p><h2 id="直接执行者和直接执行者服务"><a href="#直接执行者和直接执行者服务" class="headerlink" title="直接执行者和直接执行者服务"></a>直接执行者和直接执行者服务</h2><p>有时候，我们希望在当前线程或线程池中执行任务，具体在哪里取决于某些条件。这种情况下，你应该会更喜欢使用单个 Executor 接口，且只需切换实现即可。</p><p>虽然将当前线程中的任务的 Executor 或 ExecutorService 的提取出来单独实现并不困难，但它仍然需要编写一些样板代码。</p><p>值得庆幸的是，Guava 为我们提供了预定义的实例。</p><p>下面的范例演示了如何在同一个线程中执行任务。简单起见，提交的任务会将当前线程休眠 500 毫秒并阻塞当前线程，并在执行的调用完成后让结果立即可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> MoreExecutors.directExecutor();</span><br><span class="line"></span><br><span class="line"><span class="type">AtomicBoolean</span> <span class="variable">executed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executed.set(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assertTrue(executed.get());</span><br></pre></td></tr></table></figure><p><code>directExecutor()</code> 方法返回的实例实际上是一个静态单例，因此使用此方法根本不会在对象创建上带来任何开销。</p><p>你应该更喜欢使用此方法来访问 <code>MoreExecutors.newDirectExecutorService()</code>，因为该 API 会在每次调用时创建完整的执行程序服务实现。</p><h2 id="退出-Executor-服务"><a href="#退出-Executor-服务" class="headerlink" title="退出 Executor 服务"></a>退出 Executor 服务</h2><p>另一个常见问题是： <strong>在线程池仍在运行其任务时关闭虚拟机</strong>。即使采用了取消机制，也无法保证任务执行良好，并在执行程序服务 （ Executor ）关闭时停止工作。这可能会导致 JVM 在任务继续工作时无限期挂起。</p><p>为了解决这个问题，Guava 引入了一系列已经实例化好的执行器 （ Executor ） 服务。它们是守护线程模式，但会与 JVM 一起终止。</p><p>这些执行器服务还提供了 <code>Runtime.getRuntime().addShutdownHook()</code> 方法用于添加一个关闭钩子，用于设置 VM 在放弃挂起的任务之前等待一段预配置的超时时间。</p><p>下面的示例中，我们提交了一个无限循环的任务，我们使用了包含 100 毫秒超时时间的已经存在的执行程序服务来运行任务，并在超过配置的超时时间之后终止 VM 。如果没有 exitingExecutorService ，此任务将导致 VM 无限期挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> </span><br><span class="line">  (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> </span><br><span class="line">  MoreExecutors.getExitingExecutorService(executor, </span><br><span class="line">    <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="监听装饰器"><a href="#监听装饰器" class="headerlink" title="监听装饰器"></a>监听装饰器</h2><p>监听装饰器允许我们封装 ExecutorService 并在提交任务时返回 ListenableFuture 实例而不是简简单单的 Future 实例。</p><p>ListenableFuture 接口扩展自 Future 接口，并添加了一个新方法 <code>addListener()</code>，该方法用于添加在将来完成时调用的侦听器。</p><p>一般情况下，我们很少直接使用 <code>ListenableFuture.addListener()</code> 方法，而是使用 Futures 类提供的许多辅助方法。例如，通过<code>Futures.allAsList()</code> 方法，我们可以在单个 ListenableFuture 中组合多个 ListenableFuture 实例，并会在这些实例在成功完成后将所有的 futures 合并并返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">listeningExecutorService</span> <span class="operator">=</span> </span><br><span class="line">  MoreExecutors.listeningDecorator(executorService);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;String&gt; future1 = </span><br><span class="line">  listeningExecutorService.submit(() -&gt; <span class="string">&quot;java&quot;</span>);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = </span><br><span class="line">  listeningExecutorService.submit(() -&gt; <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> Futures.allAsList(future1, future2).get()</span><br><span class="line">  .stream()</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot;&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;云遇未晚&quot;</span>, greeting);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
            <tag> Guava </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、Java并发 Java ForkJoinPool</title>
      <link href="/posts/b57a6e2b.html"/>
      <url>/posts/b57a6e2b.html</url>
      
        <content type="html"><![CDATA[<h1 id="六、Java并发-Java-ForkJoinPool"><a href="#六、Java并发-Java-ForkJoinPool" class="headerlink" title="六、Java并发 Java ForkJoinPool"></a>六、Java并发 Java ForkJoinPool</h1><p>ForkJoinPool 是Java 7 中引入的 fork/join 框架的核心之一。它解决了一个常见的问题： 如何在递归中生成多个任务。因为，即使是使用一个简单的 <code>ThreadPoolExecutor</code> ，也会在不断的递归中快速耗尽线程。因为每个任务或子任务都需要自己的线程来运行。</p><p>在 fork/join 框架中，任何任务都可以生成 ( fork ) 多个子任务并使用 <code>join()</code> 方法等待它们的完成。fork/join 框架的好处是它不会为每个任务或子任务创建新线程，而是实现了 <strong>工作窃取</strong> ( Work Stealing ) 算法。关于 fork/join 框架的详细信息，你可以访问我们的 一文秒懂 Java Fork/Join。</p><p>接下来，我们看一个使用 <code>ForkJoinPool</code> 遍历节点树并计算所有叶值之和的简单示例。在这个示例中，树是一个由节点，int 值和一组子节点组成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Set&lt;TreeNode&gt; children;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> value, TreeNode... children) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.children = Sets.newHashSet(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了树 <code>TreeNode</code> 之后，如果我们想要并行地对树中的所有值求和，我们需要实现一个 <code>RecursiveTask&lt;Integer&gt;</code> 接口。每个任务都接收自己的节点，并将其值添加到其子节点的值之和上。</p><p>要计算子节点值的总和，任务实现执行以下操作</p><p>1、 将子节点集合转换为流 ( stream )<br>2、 映射前面操作中创建的流，为每个元素创建一个新的 CountingTask<br>3、 通过 <code>fork</code> 执行每个子任务<br>4、 通过在每个 <code>fork</code> 任务上调用 <code>join()</code> 方法来收集结果<br>5、 使用 ·Collectors.summingInt` 收集器对结果求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CountingTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountingTask</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.value + node.children.stream()</span><br><span class="line">          .map(childNode -&gt; <span class="keyword">new</span> <span class="title class_">CountingTask</span>(childNode).fork())</span><br><span class="line">          .collect(Collectors.summingInt(ForkJoinTask::join));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在树上运行计算的代码非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> forkJoinPool.invoke(<span class="keyword">new</span> <span class="title class_">CountingTask</span>(tree));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
            <tag> forkJoinPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、Java并发 ScheduledThreadPoolExecutor</title>
      <link href="/posts/5975178e.html"/>
      <url>/posts/5975178e.html</url>
      
        <content type="html"><![CDATA[<h1 id="五、Java并发-ScheduledThreadPoolExecutor"><a href="#五、Java并发-ScheduledThreadPoolExecutor" class="headerlink" title="五、Java并发 ScheduledThreadPoolExecutor"></a>五、Java并发 ScheduledThreadPoolExecutor</h1><p><code>ScheduledThreadPoolExecutor</code> 扩展自 一文秒懂 Java 线程池之 ThreadPoolExecutor 讲解的 <code>了ThreadPoolExecutor</code> 类，并且添加了其它方法实现了 <code>ScheduledExecutorService</code> 接口。</p><ul><li><code>schedule()</code> 方法允许在指定的延迟后执行一次任务</li><li><code>scheduleAtFixedRate()</code> 方法允许在指定的初始延迟后执行任务，然后以一定的周期重复执行，其中 <code>period</code> 参数用于指定两个任务的开始时间之间的间隔时间，因此任务执行的频率是固定的。</li><li><code>scheduleWithFixedDelay()</code> 方法类似于 <code>scheduleAtFixedRate()</code> ，它也重复执行给定的任务，但<code>period</code> 参数用于指定前一个任务的结束和下一个任务的开始之间的间隔时间。也就是指定下一个任务延时多久后才执行。执行频率可能会有所不同，具体取决于执行任何给定任务所需的时间。</li></ul><p>静态方法 <code>Executors.newScheduledThreadPool()</code> 方法用于创建包含了指定 <code>corePoolSize</code>，无上限 <code>maximumPoolSize</code> 和 <code>0</code> 存活时间 <code>keepAliveTime</code> 的 <code>ScheduledThreadPoolExecutor</code> 实例。</p><p>例如下面的示例创建了一个包含了 5 个核心线程的 <code>ScheduledThreadPoolExecutor</code> 实例，且每隔 500 毫秒运行一个输出 <code>Hello World</code> 的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h2 id="范例-2"><a href="#范例-2" class="headerlink" title="范例 2"></a>范例 2</h2><p>下面的代码则演示了如何在 500 毫秒延迟后执行任务，然后每 100 毫秒重复执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    lock.countDown();</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">lock.await(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、Java并发 Java 线程池之 ThreadPoolExecutor</title>
      <link href="/posts/f6cd6d86.html"/>
      <url>/posts/f6cd6d86.html</url>
      
        <content type="html"><![CDATA[<h1 id="四、Java并发-Java-线程池之-ThreadPoolExecutor"><a href="#四、Java并发-Java-线程池之-ThreadPoolExecutor" class="headerlink" title="四、Java并发 Java 线程池之 ThreadPoolExecutor"></a>四、Java并发 Java 线程池之 ThreadPoolExecutor</h1><p>因为上一章节篇幅有限，所以我决定把 <strong>一文秒懂 Java 线程池</strong> 拆分为三篇文章单独介绍。本章节，我们就来看看 <code>ThreadPoolExecutor</code> 。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code> 是一个可被继承 ( extends ) 的线程池实现，包含了用于微调的许多参数和钩子。</p><p>我们并不会讨论 ThreadPoolExecutor 类中的所有的参数和钩子，只会讨论几个主要的配置参数：</p><ol><li> `corePoolSize``</li><li>``maximumPoolSize`</li><li> <code>keepAliveTime</code></li></ol><p>ThreadPoolExecutor 创建的线程池由固定数量的核心线程组成，这些线程在 ThreadPoolExecutor 生命周期内始终存在，除此之外还有一些额外的线程可能会被创建，并会在不需要时主动销毁。<code>corePoolSize</code> 参数用于指定在线程池中实例化并保留的核心线程数。如果所有核心线程都忙，并且提交了更多任务，则允许线程池增长到 <code>maximumPoolSize</code> 。</p><p><code>keepAliveTime</code> 参数是额外的线程（ 即，实例化超过 corePoolSize 的线程 ）在空闲状态下的存活时间。</p><p>这三个参数涵盖了广泛的使用场景，但最典型的配置是在 Executors 静态方法中预定义的。</p><h3 id="Executors-newFixedThreadPool"><a href="#Executors-newFixedThreadPool" class="headerlink" title="Executors.newFixedThreadPool()"></a>Executors.newFixedThreadPool()</h3><p>例如，<code>Executors.newFixedThreadPool()</code> 静态方法创建了一个 <code>ThreadPoolExecutor</code> ，它的参数 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都是相等的，且参数 <code>keepAliveTime</code> 始终为 <code>0</code> ，也就意味着此线程池中的线程数始终相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> </span><br><span class="line">  (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">2</span>, executor.getPoolSize());</span><br><span class="line">assertEquals(<span class="number">1</span>, executor.getQueue().size());</span><br></pre></td></tr></table></figure><p>上面这个示例中，我们实例化了一个固定线程数为 <code>2</code> 的 <code>ThreadPoolExecutor</code>。这意味着如果同时运行的任务的数量始终小于或等于 2 ，那么这些任务会立即执行。否则，其中一些任务可能会被放入队列中等待轮到它们。</p><p>上面这个示例中，我们创建了三个 <code>Callable</code> 任务，通过睡眠模拟 1000 毫秒的繁重工作。前两个任务将立即执行，第三个任务必须在队列中等待。我们可以通过在提交任务后立即调用 <code>getPoolSize()</code> 和 <code>getQueue().size()</code> 来方法来验证。</p><h3 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h3><p><code>Executors</code> 还提供了 <code>Executors.newCachedThreadPool()</code> 静态方法创建另一个预配置的 <code>ThreadPoolExecutor</code>。该方法创建的线程池没有任何核心线程，因为它将 <code>corePoolSize</code> 属性设置为 <code>0</code>，但同时有可以创建最大数量的额外线程，因为它将 <code>maximumPoolSize</code> 设置为 <code>Integer.MAX_VALUE</code> ，且将 <code>keepAliveTime</code> 的值设置为 <code>60</code> 秒。</p><p>这些参数值意味着缓存的线程池可以无限制地增长以容纳任何数量的已提交任务。但是，当不再需要线程时，它们将在 60秒不活动后被销毁。这种线程池的使用场景一般是你的应用程序中有很多短期任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> </span><br><span class="line">  (ThreadPoolExecutor) Executors.newCachedThreadPool();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">3</span>, executor.getPoolSize());</span><br><span class="line">assertEquals(<span class="number">0</span>, executor.getQueue().size());</span><br></pre></td></tr></table></figure><p>上面这个示例中的队列大小始终为 <code>0</code> ，因为在内部使用了 <code>SynchronousQueue</code> 的实例。在 <code>SynchronousQueue</code> 中，插入和删除操作总是成对出现且同时发生。因此队列实际上从不包含任何内容。</p><h3 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h3><p><code>Executors.newSingleThreadExecutor()</code> 静态方法则创建另一种典型的只包含单个线程的 <code>ThreadPoolExecutor</code> 实例。</p><p>这种单线程执行程序是创建事件循环的理想选择。</p><p>在这个单线程 <code>ThreadPoolExecutor</code> 实例中，属性 <code>corePoolSize</code> 和属性 <code>maximumPoolSize</code> 的值都为 <code>1</code>，而属性 <code>keepAliveTime</code> 的值为 <code>0</code> 。</p><p>在单线程 <code>ThreadPoolExecutor</code> 实例中，所有的任务都按顺序执行。因此，下面的示例中，任务完成后标志的值是 <code>2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.set(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此外，单线程 <code>ThreadPoolExecutor</code> 实例使用了不可变包装器进行修饰，因此在创建后无法重新配置。当然了，这也是我们无法将该示例强制转换为 <code>ThreadPoolExecutor</code> 的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、Java并发 Java 线程池 ( Thread Pool )</title>
      <link href="/posts/bd483eb7.html"/>
      <url>/posts/bd483eb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="三、Java并发-Java-线程池-Thread-Pool"><a href="#三、Java并发-Java-线程池-Thread-Pool" class="headerlink" title="三、Java并发 Java 线程池 ( Thread Pool )"></a>三、Java并发 Java 线程池 ( Thread Pool )</h1><p>本文我们将讲解 Java 中的线程池 ( Thread Pool )，从 Java 标准库中的线程池的不同实现开始，到 Google 开发的 Guava 库的前世今生。</p><blockquote><p>本章节涉及到很多前几个章节中阐述的知识点。我们希望你是按照顺序阅读下来的，不然有些知识会一头雾水。</p></blockquote><p>Java 语言的实现中，把 Java 线程一一映射到操作系统级的线程，而后者是操作系统的资源，这意味着，如果开发者毫无节制地创建线程，那么线程资源就会被快速的耗尽。</p><blockquote><p>在 Windows 操作系统上，每个线程要预留出 1m 的内存空间，意味着 2G 的内存理论上做多只能创建 2048 个线程。而在 Linux 上，最大线程数由常量 <code>PTHREAD_THREADS_MAX</code> 决定，一般为 1024。</p></blockquote><p>出于模拟并行性的目的，Java 线程之间的上下文切换也由操作系统完成。因为线程上下文切换需要消耗时间，所以，一个简单的观点是：产生的线程越多，每个线程花在实际工作上的时间就越少。</p><blockquote><p>为什么会有线程上下文切换？</p><p>一台电脑，运行起来后，它的 CPU 是固定的，05 年之前，还是单核时代，也就是一次只能运行一个线程，虽然随着时间的推移，现在的 CPU 已经有很多个核心，比如 8 核 16 核之类的。但相比于一个应用程序能够创建的线程数，那真的是太少了。而每个核心一次只能运行一个线程，所以多个线程需要运行时就需要来回不停的在多个线程间切换，这就是线程之间的上下文切换。</p></blockquote><p>为了节制创建线程的数量，也为了节省创建线程的开销，因此提出了线程池的概念。线程池模式有助于节省多线程应用程序中的资源，还可以在某些预定义的限制内包含并行性。</p><p>当我们使用线程池时，我们可以以并行任务的形式编写并发代码并将其提交到线程池的实例中执行。</p><p>这个线程池实例控制了多个重用线程以执行这些任务。</p><p><img src="https://s3.uuu.ovh/imgs/2022/05/04/4e8bcdf1df3e7006.png" alt="img_1.png"></p><p>这种线程池模式，允许我们控制应用程序创建的线程数，生命周期，以及计划任务的执行并将传入的任务保留在队列中。</p><h2 id="Java-中的线程池"><a href="#Java-中的线程池" class="headerlink" title="Java 中的线程池"></a>Java 中的线程池</h2><h3 id="Executors、Executor-和-ExecutorService"><a href="#Executors、Executor-和-ExecutorService" class="headerlink" title="Executors、Executor 和 ExecutorService"></a>Executors、Executor 和 ExecutorService</h3><p><code>Executors</code> 是一个帮助类，提供了创建几种预配置线程池实例的方法。如果你不需要应用任何自定义的微调，可以调用这些方法创建默认配置的线程池，因为它能节省很多时间和代码。</p><p><code>Executor</code> 和 <code>ExecutorService</code> 接口则用于与 Java 中不同线程池的实现协同工作。通常，你应该将代码与线程池的实际实现分离，并在整个应用程序中使用这些接口。</p><p>Executor 接口提供了一个 <code>execute()</code> 方法将 Runnable 实例提交到线程池中执行。</p><p>下面的代码是一个快速示例，演示了如何使用 Executors API 获取包含了单个线程池和无限队列支持的 Executor 实例，以便按顺序执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>获取了 <code>Executor</code> 示例后，我们就可以使用 <code>execute()</code> 方法将一个只在屏幕上打印 <code>Hello World</code> 的任务提交到队列中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>));</span><br></pre></td></tr></table></figure><p>上面这个示例使用了 lambda （ Java 8特性 ）提交任务，JVM 会自动推断该任务为 <code>Runnable</code></p><p>我们在 Java Shell 演示下上面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; <span class="keyword">import</span> java.util.concurrent.*</span><br><span class="line"></span><br><span class="line">jshell&gt; <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor ==&gt; java.util.concurrent.Executors$FinalizableDelegatedExecutorService@<span class="number">1e127982</span></span><br><span class="line"></span><br><span class="line">jshell&gt; executor.execute(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"></span><br><span class="line">jshell&gt; Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jshell&gt; </span><br></pre></td></tr></table></figure><p><code>ExecutorService</code> 接口则包含大量用于控制任务进度和管理服务终止的方法。我们可以使用此接口来提交要执行的任务，还可以使用此接口返回的 Future 实例控制任务的执行。</p><p>下面的示例中，我们创建了一个 ExecutorService 的实例，提交了一个任务，然后使用返回的 Future 的 get() 方法等待提交的任务完成并返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(() -&gt; <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="comment">// 一些其它操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br></pre></td></tr></table></figure><p>在实际使用时，我们并不会立即调用 <code>future.get()</code> 方法，可能会等待一些时间，推迟调用它直到我们需要它的值用于计算等目的。</p><p><code>ExecutorService</code> 中的 <code>submit()</code> 方法被重载为支持 <code>Runnable</code> 或 <code>Callable</code> ，它们都是功能接口，可以接收一个 lambdas 作为参数（ 从 Java 8 开始 ）：</p><ul><li>使用 Runnable 作为参数的方法不会抛出异常也不会返回任何值 ( 返回 <code>void</code> )</li><li>使用 Callable 作为参数的方法则可以抛出异常也可以返回值。</li></ul><p>如果想让编译器将参数推断为 Callable 类型，只需要 lambda 返回一个值即可。</p><p><code>ExecutorService</code> 接口的更多使用范例和特性，你可以访问前面的章节 一文秒懂 Java ExecutorService。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Java并发 Java Fork-Join</title>
      <link href="/posts/4a515c30.html"/>
      <url>/posts/4a515c30.html</url>
      
        <content type="html"><![CDATA[<h1 id="二、Java并发-Java-Fork-Join"><a href="#二、Java并发-Java-Fork-Join" class="headerlink" title="二、Java并发 Java Fork-Join"></a>二、Java并发 Java Fork-Join</h1><p>fork/join 框架是 Java 7 中引入的 ，它是一个工具，通过 「 分而治之 」 的方法尝试将所有可用的处理器内核使用起来帮助加速并行处理。</p><p>在实际使用过程中，这种 「 分而治之 」的方法意味着框架首先要 <code>fork</code> ，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。然后，<code>join</code> 部分开始工作，将所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待每个子任务执行完毕。</p><p>为了提供有效的并行执行，fork/join 框架使用了一个名为 <code>ForkJoinPool</code> 的线程池，用于管理 <code>ForkJoinWorkerThread</code> 类型的工作线程。</p><h2 id="ForkJoinPool-线程池"><a href="#ForkJoinPool-线程池" class="headerlink" title="ForkJoinPool 线程池"></a>ForkJoinPool 线程池</h2><p><code>ForkJoinPool</code> 是 fork/join 框架的核心，是 ExecutorService 的一个实现，用于管理工作线程，并提供了一些工具来帮助获取有关线程池状态和性能的信息。</p><p>工作线程一次只能执行一个任务。</p><p><code>ForkJoinPool</code> 线程池并不会为每个子任务创建一个单独的线程，相反，池中的每个线程都有自己的双端队列用于存储任务 （ double-ended queue ）( 或 deque，发音 <code>deck</code> ）。</p><p>这种架构使用了一种名为工作窃取（ work-stealing ）算法来平衡线程的工作负载。</p><h3 id="工作窃取（-work-stealing-）算法"><a href="#工作窃取（-work-stealing-）算法" class="headerlink" title="工作窃取（ work-stealing ）算法"></a>工作窃取（ work-stealing ）算法</h3><p>要怎么解释 「 工作窃取算法 」 呢 ？</p><p>简单来说，就是 <strong>空闲的线程试图从繁忙线程的 deques 中 *窃取* 工作</strong>。</p><p>默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方。</p><p>这种方法最大限度地减少了线程竞争任务的可能性。它还减少了工作线程寻找任务的次数，因为它首先在最大可用的工作块上工作。</p><h3 id="ForkJoinPool-线程池的实例化"><a href="#ForkJoinPool-线程池的实例化" class="headerlink" title="ForkJoinPool 线程池的实例化"></a>ForkJoinPool 线程池的实例化</h3><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h4><p>在 Java 8 中，创建 ForkJoinPool 实例的最简单的方式就是使用其静态方法 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--">commonPool()</a>。</p><p><code>commonPool()</code> 静态方法，见名思义，就是提供了对公共池的引用，公共池是每个 ForkJoinTask 的默认线程池。</p><p>根据 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">Oracle 的官方文档</a>，使用预定义的公共池可以减少资源消耗，因为它会阻止每个任务创建一个单独的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">commonPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br></pre></td></tr></table></figure><h4 id="Java-7"><a href="#Java-7" class="headerlink" title="Java 7"></a>Java 7</h4><p>如果要在 Java 7 中实现相同的行为，则需要通过创建 ForkJoinPool 的实例并将其赋值给实用程序类的公共静态字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>使用构造函数实例化 ForkJoinPool 时，可以创建具有指定级别的并行性，线程工厂和异常处理程序的自定义线程池。在上面的示例中，线程池的并行度级别为 2 ，意味着线程池将使用 2 个处理器核心。</p><p>然后就可以通过这个公共静态字段轻松的访问 ForkJoinPool 的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> PoolUtil.forkJoinPool;</span><br></pre></td></tr></table></figure><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p><code>ForkJoinTask</code> 是 <code>ForkJoinPool</code> 线程之中执行的任务的基本类型。我们日常使用时，一般不直接使用 <code>ForkJoinTask</code> ，而是扩展它的两个子类中的任意一个</p><p>1、任务不返回结果 ( 返回 <code>void</code> ） 的 <code>RecursiveAction</code><br>2、返回值的任务的 <code>RecursiveTask &lt;V&gt;</code></p><p>这两个类都有一个抽象方法 <code>compute()</code> ，用于定义任务的逻辑。</p><p>我们所要做的，就是继承任意一个类，然后实现 <code>compute()</code> 方法。</p><h3 id="RecursiveAction-使用示例"><a href="#RecursiveAction-使用示例" class="headerlink" title="RecursiveAction 使用示例"></a>RecursiveAction 使用示例</h3><p>出于演示目的，示例当然是尽可能的简单，因此，我们的示例，执行了一个比较荒谬的任务：将输入转为大写并记录。</p><p>所有的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRecursiveAction</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">workload</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> </span><br><span class="line">      Logger.getAnonymousLogger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRecursiveAction</span><span class="params">(String workload)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workload = workload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workload.length() &gt; THRESHOLD) &#123;</span><br><span class="line">            ForkJoinTask.invokeAll(createSubtasks());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           processing(workload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;CustomRecursiveAction&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CustomRecursiveAction&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">partOne</span> <span class="operator">=</span> workload.substring(<span class="number">0</span>, workload.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">partTwo</span> <span class="operator">=</span> workload.substring(workload.length() / <span class="number">2</span>, workload.length());</span><br><span class="line"></span><br><span class="line">        subtasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveAction</span>(partOne));</span><br><span class="line">        subtasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveAction</span>(partTwo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subtasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processing</span><span class="params">(String work)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> work.toUpperCase();</span><br><span class="line">        logger.info(<span class="string">&quot;This result - (&quot;</span> + result + <span class="string">&quot;) - was processed by &quot;</span></span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了一个字符串类型 ( String ) 的名为 <code>workload</code> 属性来表示要处理的工作单元。</p><p>同时，为了演示 fork/join 框架的 fork 行为，在该示例中，如果 <code>workload.length()</code> 大于指定的阈值，那么就使用 <code>createSubtask()</code> 方法拆分任务。</p><p>在 <code>createSubtasks()</code> 方法中，输入的字符串被递归地划分为子串，然后创建基于这些子串的 <code>CustomRecursiveTask</code> 实例。</p><p>当递归分割字符串完毕时，<code>createSubtasks()</code> 方法返回 <code>List&lt;CustomRecursiveAction&gt;</code> 作为结果。</p><p>然后在 <code>compute()</code> 方法中使用 <code>invokeAll()</code> 方法将任务列表提交给 <code>ForkJoinPool</code> 线程池。</p><p>我们来总结下创建 RecursiveAction 的步骤：</p><p>1、创建一个表示工作总量的对象<br>2、选择合适的阈值<br>3、定义分割工作的方法<br>4、定义执行工作的方法</p><p>类似的，我们可以使用相同的方式开发自己的 <code>RecursiveAction</code> 类。</p><h2 id="RecursiveTask-使用示例"><a href="#RecursiveTask-使用示例" class="headerlink" title="RecursiveTask 使用示例"></a>RecursiveTask 使用示例</h2><p>对于有返回值的任务，除了将每个子任务的结果在一个结果中合并，其它逻辑和 <code>RecursiveAction</code> 都差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRecursiveTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRecursiveTask</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> ForkJoinTask.invokeAll(createSubtasks())</span><br><span class="line">              .stream()</span><br><span class="line">              .mapToInt(ForkJoinTask::join)</span><br><span class="line">              .sum();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> processing(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;CustomRecursiveTask&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CustomRecursiveTask&gt; dividedTasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveTask</span>(</span><br><span class="line">          Arrays.copyOfRange(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>)));</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveTask</span>(</span><br><span class="line">          Arrays.copyOfRange(arr, arr.length / <span class="number">2</span>, arr.length)));</span><br><span class="line">        <span class="keyword">return</span> dividedTasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">processing</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(arr)</span><br><span class="line">          .filter(a -&gt; a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">27</span>)</span><br><span class="line">          .map(a -&gt; a * <span class="number">10</span>)</span><br><span class="line">          .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个示例中，任务由存储在 <code>CustomRecursiveTask</code> 类的 <code>arr</code> 字段中的数组表示。</p><p><code>createSubtask()</code> 方法递归地将任务划分为较小的工作，直到每个部分小于阈值。然后，<code>invokeAll()</code>方法将子任务提交给公共拉取并返回 Future 列表。</p><p>要触发执行，需要为每个子任务调用 <code>join()</code> 方法。</p><p>上面这个示例中，我们使用了 Java 8 的流 ( Stream ) API ， <code>sum()</code> 方法用于将子结果组合到最终结果中。</p><h2 id="将任务提交到-ForkJoinPool-线程池中"><a href="#将任务提交到-ForkJoinPool-线程池中" class="headerlink" title="将任务提交到 ForkJoinPool 线程池中"></a>将任务提交到 ForkJoinPool 线程池中</h2><p>只要使用很少的方法，就可以把任务提交到 ForkJoinPool 线程池中。</p><p>1、<code>submit()</code> 或 <code>execute()</code> 方法</p><p>这两个方法的调用方式是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forkJoinPool.execute(customRecursiveTask);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> customRecursiveTask.join();</span><br></pre></td></tr></table></figure><p>2、使用 <code>invoke()</code> 方法 <code>fork</code> 任务并等待结果，不需要任何手动连接 ( join )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.invoke(customRecursiveTask);</span><br></pre></td></tr></table></figure><p>3、<code>invokeAll()</code> 方法是将 ForkJoinTasks 序列提交给 ForkJoinPool 的最方便的方法。它将任务作为参数 ( 两个任务，var args 或集合 ），<code>fork</code> 它们，并按照生成它们的顺序返回 Future 对象的集合。<br>4、或者，我们还可以使用单独的 <code>fork()</code> 和 <code>join()</code> 方法。</p><ul><li><code>fork()</code> 方法将任务提交给线程池，但不会触发任务的执行。</li><li><code>join()</code> 方法则用于触发任务的执行。在 <code>RecursiveAction</code> 的情况下，join() 返回 null，但对于 <code>RecursiveTask&lt;V&gt;</code> ，它返回任务执行的结果。</li></ul><p>customRecursiveTaskFirst.fork(); result = customRecursiveTaskLast.join();</p><p>上面的 <code>RecursiveTask&lt;V&gt;</code> 示例中，我们使用 <code>invokeAll()</code> 方法向线程池提交一系列子任务。同样的工作，也可以使用 <code>fork()</code> 和 <code>join()</code> 来完成，但这可能会对结果的排序产生影响。</p><p>为了避免混淆，当涉及到多个任务且要保证任务的顺序时，通常都是使用 <code>ForkJoinPool.invokeAll()</code> 。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>使用 fork/join 框架可以加速处理大型任务，但要实现这一结果，应遵循一些指导原则：</p><ul><li>使用尽可能少的线程池。绝大多数情况下，最好的决定是每个应用程序或系统只使用一个线程池。 (是线程池而不是线程)。</li><li>当不需要任何调整时，使用默认的公共线程池。</li><li>使用合理的阈值。将 ForkJoingTask 任务拆分为子任务。</li><li>避免在 ForkJoingTasks 中出现任何阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
            <tag> 工具 </tag>
            
            <tag> forkJoinPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Java并发 Java ExecutorService</title>
      <link href="/posts/d5817b6f.html"/>
      <url>/posts/d5817b6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java并发-Java-ExecutorService"><a href="#一、Java并发-Java-ExecutorService" class="headerlink" title="一、Java并发 Java ExecutorService"></a>一、Java并发 Java ExecutorService</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> 是 Java <code>java.util.concurrent</code> 包的重要组成部分，是 Java JDK 提供的框架，用于简化异步模式下任务的执行。</p><p>一般来说，ExecutorService 会自动提供一个线程池和相关 API，用于为其分配任务。</p><h2 id="实例化-ExecutorService"><a href="#实例化-ExecutorService" class="headerlink" title="实例化 ExecutorService"></a>实例化 ExecutorService</h2><p>实例化 ExecutorService 的方式有两种：一种是工厂方法，另一种是直接创建。</p><h3 id="Executors-newFixedThreadPool-工厂方法创建-ExecutorService-实例"><a href="#Executors-newFixedThreadPool-工厂方法创建-ExecutorService-实例" class="headerlink" title="Executors.newFixedThreadPool() 工厂方法创建 ExecutorService 实例"></a><code>Executors.newFixedThreadPool()</code> 工厂方法创建 ExecutorService 实例</h3><p>创建 ExecutorService 实例的最简单方法是使用 <code>Executors</code> 类的提供的工厂方法。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当然还有其它很多工厂方法，每种工厂方法都可以创建满足特定用例的预定义 ExecutorService 实例。你所需要做的就是找到自己想要的合适的方法。这些方法都在 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">Oracle 的 JDK 官方文档中有列出</a></p><h3 id="直接创建-ExecutorService-的实例"><a href="#直接创建-ExecutorService-的实例" class="headerlink" title="直接创建 ExecutorService 的实例"></a>直接创建 ExecutorService 的实例</h3><p>因为 <code>ExecutorService</code> 是只是一个接口，因此可以使用其任何实现类的实例。Java <code>java.util.concurrent</code> 包已经预定义了几种实现可供我们选择，或者你也可以创建自己的实现。</p><p>例如，<code>ThreadPoolExecutor</code> 类实现了 <code>ExecutorService</code> 接口并提供了一些构造函数用于配置执行程序服务及其内部池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,   </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>你可能会注意到，上面的代码与工厂方法 <code>newSingleThreadExecutor()</code> 的 源代码 非常相似。对于大多数情况，不需要详细的手动配置。</p><h2 id="将任务分配给-ExecutorService"><a href="#将任务分配给-ExecutorService" class="headerlink" title="将任务分配给 ExecutorService"></a>将任务分配给 ExecutorService</h2><p><code>ExecutorService</code> 可以执行 <code>Runnable</code> 和 <code>Callable</code> 任务。为了使本文简单易懂。我们将使用两个两个原始任务，如下面的代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnableTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; callableTask = () -&gt; &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task&#x27;s execution&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; callableTasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">callableTasks.add(callableTask);</span><br><span class="line">callableTasks.add(callableTask);</span><br><span class="line">callableTasks.add(callableTask);</span><br></pre></td></tr></table></figure><blockquote><p>注意: 上面的代码使用了 lambda 表达式而不是匿名内部类。</p></blockquote><p>创建完了任务之后，就可以使用多种方法将任务分配给 ExecutorService ，比如 <code>execute()</code> 方法，还有 <code>submit()</code>、<code>invokeAny()</code> 和 <code>invokeAll()</code> 等方法。这些方法都继承自 <code>Executor</code> 接口。</p><p>1、首先来看看 <code>execute()</code> 方法。</p><p>该方法返回值为空 ( <code>void</code> )。因此使用该方法没有任何可能获得任务执行结果或检查任务的状态（ 是正在运行 ( running ) 还是执行完毕 ( executed ) ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(runnableTask);</span><br></pre></td></tr></table></figure><p>2、其次看看 <code>submit()</code> 方法。</p><p><code>submit()</code> 方法会将一个 <code>Callable</code> 或 <code>Runnable</code> 任务提交给 <code>ExecutorService</code> 并返回 <code>Future</code> 类型的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executorService.submit(callableTask);</span><br></pre></td></tr></table></figure><p>3、然后是 <code>invokeAny()</code> 方法。</p><p><code>invokeAny()</code> 方法将一组任务分配给 ExecutorService，使每个任务执行，并返回任意一个成功执行的任务的结果 ( 如果成功执行 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> executorService.invokeAny(callableTasks);</span><br></pre></td></tr></table></figure><p>4、最后是 <code>invokeAll()</code> 方法。</p><p><code>invokeAll()</code> 方法将一组任务分配给 ExecutorService ，使每个任务执行，并以 Future 类型的对象列表的形式返回所有任务执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableTasks);</span><br></pre></td></tr></table></figure><p>在继续深入理解 ExecutorService 之前，我们必须先讲解下另外两件事：关闭 ExecutorService 和处理 Future 返回类型。</p><h2 id="关闭-ExecutorService"><a href="#关闭-ExecutorService" class="headerlink" title="关闭 ExecutorService"></a>关闭 ExecutorService</h2><p>一般情况下，ExecutorService 并不会自动关闭，即使所有任务都执行完毕，或者没有要处理的任务，也不会自动销毁 ExecutorService 。它会一直出于等待状态，等待我们给它分配新的工作。</p><p>这种机制，在某些情况下是非常有用的，比如，，如果应用程序需要处理不定期出现的任务，或者在编译时不知道这些任务的数量。</p><p>但另一方面，这也带来了副作用：即使应用程序可能已经到达它的终点，但并不会被停止，因为等待的 ExecutorService 将导致 JVM 继续运行。这样，我们就需要主动关闭 ExecutorService。</p><p>要正确的关闭 ExecutorService，可以调用实例的 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法。</p><p>1、<code>shutdown()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p><code>shutdown()</code> 方法并不会立即销毁 ExecutorService 实例，而是首先让 ExecutorService 停止接受新任务，并在所有正在运行的线程完成当前工作后关闭。<br>2、<code>shutdownNow()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Runnable&gt; notExecutedTasks = executorService.shutDownNow();</span><br></pre></td></tr></table></figure><p><code>shutdownNow()</code> 方法会尝试立即销毁 ExecutorService 实例，所以并不能保证所有正在运行的线程将同时停止。该方法会返回等待处理的任务列表，由开发人员自行决定如何处理这些任务。</p><p>因为提供了两个方法，因此关闭 ExecutorService 实例的最佳实战 （ 也是 Oracle 所推荐的 ）就是同时使用这两种方法并结合 <code>awaitTermination()</code> 方法。</p><p>使用这种方式，ExecutorService 首先停止执行新任务，等待指定的时间段完成所有任务。如果该时间到期，则立即停止执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!executorService.awaitTermination(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h2><p><code>submit()</code> 方法和 <code>invokeAll()</code> 方法返回一个 Future 接口的对象或 Future 类型的对象集合。这些 Future 接口的对象允许我们获取任务执行的结果或检查任务的状态 ( 是正在运行还是执行完毕 ）。</p><h3 id="Future-接口-get-方法"><a href="#Future-接口-get-方法" class="headerlink" title="Future 接口 get() 方法"></a>Future 接口 get() 方法</h3><p>Future 接口提供了一个特殊的阻塞方法 <code>get()</code>，它返回 Callable 任务执行的实际结果，但如果是 Runnable 任务，则只会返回 null。</p><p>因为 <code>get()</code> 方法是阻塞的。如果调用 <code>get()</code> 方法时任务仍在运行，那么调用将会一直被执阻塞，直到任务正确执行完毕并且结果可用时才返回。</p><p>而且更重要的是，正在被执行的任务随时都可能抛出异常或中断执行。因此我们要将 <code>get()</code> 调用放在 <code>try catch</code> 语句块中，并捕捉 <code>InterruptedException</code> 或 <code>ExecutionException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executorService.submit(callableTask);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>get()</code> 方法是阻塞的，而且并不知道要阻塞多长时间。因此可能导致应用程序的性能降低。如果结果数据并不重要，那么我们可以使用超时机制来避免长时间阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>这个 <code>get()</code> 的重载，第一个参数为超时的时间，第二个参数为时间的单位。上面的实例所表示就的就是等待 200 毫秒。</p><p>注意，这个 <code>get()</code> 重载方法，如果在超时时间内正常结束，那么返回的是 Future 类型的结果，如果超时了还没结束，那么将抛出 TimeoutException 异常。</p><p>除了 get() 方法之外，Future 还提供了其它很多方法，我们将几个重要的方法罗列在此</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">isDone()</td><td align="center">检查已分配的任务是否已处理</td></tr><tr><td align="center">cancel()</td><td align="center">取消任务执行</td></tr><tr><td align="center">isCancelled()</td><td align="center">检查任务是否已取消</td></tr></tbody></table><p>这些方法的使用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isDone</span>      <span class="operator">=</span> future.isDone();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">canceled</span>    <span class="operator">=</span> future.cancel(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCancelled</span> <span class="operator">=</span> future.isCancelled();</span><br></pre></td></tr></table></figure><h2 id="ScheduledExecutorService-接口"><a href="#ScheduledExecutorService-接口" class="headerlink" title="ScheduledExecutorService 接口"></a>ScheduledExecutorService 接口</h2><p><code>ScheduledExecutorService</code> 接口用于在一些预定义的延迟之后运行任务和（ 或 ）定期运行任务。</p><p>同样的，实例化 <code>ScheduledExecutorService</code> 的最佳方式是使用 Executors 类的工厂方法。</p><blockquote><p>Executors 类为很多类都提供了工厂方法，简直就是工厂方法的集大成者。</p></blockquote><p>本章节为了简单起见，我们只使用只有一个线程的 ScheduledExecutorService 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure><p>有了实例之后，事情就好办了，比如，要在固定延迟后安排单个任务的执行，可以使用 ScheduledExecutorService 实例的 <code>scheduled()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; resultFuture = executorService.schedule(callableTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>上面这个实例中的代码在执行 callableTask 之前延迟了一秒钟。</p><p><code>scheduled()</code> 方法有两个重载，分别用于执行 Runnable 任务或 Callable 任务。</p><p>另外，ScheduledExecutorService 实例还提供了另一个重要方法 <code>scheduleAtFixedRate()</code> ，它允许在固定延迟后定期执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; resultFuture = service.scheduleAtFixedRate(runnableTask, <span class="number">100</span>, <span class="number">450</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>上面的代码块将在 100 毫秒的初始延迟后执行任务，之后，它将每 450 毫秒执行相同的任务。</p><p>如果处理器需要更多时间来执行分配的任务，那么可以使用 <code>scheduleAtFixedRate()</code> 方法的 period 参数，ScheduledExecutorService 将等到当前任务完成后再开始下一个任务。</p><p>如果任务迭代之间必须具有固定长度的延迟，那么可以使用 <code>scheduleWithFixedDelay()</code> 方法 。例如，以下代码将保证当前执行结束与另一个执行结束之间的暂停时间为 150 毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.scheduleWithFixedDelay(task, <span class="number">100</span>, <span class="number">150</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>根据 <code>scheduleAtFixedRate()</code> 和 <code>scheduleWithFixedDelay()</code> 方法契约，在任务执行期间，如果 ExecutorService 终止了或任务抛出了异常，那么任务将自动结束。</p><h2 id="ExecutorService-或-Fork-Join"><a href="#ExecutorService-或-Fork-Join" class="headerlink" title="ExecutorService 或 Fork/Join"></a>ExecutorService 或 Fork/Join</h2><p>Fork/Join 是 Java 7 提供的新框架，在 Java 7 发布之后，许多开发人员都作出了将 ExecutorService 框架替换为 fork/join 框架的决定。</p><p>但，这并不总是正确的决定。尽管 fork/join 使用起来更加简单且频繁使用时更带来更快的性能，但开发人员对并发执行的控制量也有所减少。</p><p>使用 ExecutorService ，开发人员能够控制生成的线程数以及应由不同线程执行的任务粒度。ExecutorService 的最佳用例是处理独立任务，例如根据 「 一个任务的一个线程 」 方案的事务或请求。</p><p>而相比之下，根据 <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Oracle 文档</a>，fork/join 旨在简化和加速工作，可以将任务递归地分成更小的部分。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>尽管 ExecutorService 相对简单，但仍有一些常见的陷阱。我们罗列于此</p><p>1、保持未使用的 ExecutorService 存活</p><p>本文中对如何关闭 ExecutorService 已经做出了详细解释。</p><p>2、使用固定长度的线程池时设置了错误的线程池容量</p><p>使用 ExecutorService 最重要的一件事，就是确定应用程序有效执行任务所需的线程数</p><ul><li>太大的线程池只会产生不必要的开销，只会创建大多数处于等待模式的线程。</li><li>太少的线程池会让应用程序看起来没有响应，因为队列中的任务等待时间很长。</li></ul><p>3、在取消任务后调用 Future 的 get() 方法</p><p>尝试获取已取消任务的结果将触发 CancellationException 异常。</p><p>4、使用 Future 的 get() 方法意外地阻塞了很长时间</p><p>应该使用超时来避免意外的等待。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> API </tag>
            
            <tag> Executor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
