<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二十、Java 8 函数接口 （ Functional interface ）</title>
      <link href="/posts/783096c.html"/>
      <url>/posts/783096c.html</url>
      
        <content type="html"><![CDATA[<h1 id="二十、Java-8-函数接口-（-Functional-interface-）"><a href="#二十、Java-8-函数接口-（-Functional-interface-）" class="headerlink" title="二十、Java 8 函数接口 （ Functional interface ）"></a>二十、Java 8 函数接口 （ Functional interface ）</h1><p>Java 8 引入了 「 函数接口 」 ( funtional interface ) 的概念，「 函数接口 」就是那些有且只有显式定义一个方法的接口。</p><p>例如，具有单个方法 <code>compareTo()</code> 的接口 <code>Comparable</code> 接口，它只有一个功能，就是用于比较。</p><p>这种函数接口一般用于 Java 8 中的 Lambda 表达式 。 而且 Java 8 为了支持 Lambda 表达式，更是定义了许多函数接口。这些接口基本都在 <code>java.util.function</code> 包中。</p><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>函数接口为 Java 8 Lambda 表达式和方法引用提供目标类型。每个函数接口都有一个 虚 ( abstract ) 方法，成为该函数接口的函数方法。用于适配该类型的 Lambda 表达式的参数类型和返回值类型。</p><p>函数接口可以在多个上下文中提供目标类型，例如赋值上下文，方法调用或强制转换上下文。</p><p>我们写一小段代码演示下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assignment context</span></span><br><span class="line">Predicate&lt;String&gt; p = String::isEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method invocation context</span></span><br><span class="line">stream.filter(e -&gt; e.getSize() &gt; <span class="number">10</span>)...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast context</span></span><br><span class="line">stream.map((ToIntFunction) e -&gt; e.getSize())..</span><br></pre></td></tr></table></figure><h2 id="函数接口的规则"><a href="#函数接口的规则" class="headerlink" title="函数接口的规则"></a>函数接口的规则</h2><p>那么，什么样的接口才能称之为函数接口呢 ？</p><p>如果一个接口的实现类只需要实现一个方法，那么该接口就是函数接口。</p><p>具体来说，有以下两种情况</p><p>1、 那些只有一个方法的接口，例如 <code>Comparable</code> 接口，它只有一个方法 <code>compareTo()</code>。<br>2、 那些具有多个默认方法，但有且只有一个虚方法的接口。也就是说，函数接口也可以有多个方法，但除了一个可用 Lambda 表达式来实现的方法，其它方法都必须有 <code>default</code> 关键字。</p><h2 id="java-util-function-包中定义的函数接口"><a href="#java-util-function-包中定义的函数接口" class="headerlink" title="java.util.function 包中定义的函数接口"></a>java.util.function 包中定义的函数接口</h2><p><code>java.util.function</code> 包中定义了大量的函数接口，下表列出了这些接口，并对其做一些简单的介绍。</p><table><thead><tr><th align="center">接口</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">BiConsumer&lt;T,U&gt;</td><td align="center">表示接受两个不同类型的参数，但不返回任何结果的操作</td></tr><tr><td align="center">BiFunction&lt;T,U,R&gt;</td><td align="center">表示接受两个不同类型的参数，并返回一个其它类型的结果的操作</td></tr><tr><td align="center">BinaryOperator<T></td><td align="center">表示接受两个相同类型的参数，并返回一个同一类型的结果的操作</td></tr><tr><td align="center">BiPredicate&lt;T,U&gt;</td><td align="center">表示接受两个不同诶行的参数，且返回布尔类型的结果的操作</td></tr><tr><td align="center">BooleanSupplier</td><td align="center">不接受任何参数，且返回一个布尔类型的结果的操作</td></tr><tr><td align="center">Consumer<T></td><td align="center">表示接受一个参数，但不返回任何结果的操作</td></tr><tr><td align="center">DoubleBinaryOperator</td><td align="center">表示接受两个 double 类型的参数，并返回 double 类型结果的操作</td></tr><tr><td align="center">DoubleConsumer</td><td align="center">表示接受一个 double 类型的参数，但不返回任何结果的操作</td></tr><tr><td align="center">DoubleFunction<R></td><td align="center">表示接受一个 double 类型的参数，且返回一个 R 类型的结果的操作</td></tr><tr><td align="center">DoublePredicate</td><td align="center">表示一个接受两个 double 类型的参数， 且返回一个布尔类型的结果的操作</td></tr><tr><td align="center">DoubleSupplier</td><td align="center">表示一个不接受任何参数，但返回布尔类型的结果的操作</td></tr><tr><td align="center">DoubleToIntFunction</td><td align="center">表示接受两个 double 类型的参数，但返回一个 int 类型的结果的操作</td></tr><tr><td align="center">DoubleToLongFunction</td><td align="center">表示接受两个 double 类型的参数，但返回一个 long 类型的结果的操作</td></tr><tr><td align="center">DoubleUnaryOperator</td><td align="center">表示接受一个 double 类型的参数，且返回一个 double 类型的结果的操作</td></tr><tr><td align="center">Function&lt;T,R&gt;</td><td align="center">表示一个接受 T 类型的参数，且返回一个 R 类型结果的函数</td></tr><tr><td align="center">IntBinaryOperator</td><td align="center">表示一个接受两个 int 类型的参数，且返回一个 int 类型的结果的操作</td></tr><tr><td align="center">IntConsumer</td><td align="center">表示接受一个 int 类型的参数，但不返回任何结果的操作</td></tr><tr><td align="center">IntFunction<R></td><td align="center">表示接受一个 int 类型的参数，但返回一个 R 类型的结果的操作</td></tr><tr><td align="center">IntPredicate</td><td align="center">表示接受一个 int 类型的参数，但返回布尔类型的结果的操作</td></tr><tr><td align="center">IntSupplier</td><td align="center">表示不接受任何参数，但返回一个 int 类型的结果的操作</td></tr><tr><td align="center">IntToDoubleFunction</td><td align="center">表示接受一个 int 类型的参数，但返回一个 double 类型的结果的操作</td></tr><tr><td align="center">IntToLongFunction</td><td align="center">表示接受一个 int 类型的参数，但返回一个 long 类型的结果的操作</td></tr><tr><td align="center">IntUnaryOperator</td><td align="center">表示接受一个 int 类型的参数，且返回一个 int 类型的结果的操作</td></tr><tr><td align="center">LongBinaryOperator</td><td align="center">表示接受两个 long 类型的参数，且返回一个 long 类型的结果的操作</td></tr><tr><td align="center">LongConsumer</td><td align="center">表示不接受任何参数，但返回一个 long 类型的结果的操作</td></tr><tr><td align="center">LongFunction<R></td><td align="center">表示接受一个 loing 类型的参数，但返回一个 R 类型的结果的操作</td></tr><tr><td align="center">LongPredicate</td><td align="center">表示接受一个 long 类型的参数，但返回布尔类型的结果的操作</td></tr><tr><td align="center">LongSupplier</td><td align="center">表示不接受任何参数，但返回一个 long 类型的结果的操作</td></tr><tr><td align="center">LongToDoubleFunction</td><td align="center">表示接受一个 long 类型的参数，但返回一个 double 类型的结果的函数</td></tr><tr><td align="center">LongToIntFunction</td><td align="center">表示接受一个 long 类型的参数，但返回 int 类型的结果的函数</td></tr><tr><td align="center">LongUnaryOperator</td><td align="center">表示接受一个 long 类型的参数，并返回一个 long 类型的结果的操作</td></tr><tr><td align="center">ObjDoubleConsumer<T></td><td align="center">表示接受两个参数，一个为 T 类型的对象，另一个 double 类型，但不返回任何结果的操作</td></tr><tr><td align="center">ObjIntConsumer<T></td><td align="center">表示接受两个参数，一个为 T 类型的对象，另一个 int 类型，但不返回任何结果的操作</td></tr><tr><td align="center">ObjLongConsumer<T></td><td align="center">表示接受两个参数，一个为 T 类型的对象，另一个 double 类型，但不返回任何结果的操作</td></tr><tr><td align="center">Predicate<T></td><td align="center">表示接受一个指定类型 T 的参数，但返回布尔类型的结果的操作</td></tr><tr><td align="center">Supplier<T></td><td align="center">表示不接受任何参数，但返回一个 T 类型的结果的操作</td></tr><tr><td align="center">ToDoubleBiFunction&lt;T,U&gt;</td><td align="center">表示接受两个不同类型的参数，但返回一个 double 类型的结果的操作</td></tr><tr><td align="center">ToDoubleFunction<T></td><td align="center">表示一个接受指定类型 T 的参数，并返回一个 double 类型的结果的操作</td></tr><tr><td align="center">ToIntBiFunction&lt;T,U&gt;</td><td align="center">表示接受两个不同类型的参数，但返回一个 int 类型的结果的操作</td></tr><tr><td align="center">ToIntFunction<T></td><td align="center">表示一个接受指定类型 T 的参数，并返回一个 int 类型的结果的操作</td></tr><tr><td align="center">ToLongBiFunction&lt;T,U&gt;</td><td align="center">表示接受两个不同类型的参数，但返回一个 long 类型的结果的操作</td></tr><tr><td align="center">ToLongFunction<T></td><td align="center">表示一个接受指定类型的参数，并返回一个 long 类型的结果的操作</td></tr><tr><td align="center">UnaryOperator<T></td><td align="center">表示接受一个参数，并返回一个与参数类型相同的结果的操作</td></tr></tbody></table><p>看起来很多接口功能都是重复的。但实际上并非如此，因为各个接口表面上看起来一样，但实际上它们有着不同的默认方法</p><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>我们写一个范例来演示下 <code>Predicate&lt;T&gt;</code> 函数接口的使用。</p><p><code>Predicate&lt;T&gt;</code> 只有一个虚方法 <code>test(Object)</code>，该方法接受一个 T 类型的对象，然后返回布尔类型的结果。因此，我们的 Lambda 表达是的参数也是 T 类型，返回值则是布尔类型</p><h4 id="Java8Tester-java"><a href="#Java8Tester-java" class="headerlink" title="Java8Tester.java"></a>Java8Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate = n -&gt; true</span></span><br><span class="line">      <span class="comment">// n is passed as parameter to test method of Predicate interface</span></span><br><span class="line">      <span class="comment">// test method will always return true no matter what value n has.</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;Print all numbers:&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//pass n as parameter</span></span><br><span class="line">      eval(list, n-&gt;<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span></span><br><span class="line">      <span class="comment">// n is passed as parameter to test method of Predicate interface</span></span><br><span class="line">      <span class="comment">// test method will return true if n%2 comes to be zero</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;Print even numbers:&quot;</span>);</span><br><span class="line">      eval(list, n-&gt; n%<span class="number">2</span> == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span></span><br><span class="line">      <span class="comment">// n is passed as parameter to test method of Predicate interface</span></span><br><span class="line">      <span class="comment">// test method will return true if n is greater than 3.</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;Print numbers greater than 3:&quot;</span>);</span><br><span class="line">      eval(list, n-&gt; n &gt; <span class="number">3</span> );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eval</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Integer n: list) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; &quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Print all numbers:</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9 </span><br><span class="line">Print even numbers:</span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">6 </span><br><span class="line">8 </span><br><span class="line">Print numbers greater than 3:</span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九、Java 8 流 Stream ( 下 )</title>
      <link href="/posts/f4456923.html"/>
      <url>/posts/f4456923.html</url>
      
        <content type="html"><![CDATA[<h1 id="十九、Java-8-流-Stream-下"><a href="#十九、Java-8-流-Stream-下" class="headerlink" title="十九、Java 8 流 Stream ( 下 )"></a>十九、Java 8 流 Stream ( 下 )</h1><p>上一章节 Java 8 流 Stream ( 上 ) 因为时间关系，我们介绍到一半半就停止了。本章节我们继续。</p><h3 id="limit-方法"><a href="#limit-方法" class="headerlink" title="limit() 方法"></a>limit() 方法</h3><p><code>limit()</code> 方法用于减少( 限制 ) 流中的元素数量。</p><p>例如下面的代码段演示了如何使用 <code>limit()</code> 方法只输出 10 个随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="sorted-方法"><a href="#sorted-方法" class="headerlink" title="sorted() 方法"></a>sorted() 方法</h3><p><code>sorted()</code> 方法用于给流中的元素进行排序。</p><p>下面的范例演示了如何按照排序顺序打印 10 个随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h2><p><code>parallelStream()</code> 是需要并发处理的流的替代方案。<code>stream()</code> 方法产生的流只能是串行处理，可以理解为只在一个线程中，按照流中元素的顺序一个接一个的处理。</p><p>而并发处理，就是传说中的 <code>map-reduce</code> 方法，可以充分利用多核优势。</p><p>需要注意的是，<code>parallelStream()</code> 会打乱流的顺序，也就是返回的序列顺序不一定是输入的序列顺序。</p><p>例如下面的代码用于打印序列中的空字符串的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get count of empty string</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><p>因为 <code>stream()</code> 返回是串行流，而 <code>parallelStream()</code> 返回的是并行流。因此在串行和并行之间切换是非常简单的。</p><h2 id="收集器-（-Collectors-）"><a href="#收集器-（-Collectors-）" class="headerlink" title="收集器 （ Collectors ）"></a>收集器 （ Collectors ）</h2><p>收集器 （ Collectors ）用于将已经处理的流中的元素组合到一起。</p><p><code>Collectors</code> 类提供了大量方法用于指示如何收集元素。</p><p>比如 <code>Collectors.toList()</code> 方法可以将流中的元素收集起来，并转换为列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Filtered List: &quot;</span> + filtered);</span><br></pre></td></tr></table></figure><p>比如 <code>Collectors.joining()</code> 方法可以将流中的元素收集起来，并使用指定的字符串拼接符拼接成一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Merged String: &quot;</span> + mergedString);</span><br></pre></td></tr></table></figure><h2 id="统计-Statistics"><a href="#统计-Statistics" class="headerlink" title="统计 ( Statistics )"></a>统计 ( Statistics )</h2><p>Java 8 同时新增了大量的统计收集器来来获取流中的元素的一些统计信息。</p><p>前提是我们先要在流上调用 <code>summaryStatistics()</code> 方法返回统计信息概要，然后在调用相应的方法来获取具体的统计信息。</p><p>例如下面的代码，先调用 <code>summaryStatistics()</code> 方法返回统计概要，然后调用 <code>getMax()</code> 方法获取最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">numbers</span> <span class="operator">=</span> Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Highest number in List : &quot;</span> + stats.getMax());</span><br></pre></td></tr></table></figure><p>例如下面的代码，先调用 <code>summaryStatistics()</code> 方法返回统计概要，然后调用 <code>getMin()</code> 和 <code>getSum()</code> 方法获取最小值和所有数字之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">numbers</span> <span class="operator">=</span> Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Lowest number in List : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of all numbers : &quot;</span> + stats.getSum());</span><br></pre></td></tr></table></figure><p>例如下面的代码，先调用 <code>summaryStatistics()</code> 方法返回统计概要，然后调用 <code>getAverage()</code> 方法获取平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">numbers</span> <span class="operator">=</span> Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Average of all numbers : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十八、Java 8 流 Stream ( 上 )</title>
      <link href="/posts/62e87c35.html"/>
      <url>/posts/62e87c35.html</url>
      
        <content type="html"><![CDATA[<h1 id="十八、Java-8-流-Stream-上"><a href="#十八、Java-8-流-Stream-上" class="headerlink" title="十八、Java 8 流 Stream ( 上 )"></a>十八、Java 8 流 Stream ( 上 )</h1><p>流 ( Stream ) 是 Java 8 新增加的一个重磅级的功能。流是一个抽象层。有了流，我们就可以使用类似于 SQL 语句的声明方式来处理数据。</p><p>比如，下面的 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(grade), student_id, student_name <span class="keyword">FROM</span> Students;</span><br></pre></td></tr></table></figure><p>上面这条 SQL 会自动返回最高学习绩点的学生的信息，而全程，开发人员却不用直接面对任何计算和比较。</p><p>在流 （ Stream ) 出现之前，对于Java 中的集合框架的使用。开发人员不得不一次次的写一个循环，一次次的重复检查。当然了，这也什么，毕竟大家都是这样过来的。</p><p>更大的问题在于开发效率。面对当前的多核 CPU 计算机，面对并发编程。我们开发者常常会写出非常容易出错的并发执行的代码。</p><p>为了解决这些问题，Java 8 引入了流 ( Stream ) 这个概念，允许开发人员以声明的方式处理数据的同时，还能利用多核构架，而无需编写任何特殊的代码。</p><h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么 ?"></a>流是什么 ?</h2><p>Java 中的 <strong>流</strong> ( Stream ) 表示来自 <strong>源</strong> ( source ) 的一系列对象，它支持统计、求和、求平均值等聚合操作。</p><p>流具有以下特征：</p><ul><li><strong>元素序列</strong> : 流以顺序方式提供特定类型的一组元素。流只会按需获取/计算元素。但它从不存储元素。</li><li>**源 ( Source )**：流可以将集合，数组或 I/O 资源作为输入源。</li><li><strong>聚合操作</strong>： 流支持聚合操作，如 <code>filter</code>、<code>map</code>、<code>limit</code>、<code>reduce</code>、<code>find</code>、<code>match</code> 等</li><li>**管道 ( pipelining )**：大多数流操作都返回流本身，以便可以对其结果进行流水线操作。这些操作称为 <strong>中间</strong> 操作，它们的功能是获取输入，处理它们并将输出返回到目标。<code>collect()</code> 方法是一个终端操作，通常在流水线操作结束时出现，以标记流的结尾。</li><li><strong>原子性迭代 ( Automatic iterations )</strong> ： 与需要显式迭代的集合相比，流操作在内部对所提供的源元素进行迭代。</li></ul><h2 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h2><p>Java 8 在推出流的同时，对集合框架也进行了一些比较大变更。主要是在 <code>Collection</code> 接口上提供了两种生成 Stream 的方法:</p><ul><li><code>stream()</code> 方法，该方法以集合作为源，返回集合中的所有元素以在集合中出现的顺序组成的流。</li><li><code>parallelStream()</code> 方法，该方法以集合作为源，返回一个支持并发操作的流。</li></ul><h2 id="流支持的聚合操作"><a href="#流支持的聚合操作" class="headerlink" title="流支持的聚合操作"></a>流支持的聚合操作</h2><h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach() 方法"></a>forEach() 方法</h3><p>Java 8 为 Stream 提供了一种新方法 <code>forEach()</code>，用于迭代流的每个元素。</p><p>下面的代码片段演示了如何使用 <code>forEach</code> 打印 <code>10</code> 个随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面这个代码片段中，<code>Random</code> 对象的 <code>ints()</code> 方法会返回一个整数流。而 <code>limit()</code> 方法则限制了流中的元素个数。从某些方面说，可以理解为当源产生了 10 个随机数之后就关闭源。</p><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map() 方法"></a>map() 方法</h3><p><code>map()</code> 方法会迭代流中的元素，并为每个元素应用一个方法，然后返回应用后的流。</p><p>例如下面的代码，使用 <code>map()</code> 方法把求出每个元素的平方，然后过滤掉重复的元素，最后在转换为列表集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取每个元素的平方</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><code>map( i -&gt; i*i)</code> 操作求取流中每个元素的平方，并返回一个新的流。<code>distinct()</code> 方法则用于过滤流中的重复元素。</p><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter() 方法"></a>filter() 方法</h3><p><code>filter()</code> 方法根据一个谓词来过滤元素。这个谓词是一个方法，以流中的每一个元素作为参数，如果返回 <code>true</code> 则会被过滤掉。</p><p>例如下面的代码，使用 <code>filter()</code> 方法过滤那些空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十七、Java 8 新日期时间 API ( 下 ) – 格式化</title>
      <link href="/posts/1054668a.html"/>
      <url>/posts/1054668a.html</url>
      
        <content type="html"><![CDATA[<h1 id="十七、Java-8-新日期时间-API-下-–-格式化"><a href="#十七、Java-8-新日期时间-API-下-–-格式化" class="headerlink" title="十七、Java 8 新日期时间 API ( 下 ) – 格式化"></a>十七、Java 8 新日期时间 API ( 下 ) – 格式化</h1><p>Java 8 似乎也对 <code>java.text.SimpleDateFormat</code> 也不太满意，竟然重新创建了一个 <code>java.time.format</code> 包，该包下包含了几个类和枚举用于格式化日期时间。</p><h2 id="java-time-format-包"><a href="#java-time-format-包" class="headerlink" title="java.time.format 包"></a>java.time.format 包</h2><p><code>java.time.format</code> 包提供了以下几个类用于格式化日期时间</p><table><thead><tr><th align="center">类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DateTimeFormatter</td><td align="center">用于打印和解析日期时间对象的格式化程序</td></tr><tr><td align="center">DateTimeFormatterBuilder</td><td align="center">创建日期时间格式化样式的构建器</td></tr><tr><td align="center">DecimalStyle</td><td align="center">日期和时间格式中使用的本地化十进制样式</td></tr></tbody></table><p><code>java.time.format</code> 包还提供了以下几个枚举，包含了常见的几种日期时间格式。</p><table><thead><tr><th align="center">枚举</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">FormatStyle</td><td align="center">包含了本地化日期，时间或日期时间格式器的样式的枚举</td></tr><tr><td align="center">ResolverStyle</td><td align="center">包含了解决日期和时间的不同方法的枚举</td></tr><tr><td align="center">SignStyle</td><td align="center">包含了如何处理正/负号的方法的枚举</td></tr><tr><td align="center">TextStyle</td><td align="center">包含了文本格式和解析的样式的枚举</td></tr></tbody></table><h2 id="DateTimeFormatter-类"><a href="#DateTimeFormatter-类" class="headerlink" title="DateTimeFormatter 类"></a>DateTimeFormatter 类</h2><p><code>DateTimeFormatter</code> 类格式化日期时间的最重要的类，该类是一个最终类，只能实例化，不能被扩展和继承。</p><p><code>DateTimeFormatter</code> 类的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DateTimeFormatter</span> <span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure><p><code>DateTimeFormatter</code> 类用于打印和解析日期时间对象的格式化器。此类提供打印和解析的主要应用程序入口点，并提供 DateTimeFormatter 的常见模式</p><ul><li>使用预定义的常量，比如 <code>ISO_LOCAL_DATE</code></li><li>使用模式字母，例如 <code>uuuu-MMM-dd</code></li><li>使用本地化样式，例如 <code>long</code> 或 <code>medium</code></li></ul><p>所有的日期时间类，包括本地日期时间和包含时区的日期时间类，都提供了两个重要的方法</p><p>1、 一个用于格式化，<code>format(DateTimeFormatter formatter)</code><br>2、 另一个用于解析，<code>parse(CharSequence text, DateTimeFormatter formatter)</code></p><p>下面，我们写几个示例来演示下这两个方法，并演示下如和使用 <code>DateTimeFormatter</code> 类</p><h4 id="Java8Tester"><a href="#Java8Tester" class="headerlink" title="Java8Tester"></a>Java8Tester</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间是: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;另一种表示形式:&quot;</span> + now.format(DateTimeFormatter.RFC_1123_DATE_TIME));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前时间是: 2022-05-05T11:47:57.680725Z[Etc/UTC]</span><br><span class="line">另一种表示形式:Thu, 5 May 2022 11:47:57 GMT</span><br></pre></td></tr></table></figure><p>我们还可以调用 <code>DateTimeFormatter.ofPattern()</code> 方法创建自己的日期时间格式，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间是: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">      <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd H:m:s&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;另一种表示形式:&quot;</span> + now.format(formatter));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前时间是: 2022-05-05T11:48:37.111221Z[Etc/UTC]</span><br><span class="line">另一种表示形式:2022/05/05 11:48:37</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然了，我们可以调用 <code>LocalDateTime</code> 类的静态方法 <code>parse()</code> 将我们刚刚自定义的日期时间格式给解析回来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间是: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">      <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd H:m:s&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> now.format(formatter);</span><br><span class="line">      System.out.println(<span class="string">&quot;另一种表示形式:&quot;</span> + text );</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">parsed</span> <span class="operator">=</span> LocalDateTime.parse(text, formatter);</span><br><span class="line">      System.out.println(<span class="string">&quot;解析后:&quot;</span> + parsed );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前时间是: 2022-05-05T11:49:07.577534Z[Etc/UTC]</span><br><span class="line">另一种表示形式:2022/05/05 11:49:7</span><br><span class="line">解析后:2022-05-05T11:49:07</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六、Java 8 新日期时间 API ( 中 ) – 时区日期时间</title>
      <link href="/posts/65f9a50c.html"/>
      <url>/posts/65f9a50c.html</url>
      
        <content type="html"><![CDATA[<h1 id="十六、Java-8-新日期时间-API-中-–-时区日期时间"><a href="#十六、Java-8-新日期时间-API-中-–-时区日期时间" class="headerlink" title="十六、Java 8 新日期时间 API ( 中 ) – 时区日期时间"></a>十六、Java 8 新日期时间 API ( 中 ) – 时区日期时间</h1><p>上一章节 Java 8 新日期时间 API ( 上 ) – 本地日期时间 我们对 Java 8 重新设计的日期时间 API 做了一些基础的介绍，同时详细介绍了和本地时间有关的几个类 <code>LocalDateTime</code> 、<code>LocalDate</code> 和 <code>LocalTime</code> 。</p><p>我同时也发现，这三个类没有任何时区相关的信息，但也不能说它们没处理时区，而只能说它们有选择的隐藏了时区的处理。它们内部会使用操作系统当前的时区。</p><p>以此同时，Java 在 <code>java.time</code> 包中也提供了几个类用于处理需要关注时区的日期时间 API。它们是 <code>java.time.ZonedDateTime</code> 和 <code>java.time.ZoneId</code>。前者用于处理需要时区的日期时间，后者用于处理时区。</p><p><code>ZonedDateTime</code> 和 <code>LocalDateTime</code> 类似，几乎有着相同的 API。从某些方面说，<code>ZonedLocalTime</code> 如果不传递时区信息，那么它会默认使用操作系统的时区，这样，结果其实和 <code>LocalDateTime</code> 是类似的。</p><p>比如，我们可以使用 <code>ZonedDateTime</code> 的 <code>now()</code> 方法返回当前时区 ( 操作系统时区 ) 的日期时间，调用 <code>parse()</code> 方法可以将一个包含了时区信息的字符串格式的日期时间转化为一个 ZonedDateTime 实例。</p><h4 id="Java8Tester-java"><a href="#Java8Tester-java" class="headerlink" title="Java8Tester.java"></a>Java8Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期时间是:&quot;</span> + now);</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">datetime</span> <span class="operator">=</span> ZonedDateTime.parse(<span class="string">&quot;2022-12-12T21:58:20+02:00&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;日期时间是:&quot;</span> + datetime);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前日期时间是:2022-05-05T11:45:25.602159Z[Etc/UTC]</span><br><span class="line">日期时间是:2022-12-12T21:58:20+02:00</span><br></pre></td></tr></table></figure><p>我们还可以调用 <code>ZonedDateTime</code> 对象的 <code>toLocalDate()</code> 和 <code>toLocalTime()</code> 方法将获取该实例的转换为本地的日期和时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期时间是:&quot;</span> + now);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> now.toLocalDate();</span><br><span class="line">      System.out.println(<span class="string">&quot;本地日期是:&quot;</span> + now);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> now.toLocalTime();</span><br><span class="line">      System.out.println(<span class="string">&quot;本地时间是:&quot;</span> + time);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前日期时间是:2022-05-05T11:46:41.247743Z[Etc/UTC]</span><br><span class="line">本地日期是:2022-05-05T11:46:41.247743Z[Etc/UTC]</span><br><span class="line">本地时间是:11:46:41.247743</span><br></pre></td></tr></table></figure><blockquote><p>P.S 这个返回值好诡异，为啥 <code>toLocalDate()</code> 还返回了时间？</p></blockquote><h2 id="处理时区"><a href="#处理时区" class="headerlink" title="处理时区"></a>处理时区</h2><p>时区相关的信息，我们可以使用 <code>ZoneId</code> 类来处理。</p><p>比如可以调用 <code>ZoneId</code> 类的静态方法 <code>systemDefault()</code> 返回当前的时区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZoneId</span> <span class="variable">currentZone</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前时区是: &quot;</span> + currentZone);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时区是: Asia/Shanghai</span><br></pre></td></tr></table></figure><p>我们还可以调用 <code>ZonedDateTime</code> 实例的 <code>getZone()</code> 方法获取实例所在的时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前时区是: &quot;</span> + now.getZone());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时区是: Asia/Shanghai</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五、Java 8 新日期时间 API ( 上 ) – 本地日期时间</title>
      <link href="/posts/a5516f38.html"/>
      <url>/posts/a5516f38.html</url>
      
        <content type="html"><![CDATA[<h1 id="十五、Java-8-新日期时间-API-上-–-本地日期时间"><a href="#十五、Java-8-新日期时间-API-上-–-本地日期时间" class="headerlink" title="十五、Java 8 新日期时间 API ( 上 ) – 本地日期时间"></a>十五、Java 8 新日期时间 API ( 上 ) – 本地日期时间</h1><p>作为开发者，经常需要处理日期时间。如果你跟随者 Java 5 一路走来，那么一定会对 <code>java.util.Date</code> 、<code>java.util.Calendar</code> 、<code>java.util.GregoiranCalendar</code> 和 <code>java.text.SimpleDateFormat</code> 四大类非常熟悉，它们分别用于处理日期、日历、日历表示、日期时间格式化。</p><p>这四个类，对于编程老人来讲，应该是习惯了，但对于编程新人来讲，就有好多疑问，有好多陷阱和坑等着它们跳，比如</p><p>1、 <strong>非线程安全</strong>：<code>java.util.Date</code> 并不是线程安全的。开发者在使用这个类时必须自己处理多线程并发问题。<br>2、 <strong>设计不佳</strong> ：一方面日期和日期格式化分布在多个包中。另一方面，<code>java.util.Date</code> 的默认日期，年竟然是从 <code>1900</code> 开始，月从 <code>1</code> 开始，日从 <code>0</code> 开始，没有统一性。而且 <code>Date</code> 类也缺少直接操作日期的相关方法。<br>3、 <strong>时区处理困难</strong>：因为设计不佳，开发人员不得不编写大量代码来处理时区问题。<br>4、 还有其它一些问题</p><p>面对种种问题，Java 8 终于重新设计了所有日期时间、日历及时区相关的 API。并把它们都统一放置在 <code>java.time</code> 包和子包下。并作出了以下改进</p><p>1、 新的日期时间 API 是线程安全的。不仅没有 <code>setter</code> 方法，而且任何对实例的变更都会返回一个新的实例而保证原来的实例不变。<br>2、 新的日期时间 API 提供了大量的方法，用于修改日期时间的各个部分，并返回一个新的实例。<br>3、 在时区方面，新的日期时间 API 引入了 <strong>域</strong> ( domain ) 这个概念。</p><p>同时 Java 8 还针对原来复杂的 API 进行重新组合和拆分，分成了好多个类。本章接下来的章节，我们就来详细介绍其中几个最重要的。</p><h2 id="本地日期时间-API"><a href="#本地日期时间-API" class="headerlink" title="本地日期时间 API"></a>本地日期时间 API</h2><p>Java 8 为处理本地的日期时间提供了三个类 <code>LocalDate</code> 、<code>LocalTime</code> 和 <code>LocalDateTime</code>。分别用于处理 <strong>本地日期</strong>、<strong>本地时间</strong> 和 <strong>本地日期时间</strong>。</p><p>当使用这三个类时，开发者并不需要关心时区是什么。因为它默认使用的是操作系统的时区。</p><p>比如，可以使用 <code>LocalDateTime.now()</code> 方法返回当前的日期时间。</p><h4 id="Java8Tester-java"><a href="#Java8Tester-java" class="headerlink" title="Java8Tester.java"></a>Java8Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期时间: &quot;</span> + currentTime);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前日期时间: 2022-05-05T11:40:19.601459</span><br></pre></td></tr></table></figure><p>比如，我们可以调用 <code>LocalDateTime</code> 对象的 <code>toLocalDate()</code> 方法和 <code>toLocalTime()</code> 分别返回当前的日期和当前的时间，也就是 <code>LocalDate</code> 和 <code>LocalTime</code> 两个类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期时间: &quot;</span> + currentTime);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> currentTime.toLocalDate();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期: &quot;</span> + date1);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalTime</span> <span class="variable">time1</span> <span class="operator">=</span> currentTime.toLocalTime();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间: &quot;</span> + time1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前日期时间: 2022-05-05T11:40:58.340724</span><br><span class="line">当前日期: 2022-05-05</span><br><span class="line">当前时间: 11:40:58.340724</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如我们可以调用 <code>LocalDateTime</code> 对象的 <code>getMonth()</code> 方法返回当前的月份，调用 <code>getDayOfMonth()</code> 返回当前的日期，调用 <code>getSecond()</code> 返回当前时间的秒数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期时间: &quot;</span> + currentTime);</span><br><span class="line"></span><br><span class="line">      <span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> currentTime.getMonth();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前月份: &quot;</span> + month);</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> currentTime.getDayOfMonth();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前月中的第几天: &quot;</span> + day);</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">seconds</span> <span class="operator">=</span> currentTime.getSecond();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前秒数: &quot;</span> + seconds);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前日期时间: 2022-05-05T11:41:34.887247</span><br><span class="line">当前月份: MAY</span><br><span class="line">当前月中的第几天: 5</span><br><span class="line">当前秒数: 34</span><br></pre></td></tr></table></figure><p>比如我们可以调用 <code>LocalDateTime</code> 对象的 <code>withDayOfMonth()</code> 修改日并返回一个新的实例，调用 <code>withYear()</code> 修改年，调用其它 <code>with*</code> 方法修改其它属性。</p><p>这些 <code>with</code> 方法都是返回新的实例，而原来的实例并不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">      System.out.println(<span class="string">&quot;当前日期时间: &quot;</span> + currentTime);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">date2</span> <span class="operator">=</span> currentTime.withDayOfMonth(<span class="number">10</span>).withYear(<span class="number">2012</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;新的日期时间: &quot;</span> + date2);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;原来的日期时间: &quot;</span> + currentTime);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前日期时间: 2022-05-05T11:42:06.589161</span><br><span class="line">新的日期时间: 2012-05-10T11:42:06.589161</span><br><span class="line">原来的日期时间: 2022-05-05T11:42:06.589161</span><br></pre></td></tr></table></figure><p>可以发现原先的实例并没有被修改。</p><p>同时，新的日期时间 API 还大量引入了 <code>of()</code> 方法，比如我们可以调用 <code>LocalDate.of()</code> 方法创建一个日期实例，调用 <code>LocalTime.of()</code> 方法创建一个时间实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, Month.OCTOBER, <span class="number">01</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;日期是: &quot;</span> + date);</span><br><span class="line">      <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">22</span>, <span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;时间是: &quot;</span> + time);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日期是: 2023-10-01</span><br><span class="line">时间是: 22:15</span><br></pre></td></tr></table></figure><p>我们还可以调用 <code>LocalDateTime.parse()</code> 、<code>LocalDate.parse()</code> 和 <code>LocalTime.parse()</code> 方法解析字符串格式的日期时间、日期和时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">      tester.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalDateTime</span> <span class="variable">datetime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2022-12-12T21:58:00&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;日期时间是:&quot;</span> + datetime);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2022-12-12&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;日期是: &quot;</span> + date);</span><br><span class="line"></span><br><span class="line">      <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;21:58:01&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;时间是: &quot;</span> + time);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日期时间是:2022-12-12T21:58</span><br><span class="line">日期是: 2022-12-12</span><br><span class="line">时间是: 21:58:01</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四、Java 8 Nashorn JavaScript</title>
      <link href="/posts/9a637408.html"/>
      <url>/posts/9a637408.html</url>
      
        <content type="html"><![CDATA[<h1 id="十四、Java-8-Nashorn-JavaScript"><a href="#十四、Java-8-Nashorn-JavaScript" class="headerlink" title="十四、Java 8 Nashorn JavaScript"></a>十四、Java 8 Nashorn JavaScript</h1><p>对于 Java 中的 JavaScript 引擎， Java 8 引入了 <code>Nashorn</code> 来代替原先的 <code>Rhino</code>。</p><p><code>Nashorn</code> 使用 Java 7 中引入的调用动态特性，且直接编译内存中的代码并将字节码传递给 JVM。这两项改进，直接给 <code>Nashorn</code> 带了至少 2 到 10 倍的性能提升。</p><h2 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h2><p>在 <code>Nashorn</code> JavaScript 引擎中。JAVA 8 引入了一个新的命令行工具 <code>jjs</code>，用于在控制台执行 javascript 代码。</p><p>例如我们可以在当前目录下 ( 任意位置 ) 创建一个 JavaScript 文件 <code>hello.js</code> ，然后输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;你好，A，B ！&#x27;);</span><br></pre></td></tr></table></figure><p>保存文件后，使用下面的 jjs 命令运行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jjs hello.js</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs hello.js</span><br><span class="line">你好，A，B ！</span><br></pre></td></tr></table></figure><h2 id="jjs-交互式解释器"><a href="#jjs-交互式解释器" class="headerlink" title="jjs 交互式解释器"></a>jjs 交互式解释器</h2><p>我们也可以直接在命令行中输出 <code>jjs</code> 进入 Java 8 提供的 <code>jjs</code> 交互式解释器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs</span><br><span class="line">jjs&gt; </span><br></pre></td></tr></table></figure><p>然后输入一些 JavaScript 语句，就会立即显示结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jjs&gt; print(&#x27;你好，A，B ！&#x27;);</span><br><span class="line">你好，A，B ！</span><br><span class="line">jjs&gt; 5 + 8</span><br><span class="line">13</span><br><span class="line">jjs&gt; 8 / 5</span><br><span class="line">1.6</span><br><span class="line">jjs&gt; </span><br></pre></td></tr></table></figure><h2 id="给-jjs-交互式解释器传递参数"><a href="#给-jjs-交互式解释器传递参数" class="headerlink" title="给 jjs 交互式解释器传递参数"></a>给 jjs 交互式解释器传递参数</h2><p>在启动 jjs 交互式解释器时，我们还可以使用两个中划线 ( <code>--</code> ) 来传递一些参数。</p><p>参数之间使用空格分隔 ( 注意，多个空额会视为单个空格 )。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jjs -- 你好 A B </span><br><span class="line">jjs&gt; print(&#x27;你输入的是: &#x27; +arguments.join(&quot;, &quot;))</span><br><span class="line">你输入的是: 你好, A, B</span><br><span class="line">jjs&gt; </span><br></pre></td></tr></table></figure><h2 id="在-Java-中调用-JavaScript"><a href="#在-Java-中调用-JavaScript" class="headerlink" title="在 Java 中调用 JavaScript"></a>在 Java 中调用 JavaScript</h2><p>通过 <code>ScriptEngineManager</code> 类，Java 可以解析和调用 JavaScript 代码。</p><p><code>ScriptEngineManager</code> 类在 <code>javax.script</code> 包中。</p><p>Java 中调用 javascript 代码的步骤一般如下</p><p>1、 创建 JavaScript 引擎的管理器，也就是创建一个 <code>ScriptEngineManager</code> 类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngineManager</span> <span class="variable">scriptEngineManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br></pre></td></tr></table></figure><p>2、 通过 JavaScript 引擎的管理器获取一个 JavaScript 引擎，比如 Java 8 中引入的 <code>Nashorn</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">nashorn</span> <span class="operator">=</span> scriptEngineManager.getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br></pre></td></tr></table></figure><p>3、 调用获取到的引擎的 <code>eval()</code> 方法执行一些代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    result = (Integer) nashorn.eval(&quot;10 + 2&quot;);</span><br><span class="line">需要注意的是，执行 JavaScript 代码可能会抛出 ScriptException 异常。因此要放在一个 `try catch` 语句中。</span><br></pre></td></tr></table></figure><p>上面这三个流程，会涉及到三个类 <code>ScriptEngineManager</code>、<code>ScriptEngine</code> 和 <code>ScriptException</code>。它们都在 <code>javax.script</code> 包中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br></pre></td></tr></table></figure><p>我们写一个范例演示下这个流程</p><h4 id="Java8Tester-java"><a href="#Java8Tester-java" class="headerlink" title="Java8Tester.java"></a>Java8Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.script.ScriptEngineManager;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptEngine;</span><br><span class="line"><span class="keyword">import</span> javax.script.ScriptException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">ScriptEngineManager</span> <span class="variable">scriptEngineManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">      <span class="type">ScriptEngine</span> <span class="variable">nashorn</span> <span class="operator">=</span> scriptEngineManager.getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         nashorn.eval(<span class="string">&quot;print(&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">         result = (Integer) nashorn.eval(<span class="string">&quot;8 + 5 * 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(ScriptException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;脚本执行失败: &quot;</span>+ e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(result.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h2 id="在-JavaScript-中调用-Java-代码"><a href="#在-JavaScript-中调用-Java-代码" class="headerlink" title="在 JavaScript 中调用 Java 代码"></a>在 JavaScript 中调用 Java 代码</h2><p>如果在 JavaScript 中调用 Java 代码，我们就不做过多介绍了，因为介绍起来是一个庞大的工程，简直就是另外一门语言的赶脚。</p><p>直接看一个示例。</p><p>把创建一个 hello.js 文件，然后输入以下内容</p><h4 id="hello-js"><a href="#hello-js" class="headerlink" title="hello.js"></a>hello.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">BigDecimal</span> = <span class="title class_">Java</span>.<span class="title function_">type</span>(<span class="string">&#x27;java.math.BigDecimal&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">amount, percentage</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(amount).<span class="title function_">multiply</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(percentage)).<span class="title function_">divide</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100&quot;</span>), <span class="number">2</span>, <span class="title class_">BigDecimal</span>.<span class="property">ROUND_HALF_EVEN</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result.<span class="title function_">toPlainString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">calculate</span>(<span class="number">568000000000000000023</span>,<span class="number">13.9</span>);</span><br><span class="line"><span class="title function_">print</span>(result);</span><br></pre></td></tr></table></figure><p>然后我们使用 <code>jjs</code> 命令来运行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs hello.js </span><br><span class="line">78952000000000002017.94</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三、Java 8 可选值 java.util.Optional 类</title>
      <link href="/posts/3b70afd5.html"/>
      <url>/posts/3b70afd5.html</url>
      
        <content type="html"><![CDATA[<h1 id="十三、Java-8-可选值-java-util-Optional-类"><a href="#十三、Java-8-可选值-java-util-Optional-类" class="headerlink" title="十三、Java 8 可选值 java.util.Optional 类"></a>十三、Java 8 可选值 java.util.Optional 类</h1><p>在不考虑竖起来的情况下，抛一个硬币，落地时，显示正面的情况只有两种：是正面和不是正面。很多时候，这是一个 「 谓词 」，也就是返回布尔类型 ( bool )。但有时候，我们需要返回另一种类型：存在 和 空。</p><ul><li><strong>存在</strong> 就是硬币落地时显示为正面</li><li><strong>空</strong> 就是硬币落地式显示的不是正面。</li></ul><p>从另一方面说，结果就是 <strong>有值</strong> 和 <strong>空</strong> 。</p><p>一个类，如果可以同时表示 <strong>有值</strong> 和 <strong>空</strong> ，我们称这种类为 <strong>可选类</strong> ( Optional )</p><p>从某些方面说，<code>Optional</code> 类型就是 「那里有一个值，它等于 x，或者那里没有那个值」</p><h2 id="JAVA-8-java-util-Optional-类"><a href="#JAVA-8-java-util-Optional-类" class="headerlink" title="JAVA 8 java.util.Optional 类"></a>JAVA 8 java.util.Optional 类</h2><p>Java 8 在 <code>java.util</code> 包中添加了一个新的类 <code>Optional</code> 。</p><p><code>Optional</code> 类是一个容器，用于表示可能包含也可能不包含非 null 值。如果存在值，<code>isPresent()</code> 方法将返回 <code>true</code>，<code>get()</code> 将返回该值。</p><p><code>Optional</code> 类提供了许多方法用于处理 「 可用 」 或 「 不可用 」 ，而不是简单的检查空值情况。</p><p><code>java.util.Optional</code> 类的声明如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt; extends Object</span><br></pre></td></tr></table></figure><blockquote><p>注意：该类是一个最终类，不能被继承和扩展。</p></blockquote><h2 id="Optional-类提供了以下静态方法来创建-Optional-类的实例"><a href="#Optional-类提供了以下静态方法来创建-Optional-类的实例" class="headerlink" title="Optional 类提供了以下静态方法来创建 Optional 类的实例"></a><code>Optional</code> 类提供了以下静态方法来创建 Optional 类的实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional` 类提供了三个静态方法用于创建 `Optional` 类的实例，这三个方法的返回值都是 `Optional&lt;T&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">empty()</td><td align="center">创建一个空 ( empty ) 的 Optional 类的实例</td></tr><tr><td align="center">of(T value)</td><td align="center">创建一个包含了指定 <code>T</code> 类型的 <code>value</code> 值的 Optional 实例</td></tr><tr><td align="center">ofNullable(T value)</td><td align="center">如果 <code>value</code> 非 <code>null</code> ，则创建一个包含了指定 <code>T</code> 类型的 <code>value</code> 值的 Optional 实例，否则创建一个空的 Optional 实例</td></tr></tbody></table><h2 id="Optional-类提供的方法"><a href="#Optional-类提供的方法" class="headerlink" title="Optional 类提供的方法"></a><code>Optional</code> 类提供的方法</h2><table><thead><tr><th align="center">方法/说明</th></tr></thead><tbody><tr><td align="center"><strong>boolean equals(Object obj)</strong> 判断某个其它的对象是否 「 等于 」 此 Optional</td></tr><tr><td align="center"><strong>Optional<T>s; filter(Predicate&lt;? super T&gt; predicate)</strong> 如果存在值，并且值与给定谓词匹配，则返回描述值的 Optional，否则返回空 Optional</td></tr><tr><td align="center"><strong><U> Optional&lt;U&gst; flatMap(Function&lt;? super T,Optional<U>&gt; mapper)</strong> 如果值存在，则将 <code>map</code> 应用到该值上并返回应用后的结果，如果值不存在，则返回一个空的 Optional</td></tr><tr><td align="center"><strong>T get()</strong> 如果此 Optional 中存在值，则返回该值，否则抛出<code>NoSuchElementException</code> 异常</td></tr><tr><td align="center"><strong>int hashCode()</strong> 如果值存在，则返回当前值的哈希值，如果不存在值，则返回 <code>0</code></td></tr><tr><td align="center"><strong>void ifPresent(Consumer&lt;? super T&gt; consumer)</strong> 如果值存在，则使用该值作为参数调用方法 <code>consumer</code> 。如果值不存在，则什么事情都不做</td></tr><tr><td align="center"><strong>boolean isPresent()</strong> 如果值存在则返回 <code>true</code> ，否则返回 <code>false</code></td></tr><tr><td align="center"><strong><U> Optional<U> map(Function&lt;? super T,? extends U&gt; mapper)</strong> 如果存在值，则将传递的 <code>map</code> 函数应用于该值，如果结果为非 null，则返回描述结果的 Optionals</td></tr><tr><td align="center"><strong>T orElse(T other)</strong> 如果值存在则返回值，否则返回 <code>other</code></td></tr><tr><td align="center"><strong>T orElseGet(Supplier&lt;? extends T&gt; other)</strong> 如果值存在则返回值，否则调用 <code>other</code> 并返回该调用的结果</td></tr><tr><td align="center"><strong><X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt;&gt;exceptionSupplier)</strong> 如果值存在，则返回包含的值，否则抛出由开发者提供的异常</td></tr><tr><td align="center"><strong>String toString()</strong> 返回此 Optional 的非空字符串表示形式，一般用于调试</td></tr></tbody></table><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>我们写一个范例演示下 Optional 类的使用</p><h4 id="OptionalTester-java"><a href="#OptionalTester-java" class="headerlink" title="OptionalTester.java"></a>OptionalTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">OptionalTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionalTester</span>();</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Optional.ofNullable - allows passed parameter to be null.</span></span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Optional.of - throws NullPointerException if passed parameter is null</span></span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">sum</span><span class="params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">//Optional.isPresent - checks the value is present or not</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;First parameter is present: &quot;</span> + a.isPresent());</span><br><span class="line">      System.out.println(<span class="string">&quot;Second parameter is present: &quot;</span> + b.isPresent());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Optional.orElse - returns the value if present otherwise returns</span></span><br><span class="line">      <span class="comment">//the default value passed.</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> a.orElse(Integer.valueOf(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Optional.get - gets the value, value should be present</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> b.get();</span><br><span class="line">      <span class="keyword">return</span> value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First parameter is present: false</span><br><span class="line">Second parameter is present: true</span><br><span class="line">10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二、Java 8 集合遍历 forEach() 方法</title>
      <link href="/posts/8d0e4be4.html"/>
      <url>/posts/8d0e4be4.html</url>
      
        <content type="html"><![CDATA[<h1 id="十二、Java-8-集合遍历-forEach-方法"><a href="#十二、Java-8-集合遍历-forEach-方法" class="headerlink" title="十二、Java 8 集合遍历 forEach() 方法"></a>十二、Java 8 集合遍历 forEach() 方法</h1><p>Java 8 为所有的集合添加了一个新的方法 <code>forEach()</code> ，该方法以只读形式遍历集合所有的元素并为每一个元素执行一个动作。</p><p>我们先来看一个范例</p><h4 id="ForEachTester-java"><a href="#ForEachTester-java" class="headerlink" title="ForEachTester.java"></a>ForEachTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arrays.asList(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B &quot;</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们使用了 <code>forEach</code> 方法遍历列表的每一个元素，并把元素传递给 <code>System.out.println()</code> 方法打印输出到屏幕上。</p><p>对于这个功能，如果我们使用 <code>for ( : )</code> 语法，则会又有些小复杂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>( String it : list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach() 方法"></a>forEach() 方法</h2><p><code>forEach()</code> 方法是 Java 8 为所有集合新增的方法。该方法定义在 <code>java.lang.Iterable</code> 接口中。</p><p><code>java.lang.Iterable</code> 接口是 Java 5 引入的，目的在于为实现该语句的对象提供 「 for-each 循环 」 语句。换句话说，所有实现了该接口的对象都可以使用 <code>for</code> 语句进行迭代。</p><p>当然了，我们今天的重点是 <code>forEach()</code> 这个方法。该方法的原型如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure><p>从函数原型中可以看出，该方法是 <code>java.lang.Iterable</code> 接口的默认方法，所有子类可以不用实现，也没必要实现。</p><p>该方法对 <code>Iterable</code> 中的的每个元素执行给定的操作 ( <code>action</code> )，直到处理完所有元素或操作抛出异常为止。</p><p>除非实现类另有指定，否则操作会按迭代顺序执行（ 如果指定了迭代顺序 ）。且操作抛出的异常将转发给调用者。</p><p>该方法的的实现类似于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (T t : <span class="built_in">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">   action.accept(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范例一：forEach-方法迭代列表"><a href="#范例一：forEach-方法迭代列表" class="headerlink" title="范例一：forEach() 方法迭代列表"></a>范例一：forEach() 方法迭代列表</h2><p>我们写一个范例使用 <code>forEach()</code> 方法和方法引用来实现一个列表的迭代</p><h4 id="ForEachTester-java-1"><a href="#ForEachTester-java-1" class="headerlink" title="ForEachTester.java"></a>ForEachTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>( String it : list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你好</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h2 id="范例二：-forEach-方法迭代一个哈希表"><a href="#范例二：-forEach-方法迭代一个哈希表" class="headerlink" title="范例二： forEach() 方法迭代一个哈希表"></a>范例二： forEach() 方法迭代一个哈希表</h2><p>我们写一个范例使用 <code>forEach()</code> 方法和 Java 8 提供的 lambda 表达式来迭代一个哈希表</p><h4 id="ForEachTester-java-2"><a href="#ForEachTester-java-2" class="headerlink" title="ForEachTester.java"></a>ForEachTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; items = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        items.put(<span class="string">&quot;A&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        items.put(<span class="string">&quot;B&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        items.put(<span class="string">&quot;C&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        items.put(<span class="string">&quot;D&quot;</span>, <span class="number">40</span>);</span><br><span class="line">        items.put(<span class="string">&quot;E&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        items.put(<span class="string">&quot;F&quot;</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        items.forEach((k,v)-&gt;System.out.println(<span class="string">&quot;Item : &quot;</span> + k + <span class="string">&quot; Count : &quot;</span> + v));</span><br><span class="line"></span><br><span class="line">        items.forEach((k,v)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Item : &quot;</span> + k + <span class="string">&quot; Count : &quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;E&quot;</span>.equals(k))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello E&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Item : A Count : 10</span><br><span class="line">Item : B Count : 20</span><br><span class="line">Item : C Count : 30</span><br><span class="line">Item : D Count : 40</span><br><span class="line">Item : E Count : 50</span><br><span class="line">Item : F Count : 60</span><br><span class="line">Item : A Count : 10</span><br><span class="line">Item : B Count : 20</span><br><span class="line">Item : C Count : 30</span><br><span class="line">Item : D Count : 40</span><br><span class="line">Item : E Count : 50</span><br><span class="line">Hello E</span><br><span class="line">Item : F Count : 60</span><br></pre></td></tr></table></figure><h2 id="范例三：forEach-方法迭代一个流"><a href="#范例三：forEach-方法迭代一个流" class="headerlink" title="范例三：forEach() 方法迭代一个流"></a>范例三：forEach() 方法迭代一个流</h2><p>我们写一个范例使用 <code>forEach()</code> 方法迭代一个流，输出流中的所有元素</p><h4 id="ForEachTester-java-3"><a href="#ForEachTester-java-3" class="headerlink" title="ForEachTester.java"></a>ForEachTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arrays.asList(<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B &quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(s-&gt;s.contains(<span class="string">&quot;C&quot;</span>))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一、Java 8 接口静态方法</title>
      <link href="/posts/e3c8b1a4.html"/>
      <url>/posts/e3c8b1a4.html</url>
      
        <content type="html"><![CDATA[<h1 id="十一、Java-8-接口静态方法"><a href="#十一、Java-8-接口静态方法" class="headerlink" title="十一、Java 8 接口静态方法"></a>十一、Java 8 接口静态方法</h1><p>Java 8 除了给接口带来了 默认方法之外，还给接口带来了 <strong>静态方法</strong>。而且，Java 8 中的静态方法还可以有具体的实现。</p><p>我们都知道，在 Java 7 及之前的版本中，接口 <code>interface</code> 是不允许有静态方法声明的，例如下面的代码</p><h4 id="InterfaceStaticMethodTester-java"><a href="#InterfaceStaticMethodTester-java" class="headerlink" title="InterfaceStaticMethodTester.java"></a>InterfaceStaticMethodTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceStaticMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 7 版本下，编译会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceDefaultMethodTester.java:8: 错误: 此处不允许使用修饰符static</span><br><span class="line">        public static void greeter(String name);</span><br><span class="line">                           ^</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p>但是，Java 8 为接口引入了 <strong>静态方法</strong> 功能。在 Java 8 中，接口不仅可以有静态方法声明，还可以有静态方法实现，例如</p><h4 id="InterfaceStaticMethodTester-java-1"><a href="#InterfaceStaticMethodTester-java-1" class="headerlink" title="InterfaceStaticMethodTester.java"></a>InterfaceStaticMethodTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceStaticMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Greeter.greeter(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，A</span><br></pre></td></tr></table></figure><p>但是，Java 8 的接口中的静态方法必须有自己的实现，而不能仅仅是一个接口声明，不然编译是会报错的。</p><p>例如下面的代码</p><h4 id="InterfaceStaticMethodTester-java-2"><a href="#InterfaceStaticMethodTester-java-2" class="headerlink" title="InterfaceStaticMethodTester.java"></a>InterfaceStaticMethodTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceStaticMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceStaticMethodTester.java:9: 错误: 缺少方法主体, 或声明抽象</span><br><span class="line">        public static void greeter(String name);</span><br><span class="line">                           ^</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p>如果添加了 <code>abstract</code> 关键字，其实，<code>abstract</code> 关键和 <code>static</code> 关键字是不兼容的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceStaticMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceStaticMethodTester.java:9: 错误: 非法的修饰符组合: abstract和static</span><br><span class="line">        public abstract static void greeter(String name);</span><br><span class="line">                                    ^</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p>所以，Java 8 支持接口中的静态方法，但静态方法必须有实现，不支持静态方法声明。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、Java 8 接口 ( interface ) 默认方法</title>
      <link href="/posts/efaf0a50.html"/>
      <url>/posts/efaf0a50.html</url>
      
        <content type="html"><![CDATA[<h1 id="十、Java-8-接口-interface-默认方法"><a href="#十、Java-8-接口-interface-默认方法" class="headerlink" title="十、Java 8 接口 ( interface ) 默认方法"></a>十、Java 8 接口 ( interface ) 默认方法</h1><p>总所周知，在 Java 7 和之前的版本中，接口 <code>interface</code> 是不能包含具体的方法实现的。</p><p>比如，下面的代码，是会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDefaultMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Syste.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceDefaultMethodTester.java:10: 错误: 接口抽象方法不能带有主体</span><br><span class="line">        &#123;</span><br><span class="line">        ^</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p>如果一个接口有多个实现，那么每个实现都要重复的一遍一遍的实现接口中的所有方法，岂不是很痛苦。</p><p>在 Java 7 及以前的版本，对于一个接口有多个实现的时候，我们通常的做法就是让所有的实现继承另一个基础类，然后在这个基础类中实现这个方法。</p><p>这就是，为什么 Java 中的 I/O 那么多类的原因，一个庞大的家族体系，每次看到我都头疼。</p><p>但是 Java 8 中，我想应该是 Java 8 核心开发者们也厌倦了这种不断的重复实现接口方法和庞大的类家族体系。竟然在 Java 8 中为接口提供了一个新的功能，允许某个接口方法有个默认实现。</p><h2 id="Java-8-接口的默认方法"><a href="#Java-8-接口的默认方法" class="headerlink" title="Java 8 接口的默认方法"></a>Java 8 接口的默认方法</h2><p>Java 8 为 <strong>接口</strong> ( interface ) 中引入了 「 默认方法 」( default method ) 实现这个新的概念。</p><p>但是，引入的初衷竟然是不是为了解救一个接口多个实现的痛苦，而是为了向后兼容，以便旧接口也可以使用 Java 8 的 lambda 表达式功能。</p><blockquote><p>泪崩～～～～</p></blockquote><p>例如，Java 8 新引入的 <code>forEach</code> 这个功能，其实，<code>List</code> 或 <code>Collection</code> 接口没有声明和实现 <code>forEach</code> 方法。因为，添加此类方法将简单地破坏集合框架实现。</p><blockquote><p>P.S 另一个重要原因，我想，是因为 Java 集合太过庞大，每个都改过去你们应该会手软才对。</p></blockquote><p>既然不能每个类都改过去，那怎么办呢？</p><p>当然是从它们都实现了的共同的祖先处想办法啦。</p><p>跳来跳去，最后选中了接口 <code>interface</code> 。</p><blockquote><p>P.S Java 是基于接口的编程，这个，大家应该没意见吧。除了主入口类，如果一个类没有实现个把接口，都会被认定为格格不入的。</p></blockquote><p>那我们知道，Java 中的接口是不能有具体实现的。哦，不是，是在现行体系下，Java 中没有哪个语法允许接口的方法有具体的实现。</p><p>但是，Java 8 又非常需要这个功能， 那要怎么办呢？</p><p>好吧，拍一下脑袋，灵光一闪，我们可以新增加一个关键字，比如 <code>default</code> ，用于标识这个方法是可以有具体的实现。</p><p>有了 <code>default</code> 关键字，我们就可以在所有集合都实现的接口 <code>Collection&lt;E&gt;</code> 中添加一个 <code>forEach</code> 方法啦。</p><p><strong>这是一个非常重要的新功能，它的出现，Java 8 及以后的版本，添加新功能的速度明显加快了很多</strong></p><h2 id="Java-8-接口默认方法语法"><a href="#Java-8-接口默认方法语法" class="headerlink" title="Java 8 接口默认方法语法"></a>Java 8 接口默认方法语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;你好，S!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从语法中可以看到，一个接口默认方法和普通的接口方法声明有两个不同点：</p><p>1、 接口默认方法可以有具体实现<br>2、 接口默认方法需要使用 <code>default</code> 关键字修饰。</p><h2 id="Java-8-接口默认方法特征"><a href="#Java-8-接口默认方法特征" class="headerlink" title="Java 8 接口默认方法特征"></a>Java 8 接口默认方法特征</h2><p>1、 一个接口可以有任意数量的默认方法，也可以没有默认方法<br>2、 如果一个类实现的两个接口都有一个同名的默认方法，那么该类必须自己实现同样的方法，然后在实现内部可以调用相应接口的方法</p><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>我们写一些范例来演示下 Java 8 中的接口默认方法的特征</p><h3 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h3><p>我们写一个范例简单演示下接口默认方法的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDefaultMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Greeter</span> <span class="variable">gt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeter</span>()&#123;&#125;;</span><br><span class="line">        gt.greeter(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，A</span><br></pre></td></tr></table></figure><h3 id="一个接口可以有多个默认方法"><a href="#一个接口可以有多个默认方法" class="headerlink" title="一个接口可以有多个默认方法"></a>一个接口可以有多个默认方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDefaultMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Greeter</span> <span class="variable">gt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeter</span>()&#123;&#125;;</span><br><span class="line">        gt.greeter(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        gt.greeterEn(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeterEn</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好，A</span><br><span class="line">Hello，A</span><br></pre></td></tr></table></figure><h2 id="一个类实现了多个具有同名的默认方法接口"><a href="#一个类实现了多个具有同名的默认方法接口" class="headerlink" title="一个类实现了多个具有同名的默认方法接口"></a>一个类实现了多个具有同名的默认方法接口</h2><p>如果一个类实现了两个或两个以上的接口，而这些接口有两个或两个以上实现了相同的方法名的默认方法，结果会怎么样呢？ 比如下面这个范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDefaultMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterfaceDefaultMethodTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceDefaultMethodTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Greeter</span> <span class="variable">gt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        gt.greeter(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">Greeter</span>,GreeterEn &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">GreeterEn</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterfaceDefaultMethodTester.java:16: 错误: 类 InterfaceDefaultMethodTester.Hello从类型 Greeter 和 GreeterEn 中继承了greeter(String) 的不相关默认值</span><br><span class="line">    class Hello implements Greeter,GreeterEn &#123;&#125;</span><br><span class="line">    ^</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p>修复这个错误，最简单的方法就是类自己实现一个相同的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDefaultMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterfaceDefaultMethodTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceDefaultMethodTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Greeter</span> <span class="variable">gt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        gt.greeter(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">Greeter</span>,GreeterEn &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">GreeterEn</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，C</span><br></pre></td></tr></table></figure><p>当然了，还可以调用相关接口的默认方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDefaultMethodTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterfaceDefaultMethodTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceDefaultMethodTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Greeter</span> <span class="variable">gt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        gt.greeter(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">Greeter</span>,GreeterEn &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Greeter.<span class="built_in">super</span>.greeter(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">GreeterEn</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greeter</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello，&quot;</span> + name );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，D</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、Java 8 Lambda 表达式 （ 下 ）范例</title>
      <link href="/posts/6fd40a1c.html"/>
      <url>/posts/6fd40a1c.html</url>
      
        <content type="html"><![CDATA[<h1 id="八、Java-8-Lambda-表达式-（-下-）范例"><a href="#八、Java-8-Lambda-表达式-（-下-）范例" class="headerlink" title="八、Java 8 Lambda 表达式 （ 下 ）范例"></a>八、Java 8 Lambda 表达式 （ 下 ）范例</h1><p>经过 Java 8 Lambda 表达式 （ 上 ）- 简介 和 Java 8 Lambda 表达式 （ 中 ）- 外部参数 两个章节的学习，想必你已经对 Java 8 中的 Lambda 表达式已经非常熟悉了。</p><p>本章节我们就来回顾下上面两章节的所学知识，然后写一些范例巩固下。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul><li>lambda 表达式是 java 8 引入的最重要的功能之一。</li><li>lambda 表达式为那些只包含一个方法的接口提供了简洁代码，例如函数接口 ( <code>function interface</code> )。</li><li>lambda 表达式还为集合的迭代提供了一种更为简单的方式。</li><li>对于那些使用匿名类或内部类实现的单个方法接口，在 Java 8 中，可以使用 lambda 表达式来实现。不仅功能相同，而且代码更简洁。</li></ul><p>lambda 表达式真正的原理，是 「 为那些函数接口定义了它们包含的唯一方法，而且返回函数接口的实例 」</p><h3 id="lambda-表达式语法"><a href="#lambda-表达式语法" class="headerlink" title="lambda 表达式语法"></a>lambda 表达式语法</h3><p>lambda 表达式语法非常易于阅读和理解</p><p>lambda 表达式语法看起来像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Argument  part)  -&gt; Body part </span><br></pre></td></tr></table></figure><p>例如</p><p>1、 如果某个方法没有参数，并打印信息，则可能像下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(&quot;Your message&quot;);</span><br></pre></td></tr></table></figure><p>2、 如果某个方法接受两个参数，执行一些业务逻辑并返回值，则看起来可能像下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    (int a, int b) -&gt;  a+b;</span><br><span class="line">表达式会返回 `a+b` 的计算结果</span><br></pre></td></tr></table></figure><p>3、 如果某个方法接受一个参数，并执行一些计算，则可能像下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String s) -&gt;  s + &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure><h2 id="Java-8-lambda-表达式的一些使用范例"><a href="#Java-8-lambda-表达式的一些使用范例" class="headerlink" title="Java 8 lambda 表达式的一些使用范例"></a>Java 8 lambda 表达式的一些使用范例</h2><h3 id="在-Runnable-中使用-lambda-表达式"><a href="#在-Runnable-中使用-lambda-表达式" class="headerlink" title="在 Runnable 中使用 lambda 表达式"></a>在 <code>Runnable</code> 中使用 lambda 表达式</h3><p>下面这个范例中，我们将运行一个 Runnable 线程。</p><p>在 Java 8 之前，在 lambda 表达式出现前，要实现 Runnable 线程，我们需要定义一个实现 Runnable 接口的类来获取 Runnable 对象。</p><h4 id="LambdaTester-java"><a href="#LambdaTester-java" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好，A&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">      thread.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，A</span><br></pre></td></tr></table></figure><p>现在，我们来看看如何使用 lambda 表达式实现相同的对象。</p><h4 id="LambdaTester-java-1"><a href="#LambdaTester-java-1" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;你好，B&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">      thread.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，B</span><br></pre></td></tr></table></figure><p>没有对比，就没有伤害，使用 lambda 表达式真的是简单明了，代码又少。</p><h3 id="在用户自定义的函数接口中使用-lambda-表达式"><a href="#在用户自定义的函数接口中使用-lambda-表达式" class="headerlink" title="在用户自定义的函数接口中使用 lambda 表达式"></a>在用户自定义的函数接口中使用 lambda 表达式</h3><p>在下面这个范例中，我们将创建自己的函数接口，我们先用普通的方式来实现一下</p><h4 id="LambdaTester-java-2"><a href="#LambdaTester-java-2" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Calculator</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2 )</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n1 + n2;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      System.out.println(cal.add(<span class="number">5</span>,<span class="number">8</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><p>匿名内部类实现已经很简洁了。但，如果你看了 lambda 的实现，就会发现，匿名内部类还是有点复杂的</p><h4 id="LambdaTester-java-3"><a href="#LambdaTester-java-3" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">Calculator</span> <span class="variable">cal</span> <span class="operator">=</span> (n1,n2) -&gt; n1 + n2;</span><br><span class="line">      System.out.println(cal.add(<span class="number">5</span>,<span class="number">8</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><p>代码少的有点不像话了…..</p><h3 id="在-Comparator-中使用-lambda-表达式"><a href="#在-Comparator-中使用-lambda-表达式" class="headerlink" title="在 Comparator 中使用 lambda 表达式"></a>在 <code>Comparator</code> 中使用 lambda 表达式</h3><p>现在，我们来看看 <code>Comparator</code> 接口，了解下如何使用 lambda 表达式对包含字符串的集合进行排序。</p><h4 id="LambdaTester-java-4"><a href="#LambdaTester-java-4" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Kabir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;...排序之前...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个 comparator</span></span><br><span class="line">        Comparator&lt;String&gt; comp= (String s1, String s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        Collections.sort(list, comp);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;...排序之后...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...排序之前...</span><br><span class="line">Ram</span><br><span class="line">Shyam</span><br><span class="line">Kabir</span><br><span class="line">...排序之后...</span><br><span class="line">Kabir</span><br><span class="line">Ram</span><br><span class="line">Shyam</span><br></pre></td></tr></table></figure><h3 id="使用-Lambda-表达式实现函数接口来迭代集合"><a href="#使用-Lambda-表达式实现函数接口来迭代集合" class="headerlink" title="使用 Lambda 表达式实现函数接口来迭代集合"></a>使用 Lambda 表达式实现函数接口来迭代集合</h3><p>Java 8 中引入了 <code>java.util.function</code> 包。这个包提供了 <code>java.util.function.Function</code> 接口，我们可以在这个接口的帮助下，使用 Lambda 表达式来迭代集合。</p><p><code>java.util.function.Function</code> 只有一个方法 <code>apply()</code> ，这个方法可以在用户定义的函数中调用。我们可以使用 <code>Function</code> 接口实现一个自定义的打印方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">customShow</span><span class="params">( Function&lt;String,String&gt; fun)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fun.apply(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们就可以使用 Lambda 来实现这个接口了</p><h4 id="LambdaTester-java-5"><a href="#LambdaTester-java-5" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;LambdaTester.Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LambdaTester.Students&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">LambdaTester</span>.Student(<span class="string">&quot;Ram&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">LambdaTester</span>.Student(<span class="string">&quot;Shyam&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">LambdaTester</span>.Student(<span class="string">&quot;Kabir&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="keyword">for</span>(Student st: list)&#123;</span><br><span class="line">            System.out.println(st.customShow(s-&gt;s.getName()+<span class="string">&quot;: &quot;</span>+s.getAge()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  String <span class="title function_">customShow</span><span class="params">(Function&lt;Student,String&gt; fun)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fun.apply(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ram: 20</span><br><span class="line">Shyam: 22</span><br><span class="line">Kabir: 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> 简介 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、Java 8 方法引用</title>
      <link href="/posts/4d9ed831.html"/>
      <url>/posts/4d9ed831.html</url>
      
        <content type="html"><![CDATA[<h1 id="九、Java-8-方法引用"><a href="#九、Java-8-方法引用" class="headerlink" title="九、Java 8 方法引用"></a>九、Java 8 方法引用</h1><p>Java 8 中新增加了 <strong>方法引用</strong> 这个概念。 但，什么是方法引用呢 ？</p><p>我们先来看一个例子，下面这个范例演示了如何遍历字符串列表并进行一些操作</p><h4 id="LambdaTester-java"><a href="#LambdaTester-java" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Kabir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span>(String st: list)&#123;</span><br><span class="line">            System.out.println(st);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为大写</span></span><br><span class="line">        <span class="keyword">for</span>(String st: list)&#123;</span><br><span class="line">            upperAndPrint(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">upperAndPrint</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ram</span><br><span class="line">Shyam</span><br><span class="line">Kabir</span><br><span class="line">RAM</span><br><span class="line">SHYAM</span><br><span class="line">KABIR</span><br></pre></td></tr></table></figure><p>有简洁代码倾向的我们，看到那重复的 <code>for(String st: list)</code> 就会想如何能够直接把代码改的更简洁一些。</p><p>第一个想到的，肯定是使用 Java 8 新增的 lambda 表达式和 <code>forEach</code> 改造下</p><h4 id="LambdaTester-java-1"><a href="#LambdaTester-java-1" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Kabir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        list.forEach(item -&gt; System.out.println(item));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为大写</span></span><br><span class="line">        list.forEach(item -&gt; upperAndPrint(item));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">upperAndPrint</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哇，使用 Lambda 表达式真的是简洁了不少，但是，还能更简单一点吗？</p><p>比如 <code>item -&gt; System.out.println(item)</code> 这个表达式，其实就是调用 <code>System.out.println()</code> 方法，并把 <code>forEach</code> 迭代列表生成的唯一参数 <code>item</code> 传给它而已</p><p>比如 <code>item -&gt; upperAndPrint(item)</code> 这个表达式，也是一样啊，就是把 <code>forEach</code> 生成的唯一参数 <code>item</code> 传给给 <code>upperAndPrint()</code> 方法而已。</p><p>既然这样，我们为什么不能直接传递方法名给 <code>forEach</code> 呢？</p><p>对吧，所以我们改改，改成如下这种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Kabir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        list.forEach(System.out.println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为大写</span></span><br><span class="line">        list.forEach(upperAndPrint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">upperAndPrint</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LambdaTester.java:18: 错误: 找不到符号</span><br><span class="line">        list.forEach(System.out.println);</span><br><span class="line">                               ^</span><br><span class="line">  符号:   变量 println</span><br><span class="line">  位置: 类型为PrintStream的变量 out</span><br><span class="line">LambdaTester.java:21: 错误: 找不到符号</span><br><span class="line">        list.forEach(upperAndPrint);</span><br><span class="line">                     ^</span><br><span class="line">  符号:   变量 upperAndPrint</span><br><span class="line">  位置: 类 LambdaTester</span><br><span class="line">2 个错误</span><br></pre></td></tr></table></figure><p>这在所有的 Java 版本中都会报错，但是自 Java 8 开始，还真是可以直接传递方法名的，只是我们使用的方式不对而已。</p><p>加入我们改成下面这样，就会正确了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Kabir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为大写</span></span><br><span class="line">        list.forEach(LambdaTester::upperAndPrint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">upperAndPrint</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ram</span><br><span class="line">Shyam</span><br><span class="line">Kabir</span><br><span class="line">RAM</span><br><span class="line">SHYAM</span><br><span class="line">KABIR</span><br></pre></td></tr></table></figure><p>哈哈哈，正确了。</p><p>在这个正确的方法中，有两个重点：</p><p>1、 方法名和类名之间不是使用点号 ( <code>.</code> ) 而是使用两个冒号 <code>::</code> 。<br>2、 提供的方法名必须包含类名，如果没有引入该类名，则需要使用全限定类名，也就是需要添加包名作为前缀。</p><p>这种使用方法名做参数的做法，在 Java 8 中称之为 「 方法引用 」</p><h2 id="Java-8-方法引用"><a href="#Java-8-方法引用" class="headerlink" title="Java 8 方法引用"></a>Java 8 方法引用</h2><p><strong>方法引用</strong> 是 Java 8 新增加的功能。方法引用有点类似于 C / C++ 中的 <strong>函数指针</strong> ，通过方法名称指向方法。</p><p>Java 8 中的方法引用通过 <code>::</code> 符号引用方法，而且支持一下类型的方法引用</p><p>1、 静态方法<br>2、 实例方法<br>3、 使用 <code>new</code> 运算符的构造函数。例如 <code>TreeSet::new</code></p><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>我们重写一下上面的范例，演示下如何引用静态方法和实例方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line">        tester.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Kabir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为大写</span></span><br><span class="line">        list.forEach(LambdaTester::upperAndPrint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为小写并输出</span></span><br><span class="line">        list.forEach(<span class="built_in">this</span>::lowerAndPrint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowerAndPrint</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">upperAndPrint</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ram</span><br><span class="line">Shyam</span><br><span class="line">Kabir</span><br><span class="line">RAM</span><br><span class="line">SHYAM</span><br><span class="line">KABIR</span><br><span class="line">ram</span><br><span class="line">shyam</span><br><span class="line">kabir</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、Java 8 Lambda 表达式 （ 中 ）- 外部参数</title>
      <link href="/posts/5fb1bf39.html"/>
      <url>/posts/5fb1bf39.html</url>
      
        <content type="html"><![CDATA[<h1 id="七、Java-8-Lambda-表达式-（-中-）-外部参数"><a href="#七、Java-8-Lambda-表达式-（-中-）-外部参数" class="headerlink" title="七、Java 8 Lambda 表达式 （ 中 ）- 外部参数"></a>七、Java 8 Lambda 表达式 （ 中 ）- 外部参数</h1><p>在 Java 8 Lambda 表达式 （ 上 ）- 简介 章节中我们讲解了 Java 8 Lambda 表达式的一些基础知识。我们也了解 Java 8 Lambda 表达式的一些使用场景：</p><ul><li>Java Lambda 表达式主要用于定义函数接口的内联实现。而函数接口，就是只包含了一个方法的接口。在前一章节中，我们使用了各种类型的 lambda 表达式来定义 <code>MathOperation</code> 接口的 <code>operation</code> 方法。</li><li>Java Lambda 表达式消除了对 <strong>匿名类</strong> 的需求，并为 Java 提供了非常简单但功能强大的函数编程功能。</li></ul><h2 id="Java-8-Lambda-表达式作用域-scope"><a href="#Java-8-Lambda-表达式作用域-scope" class="headerlink" title="Java 8 Lambda 表达式作用域 ( scope )"></a>Java 8 Lambda 表达式作用域 ( scope )</h2><p>因为 Java 8 的 lambda 表达式其实是函数接口的内联实现，也就是匿名内部类，因此，可以引用任何外部的变量或者常量。</p><p>但是，lambda 对这些外部的变量是有要求的： 它们必须使用 <code>final</code> 修饰符修饰。</p><p>如果一个变量允许被第二次赋值，则 Lambda 表达式会抛出编译错误。</p><blockquote><p>注意： 其实这条规则并不是非常严格执行的，普通变量也是可以的，只要，只要不进行第二次赋值就可以。</p><p>注意： 刚刚测试了下，其实只要不是当前作用域声明的变量，可以随意第二次赋值，也不会报错</p></blockquote><h2 id="范例一"><a href="#范例一" class="headerlink" title="范例一"></a>范例一</h2><p>Java 8 lambda 表达式使用外部 <code>final</code> 变量</p><h4 id="LambdaTester-java"><a href="#LambdaTester-java" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;你好，&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，A</span><br></pre></td></tr></table></figure><h3 id="范例二"><a href="#范例二" class="headerlink" title="范例二"></a>范例二</h3><p>lambda 引用的普通的变量也是可以的，只要这个变量没有第二次被赋值，不管是任何地方。</p><h4 id="LambdaTester-java-1"><a href="#LambdaTester-java-1" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;你好，&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，B</span><br></pre></td></tr></table></figure><h2 id="范例三"><a href="#范例三" class="headerlink" title="范例三"></a>范例三</h2><p>如果 lambda 表达式引用的是当前作用域下的普通的变量，而该变量又在某个地方第二次被赋值，则会抛出一个编译错误</p><h4 id="LambdaTester-java-2"><a href="#LambdaTester-java-2" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;你好，&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">      salutation = <span class="string">&quot;Hello，&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LambdaTester.java:8: 错误: 从lambda 表达式引用的本地变量必须是最终变量或实际上的最终变量</span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">                         ^</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><h2 id="范例四"><a href="#范例四" class="headerlink" title="范例四"></a>范例四</h2><p>如果 lambda 表达式引用的变量并不是当前作用域下声明的，也可以随意赋值，并不会报错</p><h4 id="LambdaTester-java-3"><a href="#LambdaTester-java-3" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;你好，&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      salutation = <span class="string">&quot;Hello，&quot;</span>;</span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">      salutation = <span class="string">&quot;你好，&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello，D</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java lambda 表达式可以随意引用外部变量，但如果外部变量是在当前作用域声明的，则一定不可以进行第二次赋值，哪怕是在 lambda 语句之后。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> 简介 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、Java 8 Lambda 表达式 （ 上 ）- 简介</title>
      <link href="/posts/2bc5fe4b.html"/>
      <url>/posts/2bc5fe4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="六、Java-8-Lambda-表达式-（-上-）-简介"><a href="#六、Java-8-Lambda-表达式-（-上-）-简介" class="headerlink" title="六、Java 8 Lambda 表达式 （ 上 ）- 简介"></a>六、Java 8 Lambda 表达式 （ 上 ）- 简介</h1><p>Lambda 表达式在 Java 8 中引入，并且被吹捧为 Java 8 最大的特性。</p><p>Lambda 表达式是函数式编程的的一个重要特性，标志者 Java 向函数式编程迈出了重要的第一步。</p><h2 id="Java-Lambda-表达式语法"><a href="#Java-Lambda-表达式语法" class="headerlink" title="Java Lambda 表达式语法"></a>Java Lambda 表达式语法</h2><p>Java Lambda 表达式的语法结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter -&gt; expression body</span><br></pre></td></tr></table></figure><p>实际代码可能如下</p><h4 id="有参数且只有一条语句时"><a href="#有参数且只有一条语句时" class="headerlink" title="有参数且只有一条语句时"></a>有参数且只有一条语句时</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a,b) -&gt; a + b</span><br></pre></td></tr></table></figure><h4 id="只有一个参数时"><a href="#只有一个参数时" class="headerlink" title="只有一个参数时"></a>只有一个参数时</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a  -&gt; a</span><br></pre></td></tr></table></figure><h4 id="没有参数时"><a href="#没有参数时" class="headerlink" title="没有参数时"></a>没有参数时</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()  -&gt; System.out.println(&quot;搜云库技术团队&quot;)</span><br></pre></td></tr></table></figure><h4 id="有多条语句时"><a href="#有多条语句时" class="headerlink" title="有多条语句时"></a>有多条语句时</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a,b) -&gt; &#123;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    System.out.println(&quot;搜云库技术团队&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这个 Java Lambda 表达式语法，有几个重要的特征需要说明</p><ul><li><strong>可选的参数类型声明</strong> ： 无需声明参数的类型。编译器可以从参数的值推断出相同的值。</li><li><strong>可选的参数周围的小括号 <code>()</code></strong> ： 如果只有一个参数，可以忽略参数周围的小括号。但如果有多个参数，则必须添加小括号。</li><li><strong>可选的大括号 <code>&#123;&#125;</code></strong> : 如果 Lambda 表达式只包含一条语句，那么可以省略大括号。但如果有多条语句，则必须添加大括号。</li><li><strong>可选的 <code>return</code> 关键字</strong> ： 如果 Lambda 表达式只有一条语句，那么编译器会自动 <code>return</code> 该语句最后的结果。但如果显式使用了 <code>return</code> 语句，则必须添加大括号 <code>&#123;&#125;</code> ，哪怕只有一条语句。</li></ul><h2 id="Java-Lambda-表达式的原理"><a href="#Java-Lambda-表达式的原理" class="headerlink" title="Java Lambda 表达式的原理"></a>Java Lambda 表达式的原理</h2><p>后面我们会讲到，Java 8 中的 Lambda 表达式其实是一个特殊的只有一个方法的类的实例。</p><p>这些类是 Java 8 内部已经定义好的，而且实现了 <code>java.lang.FunctionalInterface</code> 这个接口。</p><p>这个 <code>java.lang.FunctionalInterface</code> 接口是一种信息性注解类型，用于标识一个接口类型声明为函数接口（ functional interface ）。</p><p>从某些方面说，Java 8 的 Lambda 表达式是使用匿名内部类的语法创建了 <code>java.util.function</code> 包下相应签名的接口的或者其它自定义的只有一个方法的接口实例。</p><p>但是，实际上，Java 8 中的 Lambda 不仅仅是使用匿名内部类，还使用了 Java 8 接口的默认方法和一些其它的功能。这方面，有空我会写一篇文章。</p><h2 id="范例一：-Java-Lambda-表达式"><a href="#范例一：-Java-Lambda-表达式" class="headerlink" title="范例一： Java Lambda 表达式"></a>范例一： Java Lambda 表达式</h2><p>Lambda 比较常见的使用场景就是 <code>new Runnable</code> 匿名内部类的使用</p><h4 id="LambdaTester-java"><a href="#LambdaTester-java" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        th.start(); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好 </span><br></pre></td></tr></table></figure><h2 id="范例二"><a href="#范例二" class="headerlink" title="范例二"></a>范例二</h2><h4 id="LambdaTester-java-1"><a href="#LambdaTester-java-1" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 有声明参数类型</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">addition</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有声明参数类型</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">subtraction</span> <span class="operator">=</span> (a, b) -&gt; a - b;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 return 语句显式返回值需要添加大括号</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">multiplication</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果只有一条语句，那么可以省略大括号，Java 会返回表达式的值</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">division</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="title function_">operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, MathOperation mathOperation)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 + 5 = 15</span><br><span class="line">10 - 5 = 5</span><br><span class="line">10 x 5 = 50</span><br><span class="line">10 / 5 = 2</span><br></pre></td></tr></table></figure><h2 id="Java-Lambda-表达式的缺点"><a href="#Java-Lambda-表达式的缺点" class="headerlink" title="Java Lambda 表达式的缺点"></a>Java Lambda 表达式的缺点</h2><p>不知道大家有没有从上面的表达式中看到一些端倪，好像，好像 Java 8 中的 Lambda 不能凭空出现。</p><p>Java Lambda 表达式最大的缺点，就是不能像其它语言的 Lambda 表达式一样凭空出现。</p><p>Java 中的 Lambda 表达式需要有一个函数接口声明作为模板。这个模板定义了 Lambda 表达式的参数类型和返回值类型。</p><p>例如下面的代码，我们先要声明一个函数接口类型，然后才能定义一个参数和返回值都一样的表达式</p><h4 id="LambdaTester-java-2"><a href="#LambdaTester-java-2" class="headerlink" title="LambdaTester.java"></a>LambdaTester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先声明一个函数接口</span></span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">LambdaTester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaTester</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 有小括号</span></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;你好，&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略小括号</span></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService2</span> <span class="operator">=</span> (message) -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;你好，&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">      greetService2.sayMessage(<span class="string">&quot;B &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你好，A</span><br><span class="line">你好，B</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> 简介 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、Java 8 java.util.Base64 编码解码</title>
      <link href="/posts/d747711e.html"/>
      <url>/posts/d747711e.html</url>
      
        <content type="html"><![CDATA[<h1 id="五、Java-8-java-util-Base64-编码解码"><a href="#五、Java-8-java-util-Base64-编码解码" class="headerlink" title="五、Java 8 java.util.Base64 编码解码"></a>五、Java 8 java.util.Base64 编码解码</h1><p>Base64 是一种常见的字符编码解码方式，一般用于将二进制数据编码为更具可读性的 Base64 进制格式。</p><p>在 Java 6 （ JDK 1.6 ) 之前， JDK 一直没有包含 Base64 的实现类。因此大部分人都使用 Sum/Orale JDK 里面的 <code>sun.misc.BASE64Encode</code> 和<code>sun.misc.BASE64Decode</code>。然后这也成为很多 Java 开发者的习惯。一直沿用到今天的 Java8 中还有人在用。</p><p>JDK 1.6 虽然添加了 Base64 的实现。但是，非常隐秘，竟然是在 <code>javax.xml.bind</code> 包下的 <code>DatastypeConvert</code> 类中的两个静态方法 <code>parseBase64Binary</code> 和 <code>printBase64Binary</code>.</p><p>Java 8 终于把 Base64 扶正了，在 <code>java.util</code> 包下提供了 <code>Base64</code> 类用于编码和解码 Base64 数据。</p><h2 id="Java-8-java-util-Base64"><a href="#Java-8-java-util-Base64" class="headerlink" title="Java 8 java.util.Base64"></a>Java 8 java.util.Base64</h2><p>Java 8 中的 <code>java.util.Base64</code> 类提供了三种类型的 Base64 编码解码格式：</p><p>1、 <strong>简单类型( simple )</strong> : 编码字符只包含 <code>A-Za-z0-9+/</code> 等 64 个字符。且编码的时候不会包含任何换行符 ( <code>\r</code> 、 <code>\n</code> 、<code>\r\n</code> ）。解码的时候也只会解码 <code>A-Za-z0-9+/</code> 内的字符，超出的则会被拒绝。<br>2、 <strong>URL</strong> : 编码字符只包含 <code>A-Za-z0-9+_</code> 等 64 个字符。和 <strong>简单</strong> 相比，就是把 <code>/</code> 换成了 <code>_</code> 。因为没有 <code>/</code> 字符，因此这种编码方式非常适合 URL 和文件名等。<br>3、 <strong>MIME</strong> : 编码会被映射为 MIME 友好格式：每一行输出不超过 76 个字符，而且每行以 <code>\r\n</code> 符结束。但末尾行并不会包含 <code>\r\n</code>。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><code>java.util.Base64</code> 还包含了两个内部静态类，分别实现了 RFC 4648 和 RFC 2045 中规范的 Base64 编码和解码方式。</p><table><thead><tr><th align="center">内部类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">static class Base64.Decoder</td><td align="center">该类实现使用 RFC 4648 和 RFC 2045 中规定的 Base64 解码方案解码数据</td></tr><tr><td align="center">static class Base64.Encoder</td><td align="center">该类实现使用 RFC 4648 和 RFC 2045 中规定的 Base64 编码方案编码数据</td></tr></tbody></table><p>每个内部类的方法详情，请直接点击相关 URL 查看。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>java.util.Base64</code> 类提供的都是静态方法。下表列出了这些静态方法</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Base64.Decoder getDecoder()</td><td align="center">返回一个 <code>Base64.Decoder</code> 类型的 <strong>简单</strong> 解码器</td></tr><tr><td align="center">Base64.Encoder getEncoder()</td><td align="center">返回一个 <code>Base64.Encoder</code> 类型的 <strong>简单</strong> 编码器</td></tr><tr><td align="center">Base64.Decoder getMimeDecoder()</td><td align="center">返回一个 <code>Base64.Decoder</code> 类型的 <strong>MIME</strong> 解码器</td></tr><tr><td align="center">Base64.Encoder getMimeEncoder()</td><td align="center">返回一个 <code>Base64.Encoder</code> 类型的 <strong>MINE</strong> 编码器</td></tr><tr><td align="center">Base64.Encoder getMimeEncoder( int lineLength, byte[] lineSeparator)</td><td align="center">返回一个 <code>Base64.Encoder</code> 类型的使用特定长度和行分隔符的 <strong>MINE</strong> 编码器</td></tr><tr><td align="center">Base64.Decoder getUrlDecoder()</td><td align="center">返回一个 <code>Base64.Decoder</code> 类型的 URL 和文件名安全的解码器</td></tr><tr><td align="center">Base64.Encoder getUrlEncoder()</td><td align="center">返回一个 <code>Base64.Encoder</code> 类型的 URL 和文件名安全的编码器</td></tr></tbody></table><h2 id="范例一：-基本的编码解码器"><a href="#范例一：-基本的编码解码器" class="headerlink" title="范例一： 基本的编码解码器"></a>范例一： 基本的编码解码器</h2><p>我们写一个范例演示下 <code>getDecoder()</code> 和 <code>getEncoder()</code> 两个方法</p><h4 id="Base64Tester-java"><a href="#Base64Tester-java" class="headerlink" title="Base64Tester.java"></a>Base64Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base64Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">base64encodedString</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(</span><br><span class="line">            <span class="string">&quot;Java 8 Base64 &quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">         System.out.println(base64encodedString);</span><br><span class="line"></span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="type">byte</span>[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(base64decodedBytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(UnsupportedEncodingException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;异常：&quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmF2YSA4IEJhc2U2NCDnvJbnoIHop6PnoIEgLSBKYXZhOOaWsOeJueaApyAtIOeugOWNleaVmeeoiyA=</span><br><span class="line"></span><br><span class="line">Java 8 Base64</span><br></pre></td></tr></table></figure><h2 id="范例二：-URL-和文件名安全的编码解码器"><a href="#范例二：-URL-和文件名安全的编码解码器" class="headerlink" title="范例二： URL 和文件名安全的编码解码器"></a>范例二： URL 和文件名安全的编码解码器</h2><p>我们写一个范例演示下 <code>getUrlEncoder()</code> 和 <code>getUrlDecoder()</code> 两个方法</p><h4 id="Base64Tester-java-1"><a href="#Base64Tester-java-1" class="headerlink" title="Base64Tester.java"></a>Base64Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base64Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">base64encodedString</span> <span class="operator">=</span> Base64.getUrlEncoder().encodeToString(</span><br><span class="line">            <span class="string">&quot;Java 8 Base64 编码解码&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">         System.out.println(base64encodedString);</span><br><span class="line"></span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="type">byte</span>[] base64decodedBytes = Base64.getUrlDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(base64decodedBytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(UnsupportedEncodingException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;异常：&quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmF2YSA4IEJhc2U2NCDnvJbnoIHop6PnoIEgLSBKYXZhOOaWsOeJueaApyAtIOeugOWNleaVmeeoiyA=</span><br><span class="line"></span><br><span class="line">Java 8 Base64</span><br></pre></td></tr></table></figure><h2 id="范例三：MIME-Base64-编码解码器"><a href="#范例三：MIME-Base64-编码解码器" class="headerlink" title="范例三：MIME Base64 编码解码器"></a>范例三：<strong>MIME</strong> Base64 编码解码器</h2><p>我们写一个范例演示下 <code>getMimeEncoder()</code> 和 <code>getMimeDecoder()</code> 两个方法</p><h4 id="Base64Tester-java-2"><a href="#Base64Tester-java-2" class="headerlink" title="Base64Tester.java"></a>Base64Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base64Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">mimeEncodedString</span> <span class="operator">=</span> Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">         System.out.println(mimeEncodedString);</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="type">byte</span>[] base64decodedBytes = Base64.getMimeDecoder().decode(mimeEncodedString);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(base64decodedBytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(UnsupportedEncodingException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;异常：&quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YTU3MTc4MTgtZDFhMS00MjJmLWEyYjgtNTczNzdjMjQ4N2VlZWE4OGVmNTgtNjA3YS00MWY5LTk0</span><br><span class="line">OTAtNjhmNTk1NGIwZGYwYmU0NzA3NjgtOGU0OS00MjBiLWE1YTktYjM1NDcyOTI2MjkwZmExMTdh</span><br><span class="line">NWQtMmRlMi00ZjllLTk1YmUtZWE0MzZlMWEwZmYxZjU2NzE5YWEtMTQzNy00YzZmLTgyNGQtNzFm</span><br><span class="line">YTNkZmVkNjBiNWE4ODViMmYtNjQ3NC00ODY2LThhMDEtMmRkMWY5NmQ5ZDgyMjNiNjAyMjgtNmY3</span><br><span class="line">NC00NGZjLWI3NWItM2Y3YzFmODlmOTIxYjA0ODE2ZjEtYTliZC00NjNkLTkxYWEtZDc3NDlhZGUx</span><br><span class="line">MTU4M2ZiMjJhZDItNzRmNS00Y2IxLTkyNmItY2Y4ZjZkNzc4OWVlZmJiMWQwYjMtZGE0MS00OTBi</span><br><span class="line">LWJmYWMtMTVmNjVmMjIxODc4</span><br><span class="line"></span><br><span class="line">a5717818-d1a1-422f-a2b8-57377c2487eeea88ef58-607a-41f9-9490-68f5954b0df0be470768-8e49-420b-a5a9-b35472926290fa117a5d-2de2-4f9e-95be-ea436e1a0ff1f56719aa-1437-4c6f-824d-71fa3dfed60b5a885b2f-6474-4866-8a01-2dd1f96d9d8223b60228-6f74-44fc-b75b-3f7c1f89f921b04816f1-a9bd-463d-91aa-d7749ade11583fb22ad2-74f5-4cb1-926b-cf8f6d7789eefbb1d0b3-da41-490b-bfac-15f65f221878</span><br></pre></td></tr></table></figure><p>是不是看不出来有 76 个字符分割 ？ 没关系，我们使用另一个 <code>getMimeEncoder(int lineLength, byte[] lineSeparator)</code> 重载方法试一下</p><h4 id="Base64Tester-java-3"><a href="#Base64Tester-java-3" class="headerlink" title="Base64Tester.java"></a>Base64Tester.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base64Tester</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">         <span class="type">String</span> <span class="variable">mimeEncodedString</span> <span class="operator">=</span> Base64.getMimeEncoder(<span class="number">32</span>,<span class="string">&quot;@~@\n\n&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>)).encodeToString(mimeBytes);</span><br><span class="line">         System.out.println(mimeEncodedString);</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="type">byte</span>[] base64decodedBytes = Base64.getMimeDecoder().decode(mimeEncodedString);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(base64decodedBytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span>(UnsupportedEncodingException e) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;异常：&quot;</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">OTkwNWYxY2QtMDBkYS00Y2M1LTgwMGUt@~@</span><br><span class="line"></span><br><span class="line">YjgzYTNkNGZlMGJhNGNmM2Q2YzItODli@~@</span><br><span class="line"></span><br><span class="line">ZS00ZDQyLWI1MzEtYTEwMmRhNzk2ZjBi@~@</span><br><span class="line"></span><br><span class="line">Njk0MWNmMzItYzhlZS00NjE0LTk5NWMt@~@</span><br><span class="line"></span><br><span class="line">ODUwYWM0NDE3YTEyYzdjOTBkMGMtOTZl@~@</span><br><span class="line"></span><br><span class="line">Ny00MjkxLThmOGUtM2JkYWQ4NmY4YjU1@~@</span><br><span class="line"></span><br><span class="line">Nzk2NmZhYjItZmY0YS00ZTc1LThiOTUt@~@</span><br><span class="line"></span><br><span class="line">Mzk5MjAxMWM0ZTMwODdjYzdhYjAtZjEx@~@</span><br><span class="line"></span><br><span class="line">MC00NDAwLTkzN2EtZTU0N2IzYTY5Mzkx@~@</span><br><span class="line"></span><br><span class="line">MzNlNjYyYjAtYTM5Yy00OTJjLWI4Mzgt@~@</span><br><span class="line"></span><br><span class="line">ZmRmYzkyMGM4ZGEzM2NlMWVmOTgtMWI3@~@</span><br><span class="line"></span><br><span class="line">OS00Y2Q0LWI1NGItYjg2MzkzNDhiMDk1@~@</span><br><span class="line"></span><br><span class="line">YmQ1ZjE5NzAtNjliYS00NTRmLTgyNTAt@~@</span><br><span class="line"></span><br><span class="line">MjNlZmZkMGVjOWU0MDk1YTAyM2MtZTUz@~@</span><br><span class="line"></span><br><span class="line">NS00NTZiLTk4ZjQtNTkyMGE0Y2FiYTdk</span><br><span class="line"></span><br><span class="line">9905f1cd-00da-4cc5-800e-b83a3d4fe0ba4cf3d6c2-89be-4d42-b531-a102da796f0b6941cf32-c8ee-4614-995c-850ac4417a12c7c90d0c-96e7-4291-8f8e-3bdad86f8b557966fab2-ff4a-4e75-8b95-3992011c4e3087cc7ab0-f110-4400-937a-e547b3a6939133e662b0-a39c-492c-b838-fdfc920c8da33ce1ef98-1b79-4cd4-b54b-b8639348b095bd5f1970-69ba-454f-8250-23effd0ec9e4095a023c-e535-456b-98f4-5920a4caba7d</span><br></pre></td></tr></table></figure><p>在这个范例中，我们每隔 32 个字符就分割一次。且使用 <code>@~@\n\n</code> 作为分隔符。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、Java8 Runnable Lambda 表达式</title>
      <link href="/posts/2063f33b.html"/>
      <url>/posts/2063f33b.html</url>
      
        <content type="html"><![CDATA[<h1 id="四、Java8-Runnable-Lambda-表达式"><a href="#四、Java8-Runnable-Lambda-表达式" class="headerlink" title="四、Java8 Runnable Lambda 表达式"></a>四、Java8 Runnable Lambda 表达式</h1><p>本章节我们重点来讲讲 Java 8 中的 <code>Runnable</code> Lambda 表达式。众所周知，Java 8 中的 <code>Runable</code> 和 <code>Callable</code> 两个接口都添加了 <code>@FunctionalInterface</code> 注解，因此我们可以直接使用 Lambda 表达式来代替它们的 <code>run()</code> 和 <code>call()</code> 方法</p><h2 id="Runnable-表达式"><a href="#Runnable-表达式" class="headerlink" title="Runnable 表达式"></a>Runnable 表达式</h2><p>Java 8 开始支持 Lambda 表达式，所以，好像，一夜间，所有添加了 <code>@FunctionalInterface</code> 注解的方法都可以使用 Lambda 表达式来创建实例，<code>Runnable</code> 也不例外，我们可以直接使用一个 Lambda 表达式来创建它的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">th.start();</span><br></pre></td></tr></table></figure><p>运行结果输出为 <code>Hello World</code> ，是不是很神奇，如果没有 Lambda 表达式，那么原来的代码可能如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">th.start(); </span><br></pre></td></tr></table></figure><p>如果我们的 Lambda 表达式需要多行代码，可以用一对打括号 <code>&#123;&#125;</code> 扩起来，就像下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    Consumer&lt;Book&gt; style = (Book b) -&gt; System.out.println(<span class="string">&quot;Book Id:&quot;</span>+b.getId() + <span class="string">&quot;, Book Name:&quot;</span>+b.getName());</span><br><span class="line">    list.forEach(style);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 Lambda 表达式需要使用到外部的参数，那么必须对参数添加 <code>final</code> 修饰符表示参数不可变更。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Book&gt; list =  Arrays.asList(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;Ramayan&quot;</span>), <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>, <span class="string">&quot;Mahabharat&quot;</span>));</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    Consumer&lt;Book&gt; style = (Book b) -&gt; System.out.println(<span class="string">&quot;Book Id:&quot;</span>+b.getId() + <span class="string">&quot;, Book Name:&quot;</span>+b.getName());</span><br><span class="line">    list.forEach(style);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们还可以把 <code>Runnable</code> 表达式作为参数传递给 <code>Thread</code> 相关的方法</p><p>我们首先来定一个 <code>Book.java</code> 类</p><h4 id="Book-java"><a href="#Book-java" class="headerlink" title="Book.java"></a>Book.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.runnable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(<span class="type">int</span> id, String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;id:&quot;</span>+id + <span class="string">&quot;, Name:&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>然后在一个 <code>Runnable</code> 中输出书籍的一些信息</p><h4 id="Java8RunnableDemo-java"><a href="#Java8RunnableDemo-java" class="headerlink" title="Java8RunnableDemo.java"></a>Java8RunnableDemo.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.runnable;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.concretepage.Book;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Book&gt; list =  Arrays.asList(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;Ramayan&quot;</span>), <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>, <span class="string">&quot;Mahabharat&quot;</span>));</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> () -&gt; list.forEach(Book::print);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            Consumer&lt;Book&gt; style = (Book b) -&gt; System.out.println(<span class="string">&quot;Book Id:&quot;</span>+b.getId() + <span class="string">&quot;, Book Name:&quot;</span>+b.getName());</span><br><span class="line">            list.forEach(style);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r2);</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:1, Name:Ramayan</span><br><span class="line">Book Id:1, Book Name:Ramayan</span><br><span class="line">id:2, Name:Mahabharat</span><br><span class="line">Book Id:2, Book Name:Mahabharat</span><br></pre></td></tr></table></figure><p>同样的，我们还可以在 <code>ExecutorService</code> 中运行 <code>Runnable</code></p><h4 id="Java8RunnableDemoExecutor-java"><a href="#Java8RunnableDemoExecutor-java" class="headerlink" title="Java8RunnableDemoExecutor.java"></a>Java8RunnableDemoExecutor.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.runnable;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.concretepage.Book;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8RunnableDemoExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Book&gt; list =  Arrays.asList(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;Ramayan&quot;</span>), <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>, <span class="string">&quot;Mahabharat&quot;</span>));</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span>  Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> () -&gt; list.forEach(Book::print);</span><br><span class="line">        service.execute(r1);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            Consumer&lt;Book&gt; style = (Book b) -&gt; System.out.println(<span class="string">&quot;Book Id:&quot;</span>+b.getId() + <span class="string">&quot;, Book Name:&quot;</span>+b.getName());</span><br><span class="line">            list.forEach(style);</span><br><span class="line">        &#125;;</span><br><span class="line">        service.execute(r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> API </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、Java8 Collectors.joining() 详解</title>
      <link href="/posts/76994fd6.html"/>
      <url>/posts/76994fd6.html</url>
      
        <content type="html"><![CDATA[<h1 id="三、Java8-Collectors-joining-详解"><a href="#三、Java8-Collectors-joining-详解" class="headerlink" title="三、Java8 Collectors.joining() 详解"></a>三、Java8 Collectors.joining() 详解</h1><p>本章节我们来详细讲讲 Java 8 流 ( stream ) 收集器 ( Collectors ) 中的 <code>joining()</code> 方法。该方法会返回一个 <code>Collectors</code> 实例，方便在流收集器上的链式操作。</p><p><code>Collectors.joining()</code> 方法以遭遇元素的顺序拼接元素。我们可以传递可选的拼接字符串、前缀和后缀</p><h2 id="joinning-方法定义"><a href="#joinning-方法定义" class="headerlink" title="joinning() 方法定义"></a>joinning() 方法定义</h2><p>假设我们的流中有四个元素 <code>[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]</code>，那么我们就可以按照以下方式来收集它们</p><h3 id="joining"><a href="#joining" class="headerlink" title="joining()"></a>joining()</h3><p><code>joinning()</code> 无参数方法会返回一个 <code>Collectors</code> 实例，并且以空字符串 ( <code>&quot;&quot;</code> ) 来拼接收集到的所有元素</p><h4 id="JoiningExample-java"><a href="#JoiningExample-java" class="headerlink" title="JoiningExample.java"></a>JoiningExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">       String result=  list.stream().collect(Collectors.joining());</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>ABCD</code></p><h2 id="joining-CharSequence-delimiter"><a href="#joining-CharSequence-delimiter" class="headerlink" title="joining(CharSequence delimiter)"></a>joining(CharSequence delimiter)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joining(CharSequence delimiter)` 接受一个参数字符串序列作为拼接符，并返回一个 `Collectors` 实例。假如我们传递的拼接符为 `&quot;-&quot;` 。那么输出结果为 `A-B-C-D</span><br></pre></td></tr></table></figure><h4 id="JoiningExample-java-1"><a href="#JoiningExample-java-1" class="headerlink" title="JoiningExample.java"></a>JoiningExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">       String result=  list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为 <code>A-B-C-D</code></p><h2 id="joining-CharSequence-delimiter-CharSequence-prefix-CharSequence-suffix"><a href="#joining-CharSequence-delimiter-CharSequence-prefix-CharSequence-suffix" class="headerlink" title="joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)"></a>joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)` 方法接受一个字符串序列作为拼接符，并在拼接完成后添加传递的前缀和后缀。假如我们传递的分隔符为 `&quot;-&quot;`，前缀为 `&quot;[&quot;` ， 后缀为 `&quot;]&quot;` 。那么输出结果为 `[A-B-C-D]</span><br></pre></td></tr></table></figure><h4 id="JoiningExample-java-2"><a href="#JoiningExample-java-2" class="headerlink" title="JoiningExample.java"></a>JoiningExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">       String result=  list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为 <code>[A-B-C-D]</code></p><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><h3 id="范例-1-：-如果流中的数据是字符串"><a href="#范例-1-：-如果流中的数据是字符串" class="headerlink" title="范例 1 ： 如果流中的数据是字符串"></a>范例 1 ： 如果流中的数据是字符串</h3><p>下面的代码演示了如何使用 <code>joinning()</code> 的三种重载方法来拼接字符串</p><h4 id="JoiningExampleWithListOfString-java"><a href="#JoiningExampleWithListOfString-java" class="headerlink" title="JoiningExampleWithListOfString.java"></a>JoiningExampleWithListOfString.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningExampleWithListOfString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Ram&quot;</span>,<span class="string">&quot;Shyam&quot;</span>,<span class="string">&quot;Shiv&quot;</span>,<span class="string">&quot;Mahesh&quot;</span>);</span><br><span class="line">        String result=  list.stream().collect(Collectors.joining());</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        result=  list.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        System.out.println(result);        </span><br><span class="line">        result=  list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>));</span><br><span class="line">        System.out.println(result);        </span><br><span class="line">    &#125;       </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RamShyamShivMahesh</span><br><span class="line">Ram,Shyam,Shiv,Mahesh</span><br><span class="line">[Ram-Shyam-Shiv-Mahesh] </span><br></pre></td></tr></table></figure><h2 id="范例-2-如果流中的数据是对象"><a href="#范例-2-如果流中的数据是对象" class="headerlink" title="范例 2: 如果流中的数据是对象"></a>范例 2: 如果流中的数据是对象</h2><p>如果流中的数据是对象，下面的代码演示了如何拼接它们。</p><p>首先，我们创建一个 <code>Person</code> 类</p><h4 id="Person-java"><a href="#Person-java" class="headerlink" title="Person.java"></a>Person.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Person&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Ram&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Shyam&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Shiv&quot;</span>, <span class="number">25</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Mahesh&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>然后创建一个 <code>Person</code> 对象流</p><h4 id="JoiningExampleWithListOfObject-java"><a href="#JoiningExampleWithListOfObject-java" class="headerlink" title="JoiningExampleWithListOfObject.java"></a>JoiningExampleWithListOfObject.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningExampleWithListOfObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = Person.getList();</span><br><span class="line">        System.out.println(<span class="string">&quot;--Join person name--&quot;</span>);</span><br><span class="line">        String result=  list.stream().map(p -&gt; p.getName()).collect(Collectors.joining());</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        result=  list.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        result=  list.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--Join person age--&quot;</span>);</span><br><span class="line">        result=  list.stream().map(p -&gt; String.valueOf(p.getAge())).collect(Collectors.joining());</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        result=  list.stream().map(p -&gt; String.valueOf(p.getAge())).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        result=  list.stream().map(p -&gt; String.valueOf(p.getAge())).collect(Collectors.joining(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>));</span><br><span class="line">        System.out.println(result);       </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--Join person name-age--&quot;</span>);</span><br><span class="line">        result=  list.stream().map(p -&gt; p.getName()+<span class="string">&quot;-&quot;</span> + p.getAge()).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        result=  list.stream().map(p -&gt; p.getName()+<span class="string">&quot;-&quot;</span> + p.getAge()).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>));</span><br><span class="line">        System.out.println(result);        </span><br><span class="line">    &#125;       </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--Join person name--</span><br><span class="line">RamShyamShivMahesh</span><br><span class="line">Ram|Shyam|Shiv|Mahesh</span><br><span class="line">[Ram-Shyam-Shiv-Mahesh]</span><br><span class="line">--Join person age--</span><br><span class="line">23202530</span><br><span class="line">23|20|25|30</span><br><span class="line">[23-20-25-30]</span><br><span class="line">--Join person name-age--</span><br><span class="line">Ram-23|Shyam-20|Shiv-25|Mahesh-30</span><br><span class="line">[Ram-23|Shyam-20|Shiv-25|Mahesh-30] </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Collectors </tag>
            
            <tag> API </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Java8 IntStream,LongStream,DoubleStream</title>
      <link href="/posts/edc65d6d.html"/>
      <url>/posts/edc65d6d.html</url>
      
        <content type="html"><![CDATA[<h1 id="二、Java8-IntStream-LongStream-DoubleStream"><a href="#二、Java8-IntStream-LongStream-DoubleStream" class="headerlink" title="二、Java8 IntStream,LongStream,DoubleStream"></a>二、Java8 IntStream,LongStream,DoubleStream</h1><p>本章节我们提供一些 Java 8 中的 <code>IntStream</code>、<code>LongStream</code> 和 <code>DoubleStream</code> 使用范例。<code>IntStream</code>、<code>LongStream</code> 和 <code>DoubleStream</code> 分别表示原始 <code>int</code> 流、 原始 <code>long</code> 流 和 原始 <code>double</code> 流。</p><p>这三个原始流类提供了大量的方法用于操作流中的数据，同时提供了相应的静态方法来初始化它们自己。</p><p>这三个原始流类都在 <code>java.util.stream</code> 命名空间下。</p><h2 id="java-util-stream-IntStream"><a href="#java-util-stream-IntStream" class="headerlink" title="java.util.stream.IntStream"></a>java.util.stream.IntStream</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.IntStream` 是一个原始整数值序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作，比如 `max()` 或 `average()</span><br></pre></td></tr></table></figure><h3 id="聚合方法"><a href="#聚合方法" class="headerlink" title="聚合方法"></a>聚合方法</h3><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">rangeClosed(a,b)</td><td align="center">返回子序列 [a,b]，包含起始值，增长步值为 1</td></tr><tr><td align="center">range(a,b)</td><td align="center">返回子序列 [a,b)，左闭右开，意味着不包括 b</td></tr><tr><td align="center">sum</td><td align="center">计算所有元素的总和</td></tr><tr><td align="center">sorted</td><td align="center">排序元素</td></tr></tbody></table><p>这些方法使用示例如下</p><h4 id="IntStreamDemo-java"><a href="#IntStreamDemo-java" class="headerlink" title="IntStreamDemo.java"></a>IntStreamDemo.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--Using IntStream.rangeClosed--&quot;</span>);</span><br><span class="line">        IntStream.rangeClosed(<span class="number">13</span>, <span class="number">15</span>).map(n-&gt;n*n).forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Using IntStream.range--&quot;</span>);</span><br><span class="line">        IntStream.range(<span class="number">13</span>,<span class="number">15</span>).map(n-&gt;n*n).forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Sum of range 1 to 10--&quot;</span>);</span><br><span class="line">        System.out.print(IntStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>).sum());</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Sorted number--&quot;</span>);</span><br><span class="line">        IntStream.of(<span class="number">13</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>).sorted().forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--Using IntStream.rangeClosed--</span><br><span class="line">169 196 225 </span><br><span class="line">--Using IntStream.range--</span><br><span class="line">169 196 </span><br><span class="line">--Sum of range 1 to 10--</span><br><span class="line">55</span><br><span class="line">--Sorted number--</span><br><span class="line">2 4 8 13 15  </span><br></pre></td></tr></table></figure><h2 id="LongStream"><a href="#LongStream" class="headerlink" title="LongStream"></a>LongStream</h2><p><code>java.util.stream.LongStream</code> 是一个原始长整型值序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作。其实，它的使用方式和 <code>IntStream</code> 一样，因为提供的方法也一样，我们就不做展开了，直接看范例</p><h4 id="LongStreamDemo-java"><a href="#LongStreamDemo-java" class="headerlink" title="LongStreamDemo.java"></a>LongStreamDemo.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--Using LongStream.rangeClosed--&quot;</span>);</span><br><span class="line">        LongStream.rangeClosed(<span class="number">13</span>, <span class="number">15</span>).map(n-&gt;n*n).forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Using LongStream.range--&quot;</span>);</span><br><span class="line">        LongStream.range(<span class="number">13</span>,<span class="number">15</span>).map(n-&gt;n*n).forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Sum of range 1 to 10--&quot;</span>);</span><br><span class="line">        System.out.print(LongStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>).sum());</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Sorted number--&quot;</span>);</span><br><span class="line">        LongStream.of(<span class="number">13</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>).sorted().forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--Using LongStream.rangeClosed--</span><br><span class="line">169 196 225 </span><br><span class="line">--Using LongStream.range--</span><br><span class="line">169 196 </span><br><span class="line">--Sum of range 1 to 10--</span><br><span class="line">55</span><br><span class="line">--Sorted number--</span><br><span class="line">2 4 8 13 15 </span><br></pre></td></tr></table></figure><h2 id="DoubleStream"><a href="#DoubleStream" class="headerlink" title="DoubleStream"></a>DoubleStream</h2><p><code>java.util.stream.LongStream</code> 是一个原始双精度浮点型序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作。它的使用方式和 <code>IntStream</code> 一样，提供的方法也一样，除此之外，还额外提供了几个聚合方法</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">average</td><td align="center">计算平均值</td></tr><tr><td align="center">max</td><td align="center">查找最大值</td></tr></tbody></table><p>下面的代码是 DoubleStream 类的一些简单的使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.function.DoublePredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--Using DoubleStream.of--&quot;</span>);</span><br><span class="line">        DoubleStream.of(<span class="number">5.33</span>,<span class="number">2.34</span>,<span class="number">5.32</span>,<span class="number">2.31</span>,<span class="number">3.51</span>).map(d-&gt;d*<span class="number">1.5</span>).forEach(s-&gt;System.out.print(s +<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;\n--Using DoubleStream.average--&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">val</span> <span class="operator">=</span> DoubleStream.of(<span class="number">12.1</span>,<span class="number">11.2</span>,<span class="number">13.3</span>).average().getAsDouble();</span><br><span class="line">        System.out.println(val);</span><br><span class="line">        System.out.println(<span class="string">&quot;--Using DoubleStream.max--&quot;</span>);</span><br><span class="line">        val = DoubleStream.of(<span class="number">12.1</span>,<span class="number">11.2</span>,<span class="number">13.3</span>).max().getAsDouble();</span><br><span class="line">        System.out.println(val);</span><br><span class="line">        System.out.println(<span class="string">&quot;--Using DoubleStream.filter--&quot;</span>);</span><br><span class="line">        <span class="type">DoublePredicate</span> <span class="variable">range</span> <span class="operator">=</span> d -&gt; d &gt; <span class="number">12.11</span> &amp;&amp; d &lt; <span class="number">12.99</span>;        </span><br><span class="line">        DoubleStream.of(<span class="number">12.1</span>,<span class="number">11.2</span>,<span class="number">12.3</span>).filter(range).forEach(d-&gt;System.out.print(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--Using DoubleStream.of--</span><br><span class="line">7、995 3.51 7.98 3.465 5.265 </span><br><span class="line">--Using DoubleStream.average--</span><br><span class="line">12、200000000000001</span><br><span class="line">--Using DoubleStream.max--</span><br><span class="line">13、3</span><br><span class="line">--Using DoubleStream.filter--</span><br><span class="line">12、3 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Collectors </tag>
            
            <tag> API </tag>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Java8 收集器 – java.util.stream.Collectors</title>
      <link href="/posts/c2245ef4.html"/>
      <url>/posts/c2245ef4.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java8-收集器-–-java-util-stream-Collectors"><a href="#一、Java8-收集器-–-java-util-stream-Collectors" class="headerlink" title="一、Java8 收集器 – java.util.stream.Collectors"></a>一、Java8 收集器 – java.util.stream.Collectors</h1><p>Java 8 流的新类 <code>java.util.stream.Collectors</code> 实现了 <code>java.util.stream.Collector</code> 接口，同时又提供了大量的方法对流 ( stream ) 的元素执行 <code>map and reduce</code> 操作，或者统计操作。</p><p>本章节，我们就来看看那些常用的方法，顺便写几个示例练练手。</p><h2 id="Collectors-averagingDouble"><a href="#Collectors-averagingDouble" class="headerlink" title="Collectors.averagingDouble()"></a>Collectors.averagingDouble()</h2><p><code>Collectors.averagingDouble()</code> 方法将流中的所有元素视为 <code>double</code> 类型并计算他们的平均值。该方法返回的是同一个 <code>Collectors</code> 实例，因此可以进行链式操作。</p><p><code>Collectors.averagingDouble()</code> 接受一个参数，这个参数是一个 lambda 表达式，用于对所有的元素执行一个 <code>map</code> 操作。</p><p>Java 所有集合的 <code>stream().collect()</code> 可以接受一个收集器实例作为其参数并返回该收集器的计算结果</p><p>例如下面的代码，<code>collect()</code> 方法会把所有的元素收集起来然后传递给 <code>Collectors.averagingDouble(d-&gt;d*2)</code> 收集器，对每个元素执行 <code>*2</code> 操作后计算平均值</p><h4 id="AveragingDoubleExample-java"><a href="#AveragingDoubleExample-java" class="headerlink" title="AveragingDoubleExample.java"></a>AveragingDoubleExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AveragingDoubleExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingDouble(d-&gt;d*<span class="number">2</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>5.0</code></p><h2 id="Collectors-averagingInt"><a href="#Collectors-averagingInt" class="headerlink" title="Collectors.averagingInt()"></a>Collectors.averagingInt()</h2><p><code>Collectors.averagingInt()</code> 方法和 <code>Collectors.averagingDouble()</code> 一样，不同的是它把流中的所有元素看成是 <code>int</code> 类型，并返回一个浮点类型的平均值</p><h4 id="AveragingIntExample-java"><a href="#AveragingIntExample-java" class="headerlink" title="AveragingIntExample.java"></a>AveragingIntExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AveragingIntExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingInt(v-&gt;v*<span class="number">2</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>5.0</code></p><h2 id="Collectors-averagingLong"><a href="#Collectors-averagingLong" class="headerlink" title="Collectors.averagingLong()"></a>Collectors.averagingLong()</h2><p><code>Collectors.averagingLong()</code> 方法也和 <code>Collectors.averagingDouble()</code> 类似，不同的是它把流中的所有元素看成是 <code>long</code> 类型，并返回一个 <code>double</code> 类型的平均值</p><h4 id="AveragingLongExample-java"><a href="#AveragingLongExample-java" class="headerlink" title="AveragingLongExample.java"></a>AveragingLongExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech..util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AveragingLongExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingLong(v-&gt;v*<span class="number">2</span>));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>5.0</code></p><h2 id="Collectors-collectingAndThen"><a href="#Collectors-collectingAndThen" class="headerlink" title="Collectors.collectingAndThen()"></a>Collectors.collectingAndThen()</h2><p><code>Collectors.collectingAndThen()</code> 函数应该最像 <code>map and reduce</code> 了，它可接受两个参数，第一个参数用于 <code>reduce</code> 操作，而第二参数用于 <code>map</code> 操作。</p><p>也就是，先把流中的所有元素传递给第二个参数，然后把生成的集合传递给第一个参数来处理。</p><p>例如下面的代码，先把 <code>[1,2,3,4]</code> 这个集合传递给 <code>s-&gt; s*s</code> lambda 表达式，计算得出结果为 <code>[1,4,9,16]</code> ，然后再把 <code>[1,4,9,16]</code> 传递给 <code>v-&gt;v*2</code> 表达式，计算得出 <code>[2,8,18,32]</code> ，然后传递给 <code>Collectors.averagingLong()</code> 计算得到结果为 <code>25.0</code></p><h4 id="CollectingAndThenExample-java"><a href="#CollectingAndThenExample-java" class="headerlink" title="CollectingAndThenExample.java"></a>CollectingAndThenExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech..util.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectingAndThenExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.collectingAndThen(Collectors.averagingLong(v-&gt;v*<span class="number">2</span>),</span><br><span class="line">                s-&gt; s*s));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="Collectors-counting"><a href="#Collectors-counting" class="headerlink" title="Collectors.counting()"></a>Collectors.counting()</h2><p><code>Collectors.counting()</code> 用于统计流中元素的个数。</p><h4 id="CountingExample-java"><a href="#CountingExample-java" class="headerlink" title="CountingExample.java"></a>CountingExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">       <span class="type">long</span> result=  list.stream().collect(Collectors.counting());</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>4</code></p><h2 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining()"></a>Collectors.joining()</h2><p><code>Collectors.joining()</code> 方法用某个指定的拼接字符串把所有元素拼接成一个字符串，并添加可选的前缀和后缀</p><h4 id="JoiningExample-java"><a href="#JoiningExample-java" class="headerlink" title="JoiningExample.java"></a>JoiningExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>);</span><br><span class="line">       String result=  list.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;(&quot;</span>,<span class="string">&quot;)&quot;</span>));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>(A,B,C,D)</code></p><h2 id="Collectors-maxBy-和-Collectors-minBy"><a href="#Collectors-maxBy-和-Collectors-minBy" class="headerlink" title="Collectors.maxBy() 和 Collectors.minBy()"></a>Collectors.maxBy() 和 Collectors.minBy()</h2><p><code>Collectors.maxBy()</code> 和 <code>Collectors.minBy()</code> 两个方法分别用于计算流中所有元素的最大值和最小值。</p><p>两个方法都可以接受一个比较器作为参数，用于如何计算最大值或最小值</p><h4 id="MaxByMinByExample-java"><a href="#MaxByMinByExample-java" class="headerlink" title="MaxByMinByExample.java"></a>MaxByMinByExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxByMinByExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = Arrays.asList(<span class="number">30</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">35</span>);</span><br><span class="line">       <span class="comment">//Get Max       </span></span><br><span class="line">       list.stream().collect(Collectors.maxBy(<span class="keyword">new</span> <span class="title class_">MaxByMinByExample</span>().<span class="keyword">new</span> <span class="title class_">IntegerComp</span>()))</span><br><span class="line">               .ifPresent(i-&gt;System.out.println(i));</span><br><span class="line">       <span class="comment">//Get Min</span></span><br><span class="line">       list.stream().collect(Collectors.minBy(<span class="keyword">new</span> <span class="title class_">MaxByMinByExample</span>().<span class="keyword">new</span> <span class="title class_">IntegerComp</span>()))</span><br><span class="line">               .ifPresent(i-&gt;System.out.println(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">IntegerComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer i1, Integer i2)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(i1 &gt;=i2 )&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">35</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="Collectors-summingInt"><a href="#Collectors-summingInt" class="headerlink" title="Collectors.summingInt()"></a>Collectors.summingInt()</h2><p><code>Collectors.summingInt()</code> 方法将流中的所有元素视为 <code>int</code> 类型，并计算所有元素的总和 ( sum )</p><h4 id="SummingIntExample-java"><a href="#SummingIntExample-java" class="headerlink" title="SummingIntExample.java"></a>SummingIntExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummingIntExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = Arrays.asList(<span class="number">30</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">35</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.summingInt(i-&gt;i));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果我为 <code>95</code></p><h2 id="Collectors-summingLong"><a href="#Collectors-summingLong" class="headerlink" title="Collectors.summingLong()"></a>Collectors.summingLong()</h2><p><code>Collectors.summingLong()</code> 将流中的所有元素视为 <code>long</code> 类型，并计算所有元素的总和</p><h4 id="SummingLongExample-java"><a href="#SummingLongExample-java" class="headerlink" title="SummingLongExample.java"></a>SummingLongExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummingLongExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add((<span class="type">long</span>)<span class="number">340</span>);</span><br><span class="line">       list.add((<span class="type">long</span>)<span class="number">240</span>);</span><br><span class="line">       list.add((<span class="type">long</span>)<span class="number">360</span>);</span><br><span class="line">       <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.summingLong(l-&gt;l));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collectors-summingDouble"><a href="#Collectors-summingDouble" class="headerlink" title="Collectors.summingDouble()"></a>Collectors.summingDouble()</h2><p><code>Collectors.summingDouble()</code> 将流中的所有元素视为 <code>double</code> 类型，并计算所有元素的总和</p><h4 id="SummingDoubleExample-java"><a href="#SummingDoubleExample-java" class="headerlink" title="SummingDoubleExample.java"></a>SummingDoubleExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummingDoubleExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Double&gt; list = Arrays.asList(<span class="number">340.5</span>,<span class="number">234.56</span>,<span class="number">672.76</span>);</span><br><span class="line">       <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().collect(Collectors.summingDouble(d-&gt;d));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 <code>1247.82</code></p><p>也许你也注意到了，这三个函数的结果的类型，就是它们如何看待元素的类型。</p><h2 id="Collectors-toList"><a href="#Collectors-toList" class="headerlink" title="Collectors.toList()"></a>Collectors.toList()</h2><p><code>Collectors.toList()</code> 将流中的所有元素导出到一个列表 ( List ) 中</p><h4 id="ToListExample-java"><a href="#ToListExample-java" class="headerlink" title="ToListExample.java"></a>ToListExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; list = Stream.of(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>).collect(Collectors.toList());</span><br><span class="line">       list.forEach(s-&gt;System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AA</span><br><span class="line">BB</span><br><span class="line">CC</span><br></pre></td></tr></table></figure><h2 id="Collectors-toSet"><a href="#Collectors-toSet" class="headerlink" title="Collectors.toSet()"></a>Collectors.toSet()</h2><p><code>Collectors.toSet()</code> 把流中的所有元素导出到一个集合 ( Set ) 中，并排除重复的元素 ( Set 的特性 )</p><h4 id="ToSetExample-java"><a href="#ToSetExample-java" class="headerlink" title="ToSetExample.java"></a>ToSetExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToSetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       Set&lt;String&gt; set = Stream.of(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">       set.forEach(s-&gt;System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AA</span><br><span class="line">BB</span><br></pre></td></tr></table></figure><h2 id="Collectors-toMap"><a href="#Collectors-toMap" class="headerlink" title="Collectors.toMap()"></a>Collectors.toMap()</h2><p><code>Collectors.toMap()</code> 将流中的所有元素导出到一个哈希表 ( Map ) 中。该方法接受两个参数，第一个参数用于生成键 ( key ) ，第二个参数用于生成值 ( value )。两个参数都是 Lambda 表达式。</p><h4 id="ToMapExample-java"><a href="#ToMapExample-java" class="headerlink" title="ToMapExample.java"></a>ToMapExample.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       Map&lt;String,String&gt; map = Stream.of(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>).collect(Collectors.toMap(k-&gt;k, v-&gt;v+v));</span><br><span class="line">       map.forEach((k,v)-&gt;System.out.println(<span class="string">&quot;key:&quot;</span>+k +<span class="string">&quot;  value:&quot;</span>+v));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key:CC  value:CCCC</span><br><span class="line">key:BB  value:BBBB</span><br><span class="line">key:AA  value:AAAA</span><br></pre></td></tr></table></figure><h2 id="Collectors-mapping"><a href="#Collectors-mapping" class="headerlink" title="Collectors.mapping()"></a>Collectors.mapping()</h2><p><code>Collectors.mapping()</code> 一般用于多重 <code>map and reduce</code> 中。 Java 文档中描述的原型如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(Function&lt;? <span class="built_in">super</span> T,? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; mapper, Collector&lt;? <span class="built_in">super</span> U,A,R&gt; downstream)</span><br></pre></td></tr></table></figure><p>第一个参数用于 <code>map</code> ，第二个参数用于 <code>reduce</code></p><h4 id="MappingDemo-java"><a href="#MappingDemo-java" class="headerlink" title="MappingDemo.java"></a>MappingDemo.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souyunku.tech.util.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = Person.getList();</span><br><span class="line">        Map&lt;Integer, String&gt; nameByAge</span><br><span class="line">           = list.stream().collect(Collectors.groupingBy(Person::getAge, </span><br><span class="line">                   Collectors.mapping(Person::getName, Collectors.joining(<span class="string">&quot;,&quot;</span>))));</span><br><span class="line">        nameByAge.forEach((k,v)-&gt;System.out.println(<span class="string">&quot;Age:&quot;</span>+k +<span class="string">&quot;  Persons: &quot;</span>+v));</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Person&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Ram&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Shyam&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Shiv&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Mahesh&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Age:20  Persons: Shyam,Shiv</span><br><span class="line">Age:30  Persons: Ram,Mahesh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Collectors </tag>
            
            <tag> API </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十九、Java并发 Java wait() 和 notify() 方法</title>
      <link href="/posts/2b1d309b.html"/>
      <url>/posts/2b1d309b.html</url>
      
        <content type="html"><![CDATA[<h1 id="十九、Java并发-Java-wait-和-notify-方法"><a href="#十九、Java并发-Java-wait-和-notify-方法" class="headerlink" title="十九、Java并发 Java wait() 和 notify() 方法"></a>十九、Java并发 Java wait() 和 notify() 方法</h1><p>大家有没有发现，其实 「 一文秒懂 」 系列讲述的都是多线程并发开发的问题。这个话题太大了，估计没有上百篇文章都解释不清楚。</p><p>本文，我们来讲解下 Java 并发中的基础的基础，核心的核心，Java 并发编程中的最基本的机制之一 – 「 线程同步 」</p><p>为了方便你理解并发编程中的各种概念和术语，我们首先会来一阵扫盲，讨论一些基本的并发相关术语和方法。接着，我们将开发一个简单的应用程序，并在合格应用程序里处理并发问题，以方便大家理解和巩固 <code>wait()</code> 和 <code>notify()</code>。</p><h2 id="Java-中的线程同步-Thread-Synchronization"><a href="#Java-中的线程同步-Thread-Synchronization" class="headerlink" title="Java 中的线程同步 ( Thread Synchronization )"></a>Java 中的线程同步 ( Thread Synchronization )</h2><p>在并发编程中，在多线程环境下，多个线程可能会尝试修改同一资源。如果线程管理不当，这显然会导致一致性问题。</p><h3 id="Java-中的哨兵块-guarded-block"><a href="#Java-中的哨兵块-guarded-block" class="headerlink" title="Java 中的哨兵块 ( guarded block )"></a>Java 中的哨兵块 ( guarded block )</h3><p>Java 中，可以用来协调多个线程操作的一个工具是 「 哨兵块 」。这个哨兵块会在恢复执行前检查特定条件。</p><p>基于这种哨兵检查的思想，Java 在所有类的基类 <code>Object</code> 中提供了两个方法</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>Object.wait()</code></td><td align="center">暂停一个线程</td></tr><tr><td align="center"><code>Object.notify()</code></td><td align="center">唤醒一个线程</td></tr></tbody></table><p>是不是有点难以理解，别担心，看下面这个图，这个图描绘了线程的的生命周期。</p><p><img src="https://s3.uuu.ovh/imgs/2022/05/04/52f9c7edb1f91071.png" alt="img_1.png"></p><p>虽然从上图中可以看出，有多个方法可以控制一个线程的生命周期，但本章节，我们只讨论 <code>notify()</code> 方法和 <code>wait()</code> 方法</p><h2 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait() 方法"></a>wait() 方法</h2><p>对照上图，简单的说，当我们调用 <code>wait()</code> 时会强制当前线程等待，直到某个其它线程在同一个对象上调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法。</p><p>因此，当前线程必须拥有对象的监视器。根据 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify--">Java docs</a> 的说法，这可能发生在</p><ul><li>我们已经为给定对象执行了同步实例方法</li><li>我们已经在给定对象上执行了 synchronized 块的主体</li><li>通过为 Class 类型的对象执行同步静态方法</li></ul><blockquote><p>请注意，一次只有一个活动线程可以拥有对象的监视器。</p></blockquote><p>除了无参数 wait() 方法外，Java 还重载了另一个 wait() 方法</p><h3 id="wait-方法-1"><a href="#wait-方法-1" class="headerlink" title="wait() 方法"></a>wait() 方法</h3><p><code>wait()</code> 方法导致当前线程无限期地等待，直到另一个线程调用此对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法</p><h3 id="wait-long-timeout-方法"><a href="#wait-long-timeout-方法" class="headerlink" title="wait(long timeout) 方法"></a>wait(long timeout) 方法</h3><p>使用此方法，我们可以指定一个超时，在此之后将自动唤醒线程。</p><p>当然了，我们可以在到达超时之前使用 <code>notify()</code> 或 <code>notifyAll()</code> 提前唤醒线程。</p><p>请注意，调用 <code>wait(0)</code> 与调用 <code>wait()</code> 相同</p><h3 id="wait-long-timeout-int-nanos"><a href="#wait-long-timeout-int-nanos" class="headerlink" title="wait(long timeout, int nanos)"></a>wait(long timeout, int nanos)</h3><p>这是与 <code>wait(long timeout)</code> 提供相同功能的签名，唯一的区别是我们可以提供更高的精度。</p><p>该方法计算超时之间的方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总超时时间（以纳秒为单位）= 1_000_000 * 超时 + nanos</span><br></pre></td></tr></table></figure><h2 id="notify-或-notifyAll-方法"><a href="#notify-或-notifyAll-方法" class="headerlink" title="notify() 或 notifyAll() 方法"></a><code>notify()</code> 或 <code>notifyAll()</code> 方法</h2><p><code>notify()</code> 和 <code>notifyAll()</code> 方法用于唤醒等待访问此对象监视器的线程。</p><p>它们以不同的方式通知等待线程。</p><h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify() 方法"></a>notify() 方法</h3><p>对于在此对象的监视器上等待的所有线程（通过使用任何一个重载 <code>wait()</code> 方法 ），<code>notify()</code> 通知将会随机唤醒任何一个线程。</p><p>也就是说，我们并不能确切知道唤醒了哪个线程，这取决于实现。</p><p>因为 <code>notify()</code> 提供了唤醒一个随机线程的机制，因此它可用于实现线程执行类似任务的互斥锁定。</p><p>但在大多数情况下，使用 <code>notifyAll()</code> 会是一个更可行的方案。</p><h2 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll() 方法"></a>notifyAll() 方法</h2><p><code>notifyAll()</code> 方法用于唤醒正在此对象的监视器上等待的所有线程。唤醒的线程将以常规的方式完成 – 就像任何其他线程一样。</p><p>但，有一点要注意的是，对于任意一个线程，但在我们允许其继续执行之前，请始终快速检查继续执行该线程所需的条件。因为在某些情况下线程被唤醒而没有收到通知（这个场景将在后面的例子中讨论 ）</p><h2 id="发送者-–-接收者同步问题"><a href="#发送者-–-接收者同步问题" class="headerlink" title="发送者 – 接收者同步问题"></a>发送者 – 接收者同步问题</h2><p>线程同步的问题，我们已经有了个大概的了解，接下来，我们看一个简单的 Sender-Receiver ( 发送者 – 接收者 ) 应用程序，这个应用程序将利用<code>wait()</code> 和 <code>notify()</code> 方法建立它们之间的同步。</p><ul><li>发送者应该向接收者发送数据包</li><li>在发送方完成发送之前，接收方无法处理数据包</li><li>同样，发送方不得尝试发送另一个数据包，除非接收方已处理过上一个数据包</li></ul><p>我们首先创建一个 Data 类，用于包含将从 Sender 发送到 Receiver 的数据包，同时，我们将使用 <code>wait()</code> 和 <code>notifyAll()</code> 来设置它们之间的同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String packet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True if receiver should wait</span></span><br><span class="line">    <span class="comment">// False if sender should wait</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">transfer</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String packet)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!transfer) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        transfer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.packet = packet;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (transfer) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        transfer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> packet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例有点小长，我们一步一步分析下代码</p><p>1、 私有属性 <code>packet</code> 用于表示通过网络传输的数据<br>2、 布尔类型的私有属性 <code>transfer</code> 用于 Sender 和 Receiver 之间的同步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  如果此变量为 true，则 Receiver 应等待 Sender 发送消息</span><br><span class="line">*  如果它是 `false` ，那么 Sender 应该等待 Receiver 接收消息</span><br></pre></td></tr></table></figure><p>3、 Sender 使用 <code>send()</code> 方法将数据发送给 Receiver：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  如果 `transfer` 为 `false` ，我们将在此线程上调用 `wait()`</span><br><span class="line">*  但如果它为 `true` ，我们需要切换状态，设置我们的消息并调用 `notifyAll()` 来唤醒其他线程以指定发生了重大事件，然后这些线程它们自己可以自查是否可以继续执行。</span><br></pre></td></tr></table></figure><p>4、 同样的， Receiver 将使用 <code>receive()</code> 方法接收数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  如果 Sender 将传输设置为 `false`，那么继续，否则将在此线程上调用 `wait()`</span><br><span class="line">*  满足条件时，我们切换状态，通知所有等待的线程唤醒并返回 Receiver 的数据包</span><br></pre></td></tr></table></figure><h3 id="为什么在-while-循环中包含-wait"><a href="#为什么在-while-循环中包含-wait" class="headerlink" title="为什么在 while 循环中包含 wait()"></a>为什么在 <code>while</code> 循环中包含 <code>wait()</code></h3><p>由于 <code>notify()</code> 和 <code>notifyAll()</code> 随机唤醒正在此对象监视器上等待的线程，因此满足条件并不总是很重要。有时可能会发生线程被唤醒，但实际上并没有满足条件。</p><p>当然了，跟进一步说，我们还可以定义一个检查来避免虚假唤醒 – 线程可以从等待中醒来而不会收到通知。</p><h3 id="我们为什么需要同步-send-和-receive-方法"><a href="#我们为什么需要同步-send-和-receive-方法" class="headerlink" title="我们为什么需要同步 send() 和 receive() 方法"></a>我们为什么需要同步 <code>send()</code> 和 <code>receive()</code> 方法</h3><p>我们将这些方法放在 <code>synchronized</code> 方法是为了提供内部锁。</p><p>如果调用 <code>wait()</code> 方法的线程不拥有固有锁，则会抛出错误。</p><p>现在，是时候创建 Sender 和 Receiver 并在两者上实现 Runnable 接口，以便它们的实例可以由线程执行。</p><p>我们先来看看 Sender 将如何工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Data data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        String packets[] = &#123;</span><br><span class="line">          <span class="string">&quot;First packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Second packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Third packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Fourth packet&quot;</span>,</span><br><span class="line">          <span class="string">&quot;End&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packet : packets) &#123;</span><br><span class="line">            data.send(packet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Thread.sleep() to mimic heavy server-side processing</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(ThreadLocalRandom.current().nextInt(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个 Sender ：</p><ul><li>我们正在创建一些随机数据包，这些数据包将通过网络以 <code>packet[]</code> 数组的形式发送</li><li>对于每个数据包，我们只是调用 <code>send()</code> 而不做其它动作</li><li>然后我们用随机时间间隔调用 <code>Thread.sleep()</code> 来模仿繁重的服务器端处理</li></ul><p>接下来，我们来看看如何实现 Receiver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Data load;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> load.receive();</span><br><span class="line">          !<span class="string">&quot;End&quot;</span>.equals(receivedMessage);</span><br><span class="line">          receivedMessage = load.receive()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(receivedMessage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(ThreadLocalRandom.current().nextInt(<span class="number">1000</span>, <span class="number">5000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); </span><br><span class="line">                Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码很简单，只是在循环中调用 <code>load.receive()</code> ，直到我们得到最后一个 “End” 数据包。</p><p>最后，我们就可以写一个 <code>main()</code> 方法来运行它们了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Sender</span>(data));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Receiver</span>(data));</span><br><span class="line"></span><br><span class="line">    sender.start();</span><br><span class="line">    receiver.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行范例，输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First packet</span><br><span class="line">Second packet</span><br><span class="line">Third packet</span><br><span class="line">Fourth packet</span><br></pre></td></tr></table></figure><p>完美！</p><p>我们在这里 – 我们以正确的顺序接收所有数据包，并成功建立了发送方和接收方之间的正确通信。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十八、Java并发 Java 之 Runnable 还是 Thread ?</title>
      <link href="/posts/c969ad4b.html"/>
      <url>/posts/c969ad4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="十八、Java并发-Java-之-Runnable-还是-Thread"><a href="#十八、Java并发-Java-之-Runnable-还是-Thread" class="headerlink" title="十八、Java并发 Java 之 Runnable 还是 Thread ?"></a>十八、Java并发 Java 之 Runnable 还是 Thread ?</h1><p>写 Java 代码的时候，我们经常会有这样的疑问：我到底是实现一个 Runnable 呢，还是扩展一个 Thread 类？</p><p>你的答案是什么呢？ 那有没有标准答案呢？</p><p>答案是什么呢？</p><p>我们先来分析下，看看哪种方法在实践中更有意义以及为什么？</p><h2 id="扩展一个线程-（-Thread-类"><a href="#扩展一个线程-（-Thread-类" class="headerlink" title="扩展一个线程 （ Thread 类 )"></a>扩展一个线程 （ Thread 类 )</h2><p>简单起见，我们就来定义一个扩展自 <code>Thread</code> 的 <code>SimpleThread</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard logger, constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也真是简单了，然后我们看看如何运行这个 SimpleThread 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenAThread_whenRunIt_thenResult</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThread</span>(</span><br><span class="line">      <span class="string">&quot;SimpleThread executed using Thread&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以把这个 SimpleThread 放到前面章节 一文秒懂 Java ExecutorService中提到的 ExecutorService 中运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenAThread_whenSubmitToES_thenResult</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> <span class="title class_">SimpleThread</span>(</span><br><span class="line">      <span class="string">&quot;SimpleThread executed using ExecutorService&quot;</span>)).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来感觉是不是有点复杂，我们只想在单独的线程中运行单个日志操作而已，使用 Thread 的方式看起来有点复杂化了，要么是 start() 和 join() ，要么是 ExecutorService。</p><p>当然，这不是最糟糕的，更糟糕的是，SimpleThread 再也不能扩展任何其它类，因为 Java 不支持多重继承。</p><h2 id="实现-implements-一个-Runnable"><a href="#实现-implements-一个-Runnable" class="headerlink" title="实现 ( implements) 一个 Runnable"></a>实现 ( implements) 一个 Runnable</h2><p>同样的简单起见，我们创建一个实现了 <code>java.lang.Runnable</code> 接口的简单任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard logger, constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是不是和上面的 SimpleThread 很相似？</p><p>因为这个 SimpleRunnable 只是一个任务，一个在一个单独的线程中运行的任务。</p><p>为了运行这个任务，有多种方式可供选择，其中之一，就是使用一个 Thread 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenRunnable_whenRunIt_thenResult</span><span class="params">()</span></span><br><span class="line"> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SimpleRunnable</span>(</span><br><span class="line">      <span class="string">&quot;SimpleRunnable executed using Thread&quot;</span>));</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，还可以使用 ExecutorService:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenARunnable_whenSubmitToES_thenResult</span><span class="params">()</span></span><br><span class="line"> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> <span class="title class_">SimpleRunnable</span>(</span><br><span class="line">      <span class="string">&quot;SimpleRunnable executed using ExecutorService&quot;</span>)).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，你是不是很疑惑？Runnable 和继承一个 Thread 没有什么区别啊 ？同样多的代码，同样多的步骤。</p><p>别急，哈哈，重点来了。</p><p>由于我们的 SimpleRunnable 实现了一个接口，因此，如果需要，我们可以自由扩展自另一个基类。</p><p>更简单的是，一个几行代码的 Runnable 还可以写成一个简单的 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenARunnableLambda_whenSubmitToES_thenResult</span><span class="params">()</span> </span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    executorService.submit(</span><br><span class="line">      () -&gt; log.info(<span class="string">&quot;Lambda runnable executed!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这才是 Runnable 的杀手锏。真的是简单的不要太多。</p><h2 id="Runnable-or-Thread"><a href="#Runnable-or-Thread" class="headerlink" title="Runnable or Thread?"></a>Runnable or Thread?</h2><p>看到这里，你想要的是 Runnable 还是 Thread ?</p><p>看我上文的描述，肯定是倾向使用 Runnable 多过 Thread：</p><ul><li>在扩展 Thread 类时，我们并没有被要求覆盖它的任何方法。相反，我们需要覆盖 Runnable 的 <code>run()</code> 方法（ Thread 类已经实现了 ）。这显然违反了 IS-A Thread 原则。</li><li>我们可以创建一个 Runnable 的实现并将其传递给 Thread 类。这利用的是组合而不是继承。这更灵活。</li><li>在扩展了 Thread 类之后，我们无法扩展任何其他类。</li><li>从 Java 8 开始，Runnables 可以重写为 lambda 表达式。</li></ul><p>所以，有了这些之后，你是怎么想的？快告诉我们吧？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十七、Java并发 Java Thread 生命周期</title>
      <link href="/posts/9c8c1a2d.html"/>
      <url>/posts/9c8c1a2d.html</url>
      
        <content type="html"><![CDATA[<h1 id="十七、Java并发-Java-Thread-生命周期"><a href="#十七、Java并发-Java-Thread-生命周期" class="headerlink" title="十七、Java并发 Java Thread 生命周期"></a>十七、Java并发 Java Thread 生命周期</h1><p>本文中，我想详细的讨论下 Java 中的核心概念 – 线程的生命周期。我会使用一张我自制的图片加上实用的代码片段，一步一步的详细剖析线程的各个状态和各个状态之间如何转换。</p><h2 id="Java-中的多线程"><a href="#Java-中的多线程" class="headerlink" title="Java 中的多线程"></a>Java 中的多线程</h2><p>Java 语言中， 多线程是由 Thread 的核心概念驱动的。因为多线程中的每一个线程都相互独立，有着自己的生命周期和状态转换。</p><p>我们先来看一张草图，这图描述了 Java 线程的各种状态和转换过程。</p><p><img src="https://s3.uuu.ovh/imgs/2022/05/04/b5b70b4c71c1fcaa.png" alt="img_1.png"></p><p>是不是很杂乱无章？ 看不懂没关系，我们接下来会详细介绍各个状态。</p><h2 id="Java-线程中的生命周期"><a href="#Java-线程中的生命周期" class="headerlink" title="Java 线程中的生命周期"></a>Java 线程中的生命周期</h2><p>Java 中，每一个线程都是 <code>java.lang.Thread</code> 类的实例。而且，Java 个线程生命周期中的各个状态都定义在 <code>Thread</code> 类的一个静态的 <code>State</code> 枚举中。</p><p><code>State</code> 枚举定义了线程的所有潜在状态。总共有 6 个，分别对应者上图中的 6 个绿色背景的矩形和椭圆型。</p><ul><li><code>NEW</code> : 新创建的，且未调用 <code>start()</code> 方法开始执行的线程。</li><li><code>RUNNABLE</code> : 已经在运行中的线程或正在等待资源分配的准备运行的线程。</li><li><code>BLOCKED</code> : 等待获取进入或重新进入同步块或方法的监视器锁的线程。</li><li><code>WAITING</code> : 等待其他一些线程执行特定操作，没有任何时间限制。</li><li><code>TIMED_WAITING</code>: 等待某个其他线程在指定时间段内执行特定操作</li><li><code>TERMINATED</code> : 线程完成了它的任务。</li></ul><p>需要注意的是： <strong>在任何给定的时间点，线程只能处于这些状态之一</strong>。</p><ul><li><code>NEW</code> 状态，应该很好理解，比如，车，厂家生产出来，只要还没被卖出过，那么它就是新的 ( NEW )</li><li><code>RUNNABLE</code> 只要线程不出于其它状态，它就是 RUNNABLE 状态。怎么理解呢？ 车买来了，只要它没坏没出什么毛病没借给别人，那么它就出于可开状态，不管是呆在家里吃灰还是已经在上路运行。</li><li><code>WAITING</code> : 无时间显示的等待其它线程完成任务时就处于这个状态，怎么理解呢？比如长假告诉公路大堵车，要等待别人前进了几个蜗牛步我们才能往前几个蜗牛步，有时候一等就是昏天暗地，可能长达几天，也可能，一辈子吧。</li><li><code>TIMED_WAITING</code> : 一直处于 <code>WAITING</code> 总不是办法，所以可能会设置一个超时时间，如果过了时间，就不等待了。同样的，如果可以后退，那么我们在堵车的时候可能会等待那么十几分钟，发现确实走不了，就等了呗。</li><li><code>TERMINATED</code> : 当一个线程结束了它的任务（可能完成了，也可能没完成）就会处于这个状态。如果拿车做比喻，那么当车彻底报废，已经再也不能上路了，就处于这个状态。</li></ul><blockquote><p>其实拿车作比喻感觉有点怪，我觉得拿追女朋友来做比喻比较恰当些。</p></blockquote><h2 id="NEW-状态"><a href="#NEW-状态" class="headerlink" title="NEW 状态"></a>NEW 状态</h2><p><strong>NEW</strong>状态的线程（或已经创建的新线程）是已创建但尚未启动的线程。线程会一直保持这个 <code>NEW</code> 状态，直到在该线程上调用了 <code>start()</code> 方法启动它。</p><p>下面的代码，我们创建了一个 <code>NEW</code> 状态的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewState</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">Log.info(t.getState());</span><br></pre></td></tr></table></figure><p>由于我们没有启动线程，因此 <code>t.getState()</code> 方法将打印输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW</span><br></pre></td></tr></table></figure><h2 id="RUNNABLE-状态"><a href="#RUNNABLE-状态" class="headerlink" title="RUNNABLE 状态"></a>RUNNABLE 状态</h2><p>当在一个 <code>NEW</code> 状态的线程上调用 <code>start()</code> 方法时，该线程的状态会从 <code>NEW</code> 转换为 <code>RUNNABLE</code>。处于该状态的线程要么是已经在运行中，那么是在处于正在等待系统的资源分配（准备运行）。</p><p>在多线程环境中，线程调度器 （ Thread-Scheduler，它是 JVM 的一部分）会为每个线程分配固定的时间。线程并不是一直都在执行的，调度器会把暂时空闲的线程的 CPU （ 还是在 RUNNABLE 状态 ）让出来，让其它需要的线程去运行。因此它会运行一段特定的时间，然后将控制权放弃给其他 RUNNABLE 线程。</p><blockquote><p>注意： 这里的等待资源，不是等待其它线程，而是等待 CPU 排队。打个比方，新车上路。要等待的是有没有路，如果没有路，就开不了，这是本质的问题。</p></blockquote><p>例如，让我们将 <code>t.start()</code> 方法添加到我们之前的代码中并尝试访问其当前状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewState</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">t.start();</span><br><span class="line">Log.info(t.getState());</span><br></pre></td></tr></table></figure><p>此代码最有可能返回输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>为什么说是最有可能呢？如果是一个空转线程，除了 CPU 不需要其它资源，那么很大概率就是 <code>RUNNABLE</code> ，但如果需要其它资源，可能会因为竞争资源而处于其它状态。还有一种情况，可能还没运行到 <code>t.getState()</code> ，线程任务就执行完毕了，那么也不会是 <code>RUNNABLE</code> 状态。</p><h2 id="BLOCKED-状态"><a href="#BLOCKED-状态" class="headerlink" title="BLOCKED 状态"></a>BLOCKED 状态</h2><p>当一个线程当前没有资格运行时，它处于 <code>BLOCKED</code> 状态。如果线程在尝试访问由某个其他线程锁定的代码段时，那它会因为需要等待获取监视器锁进入此状态。</p><p>我们使用一小段代码来重现下这个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoThreadB</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoThreadB</span>());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Log.info(t2.getState());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThreadB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        commonResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">commonResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Infinite loop to mimic heavy processing</span></span><br><span class="line">            <span class="comment">// &#x27;t1&#x27; won&#x27;t leave this method</span></span><br><span class="line">            <span class="comment">// when &#x27;t2&#x27; try to enters this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中</p><ul><li>我们创建了两个不同的线程– <code>t1</code> 和 <code>t2</code> 。</li><li><code>t1</code> 启动后就进入了同步的 <code>commonResource()</code>方法，同步方法意味着一次只能有一个线程可以访问它。尝试访问此方法的所有其他后续线程将被阻止进一步执行，直到当前线程完成处理。</li><li>当 t1 进入这个方法时，它保持了无限循环，这只是为了模仿繁重的处理，以便所有其他线程都无法进入此方法。</li><li>接着我们开启 <code>t2</code> ，它尝试输入已经被 <code>t1</code> 访问的 <code>commonResource()</code> 方法，这时，因为 <code>commonResource()</code> 被 t1 锁定，所以 t2 将保持在 <code>BLOCKED</code> 状态</li></ul><p>在这个状态上，当我们使用 <code>t.getState()</code> 时将输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLOCKED</span><br></pre></td></tr></table></figure><h2 id="WAITTING-状态"><a href="#WAITTING-状态" class="headerlink" title="WAITTING 状态"></a>WAITTING 状态</h2><p>线程在等待某个其他线程执行特定操作时处于 <code>WAITING</code> 状态。根据 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html#WAITING">Oracle 官方文档</a>，任何线程都可以通过调用以下三种方法中的任何一种来进入此状态：</p><p>1、<code>object.wait()</code></p><p>2、<code>thread.join()</code></p><p>3、<code>LockSupport.park()</code></p><p>请注意，我们没有为 <code>wait()</code> 和 <code>join()</code> 定义任何超时时间，因为下一节将介绍该方案。</p><p>我们以后会写一个单独的教程，详细讨论了 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 的使用。</p><p>下面，我们写一段代码尝试重现这种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingState</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitingState</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoThreadWS</span>());</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThreadWS</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.info(WaitingState.t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来讨论一下上面的代码做的事情</p><p>1、首先，我们创建并启动了 <code>t1</code></p><p>2、其次，<code>t1</code> 创建了 <code>t2</code> 并启动它</p><p>3、当 <code>t2</code> 的处理继续时，我们调用 <code>t2.join()</code>，这使 <code>t1</code> 处于 <code>WAITING</code> 状态，直到 <code>t2</code> 完成执行</p><p>4、由于 t1 正在等待 t2 完成，我们从 t2 调用 <code>t1.getState()</code></p><p>输出结果一般为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WAITING</span><br></pre></td></tr></table></figure><p>请留意在哪里调用 <code>t1.getState()</code> 。</p><p>所以，<code>WAITING</code> 和 <code>BLOCKED</code> 两个状态的区别是什么？</p><ul><li><code>BLOCKED</code> 是因为线程竞争不到资源而处于 BLOCKED 状态。这个是被动的。因为别无选择。</li><li><code>WAITING</code> 是因为线程主动等待别人完成而处于 WAITING 状态。这个是主动的。因为它可以不调用那三个方法，不用等待其它人完成。它可以选择挥一挥衣袖，不不带走一片云彩</li></ul><h2 id="TIMED-WAITING-状态"><a href="#TIMED-WAITING-状态" class="headerlink" title="TIMED_WAITING 状态"></a>TIMED_WAITING 状态</h2><p>线程在等待另一个线程在规定的时间内执行特定操作时处于 <code>TIMED_WAITING</code> 状态。根据 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html#TIMED_WAITING">Java Docs 文档</a>，有五种方法可以将线程置于TIMED_WAITING 状态：</p><ul><li><code>thread.sleep(long millis)</code></li><li>``wait(int timeout) or wait(int timeout, int nanos)`</li><li>thread.join(long millis)</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil`</li></ul><p>下面，我们写一段代码尝试重现这种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimedWaitingState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj1);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The following sleep will give enough time for ThreadScheduler</span></span><br><span class="line">        <span class="comment">// to start processing of thread t1</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Log.info(t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.error(<span class="string">&quot;Thread interrupted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码和 <code>WAITING</code> 状态的差不多，我们创建并启动了一个线程 <code>t1</code>，并它进入睡眠状态，超时时间为 <code>5</code> 秒。</p><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIMED_WAITING</span><br></pre></td></tr></table></figure><h2 id="TERMINATED-状态"><a href="#TERMINATED-状态" class="headerlink" title="TERMINATED 状态"></a>TERMINATED 状态</h2><p>这是一个 「 已死 」 线程的状态。当一个线程已经完成执行或异常终止时，它处于 <code>TERMINATED</code> 状态。我们写一段代码尝试重现这种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminatedState</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TerminatedState</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// The following sleep method will give enough time for </span></span><br><span class="line">        <span class="comment">// thread t1 to complete</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Log.info(t1.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// No processing in this block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，我们启动线程 <code>t1</code> 时，下一个语句 <code>Thread.sleep(1000)</code> 为 t1 提供了足够的时间来完成。</p><p>因此，上面这个示例输出结果为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在本教程中，我们了解了 Java 中线程的生命周期。我们详细介绍了 <code>Thread.State</code> 枚举定义的所有七个状态，并使用一些示例来演示他们。</p><p>虽然代码片段几乎可以在每台机器上提供相同的输出，但在某些特殊情况下，我们可能会得到一些不同的输出，因为线程调度程序的确切行为无法确定。</p><p>所以，有任何问题，欢迎回帖咨询</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六、Java并发 Java ThreadLocalRandom</title>
      <link href="/posts/9c264667.html"/>
      <url>/posts/9c264667.html</url>
      
        <content type="html"><![CDATA[<h1 id="十六、Java并发-Java-ThreadLocalRandom"><a href="#十六、Java并发-Java-ThreadLocalRandom" class="headerlink" title="十六、Java并发 Java ThreadLocalRandom"></a>十六、Java并发 Java ThreadLocalRandom</h1><p>随机数生成是一个非常常见的操作，而且 Java 也提供了 <code>java.util.Random</code> 类用于生成随机数，而且呢，这个类也是线程安全的，就是有一点不好，在多线程下，它的性能不佳。</p><p>为什么多线程下，Random 的性能不佳？</p><p>因为，它采用了多个线程共享一个 Random 实例。这样就会导致多个线程争用。</p><p>为了解决这个问题，Java 7 引入了 <code>java.util.concurrent.ThreadLocalRandom</code> 类，用于在多线程环境中生成随机数。</p><p>本文接下来的部分，就来看看如何 ThreadLocalRandom 如何执行以及如何在实际应用程序中使用它。</p><h2 id="ThreadLocalRandom-Via-Random"><a href="#ThreadLocalRandom-Via-Random" class="headerlink" title="ThreadLocalRandom Via Random"></a>ThreadLocalRandom Via Random</h2><p>ThreadLocalRandom 是 ThreadLocal 类和 Random 类的组合，它与当前线程隔离，通过简单地避免对 Random 对象的任何并发访问，在多线程环境中实现了更好的性能。</p><p>也就是说，相比于 <code>java.util.Random</code> 类全局的提供随机数生成， 使用 ThreadLocalRandom，一个线程获得的随机数不受另一个线程的影响。</p><p>另一个与 Random 类不同的是，ThreadLocalRandom 不支持显式设置种子。因为它重写了从 Random 继承的 <code>setSeed(long seed)</code> 方法，会在调用时始终抛出 <code>UnsupportedOperationException</code>。</p><p>接下来我们看看如何使用 ThreadLocalRandom 生成随机 <code>int</code>、<code>long</code> 和 <code>double</code> 值。</p><h2 id="使用-ThreadLocalRandom-生成随机数"><a href="#使用-ThreadLocalRandom-生成随机数" class="headerlink" title="使用 ThreadLocalRandom 生成随机数"></a>使用 ThreadLocalRandom 生成随机数</h2><p>根据 Oracle 文档，我们只需要调用 <code>ThreadLocalRandom.current()</code> 方法，就能返回当前线程的 <code>ThreadLocalRandom</code> 实例。然后，我们可以通过实例的相关方法来生成随机值。</p><p>比如下面的代码，生成一个没有任何边界的随机 int 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">unboundedRandomValue</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt());</span><br></pre></td></tr></table></figure><blockquote><p>其实是有边界的，它的边界就是 int 的边界。</p></blockquote><p>接下来，我们看看如何生成有边界的随机 int 值，这意味着我们需要传递边界下限和边界上限作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">boundedRandomValue</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>请注意，这是一个左闭右开区间，也就是说，上面的实例生成的随机数在 <code>[0,100)</code> 之间，包含了 0 但不包含 100。</p><p>同样的，我们可以通过调用 <code>nextLong()</code> 和 <code>nextDouble()</code> 方法生成 long 和 double 类型的随机值，调用方式与上面示例中 <code>nextInt()</code> 类似。</p><p>Java 8 还添加了 <code>nextGaussian()</code> 方法从生成器序列中生成下一个正态分布的值，其值范围在 <code>0.0</code> 和 <code>1.0</code> 之间。</p><p>与 Random 方法类似，ThreadLocalRandom 也提供了 <code>doubles()</code> 、<code>ints()</code> 和 <code>longs()</code> 方法生成一序列流式 ( stream ) 的随机值。</p><h2 id="使用-JMH-比较-ThreadLocalRandom-和-Random"><a href="#使用-JMH-比较-ThreadLocalRandom-和-Random" class="headerlink" title="使用 JMH 比较 ThreadLocalRandom 和 Random"></a>使用 JMH 比较 ThreadLocalRandom 和 Random</h2><p>记下来，我们看看如何在多线程环境中分别使用这两个类生成随机值，然后再使用 JMH 比较它们的性能。</p><p>首先，我们创建一个示例，其中所有线程共享一个 Random 实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">List&lt;Callable&lt;Integer&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    callables.add(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> random.nextInt();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.invokeAll(callables);</span><br></pre></td></tr></table></figure><p>上面的代码中，我们把使用 Random 实例生成随机值的任务提交给 ExecutorService 。</p><p>然后，我们使用 JMH 基准测试来检查上面代码的性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:00:36</span><br><span class="line">Benchmark                                            Mode Cnt Score    Error    Units</span><br><span class="line">ThreadLocalRandomBenchMarker.randomValuesUsingRandom avgt 20  771.613 ± 222.220 us/op</span><br></pre></td></tr></table></figure><p>接着，类似地，我们使用 <code>ThreadLocalRandom</code> 而不是 <code>Random</code> 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">List&lt;Callable&lt;Integer&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    callables.add(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextInt();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.invokeAll(callables);</span><br></pre></td></tr></table></figure><p>上面的代码，为线程池中的每个线程单独使用了一个 ThreadLocalRandom 实例。</p><p>下面是使用 JMH 对 ThreadLocalRandom 的测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:00:36</span><br><span class="line">Benchmark                                                       Mode Cnt Score    Error   Units</span><br><span class="line">ThreadLocalRandomBenchMarker.randomValuesUsingThreadLocalRandom avgt 20  624.911 ± 113.268 us/op</span><br></pre></td></tr></table></figure><p>通过 JMH 的测试结果中可以看出，使用 Random 生成 1000 个随机值所花费的平均时间是 772 微秒，但使用 ThreadLocalRandom 只花了 625 微秒。嗯，差距不是很大，但好歹也是有差距的，因为生成 1000 个随机数是瞬间的事情。</p><p>因此，我们可以得出结论，ThreadLocalRandom 在高度并发的环境中更有效。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五、Java并发 Java java.util.concurrent.Future</title>
      <link href="/posts/50778af3.html"/>
      <url>/posts/50778af3.html</url>
      
        <content type="html"><![CDATA[<h1 id="十五、Java并发-Java-java-util-concurrent-Future"><a href="#十五、Java并发-Java-java-util-concurrent-Future" class="headerlink" title="十五、Java并发 Java java.util.concurrent.Future"></a>十五、Java并发 Java java.util.concurrent.Future</h1><p>写了几篇 Java 一文秒懂 XXX 系列的文章后，对 Java 并发编程的设计思想真的是竖然起敬。</p><p>Java 在并发方面引入了 「 将来 」( Future ) 这个概念。把所有不在主线程执行的代码都附加了将来这个灵魂。主线程只负责其它并发线程的创建、启动、监视和处理并发线程完成任务或发生异常时的回调。其它情况，则交给并发线程自己去处理。而双方之间的沟通，就是通过一个个被称之为 「 将来 」 的类出处理。</p><p><code>Future</code> 定义在 <code>java.util.concurrent</code> 包中，这是一个接口，自 Java 1.5 以来一直存在的接口，用于处理异步调用和处理并发编程。</p><h2 id="创建-Future"><a href="#创建-Future" class="headerlink" title="创建 Future"></a>创建 <code>Future</code></h2><p>简单地说，<code>Future</code> 类表示异步计算的未来结果 – 在处理完成后最终将出现在 Future 中的结果。</p><p>是不是又很难理解，文字越少，内容越多。上面这句话的意思，就是主线程会创建一个 Future 接口的对象，然后启动并发线程，并告诉并发线程，一旦你执行完毕，就把结果存储在这个 Future 对象里。</p><p>因此，理解 Future 的第一步，就是要知道如何创建和返回 Future 实例。</p><p>一般情况下，我们会把长时间运行的逻辑放在异步线程中进行处理，这是使用 Future 接口最理想的场景。主线程只要简单的将异步任务封装在 Future 里，然后开始等待 Future 的完成，在这段等待的时间内，可以处理一些其它逻辑，一旦 Future 执行完毕，就可以从中获取执行的结果并进一步处理。</p><p>针对上面这种表述，我们来看看具体哪些场景可以使用 Future :</p><ul><li>计算密集型（ 数学和科学计算 ）</li><li>操纵大数据结构（ 大数据 ）</li><li>远程方法调用（下载文件，HTML 爬取，Web 服务）</li></ul><h3 id="实现了-Future-的-FutureTask"><a href="#实现了-Future-的-FutureTask" class="headerlink" title="实现了 Future 的 FutureTask"></a>实现了 Future 的 FutureTask</h3><p>我们先来看一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareCalculator</span> &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> </span><br><span class="line">      <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;Integer&gt; <span class="title function_">calculate</span><span class="params">(Integer input)</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> input * input;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你认真读过前几个章节，想必对这段代码不陌生了。</p><p>在上面这段代码中，我们创建了一个简单的类用于计算一个整型 ( Integer ) 的平方。当然了，计算平方这个任务肯定不能划到 「 长时间运行 」 这个类别里，所以我们在它之前又添加了 <code>Thread.sleep(1000)</code>。</p><blockquote><p>不要小看 1s。这已经是相当长的任务了。</p></blockquote><p>在上面这段代码中，实际执行的计算是作为 Lambda 表达式参数传递给 <code>call()</code> 方法。当然了，这个实际执行的代码，除了 <code>Thread.sleep()</code> 之外好像也没有什么特别之处。</p><p>好了，现在，我们应该将注意力转移到 Callable 和 ExecutorService 的使用，因为它们才是最有趣的。</p><p><code>Callable</code> 是一个接口，用于表示一个任务，这个任务可以返回值。<code>Callable</code> 接口只有一个方法 <code>call()</code>。上面的示例中。那个 Lambda 其实就是一个 Callable 实例。</p><blockquote><p>啥？ 不会看不懂吧？ 好吧，我找个时间好好写一些 Java Lambda 方面的文章。</p></blockquote><p>Callable 实例创建完成后并不会立即执行，我们仍然需要将它传递给一个 「 执行器 」( Executor , 执行程序 ) ，这个执行器将负责在新线程中启动该任务并返回一个包含了值的 Future 对象。</p><p>这个执行器，是 <code>Executor</code> 的实例，通常，它是一个 ExecutorService 类的实例。</p><p>Java 其实提供了很多方法创建 <code>ExecutorService</code> 的实例，但最常用的，也是最推荐的做法是使用 Executors 的静态工厂方法。上面的示例中，我们就使用了 <code>Executors.newSingleThreadExecutor()</code> 方法创建了一个能够处理单个线程的 ExecutorService。</p><p>一旦我们有了一个 ExecutorService 对象，我们只需要调用它的 <code>submit()</code> 并传递我们的 Callable 作为参数即可。 <code>submit()</code> 会启动任务并返回一个 FutureTask 对象。</p><p>FutureTask 是一个类，实现了 Future 接口， 在 <code>java.util.concurrent</code> 包中定义。</p><h2 id="消费-使用-Future"><a href="#消费-使用-Future" class="headerlink" title="消费( 使用 ) Future"></a>消费( 使用 ) Future</h2><p>用了相当长的篇幅，我们终于讲完了如何创建一个 Future 实例，接下来，我们将进入如何消费(使用) 刚刚创建的 Future 实例。</p><h3 id="使用-isDone-和-get-方法来获取结果"><a href="#使用-isDone-和-get-方法来获取结果" class="headerlink" title="使用 isDone() 和 get() 方法来获取结果"></a>使用 <code>isDone()</code> 和 <code>get()</code> 方法来获取结果</h3><p>现在，是时候调用 <code>calculate()</code> 方法获取返回的 Future 实例了，通过 Future 实例，我们就能进一步获取计算的整型结果。</p><p>要从 Future 实例中获取结果，我们需要用到两个方法：<code>isDone()</code> 和 <code>get()</code>。</p><p>1、 <code>Future.isDone()</code> 方法用于获取我们的执行器是否已完成任务处理。如果任务完成，则返回 <code>true</code>，否则返回 <code>false</code>。<br>2、 从计算中返回实际结果的方法是 <code>Future.get()</code>。但要注意的是，<code>Future.get()</code> 方法是一个阻塞方法。如果任务还没执行完毕，那么会一直阻塞直到直到任务完成，</p><p>为了防止调用 <code>Future.get()</code> 方法阻塞当前线程，推荐的做法是先调用 <code>Future.isDone()</code> 判断任务是否完成，然后再调用 <code>Future.get()</code> 从完成的任务中获取任务执行的结果。</p><p>因为 <code>Future.isDone()</code> 和 <code>Future.get()</code> 的存在，我们就可以在等待任务完成时运行其它一些代码，就像下面示例中所演示的那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">SquareCalculator</span>().calculate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!future.isDone()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br></pre></td></tr></table></figure><p>上面这段代码，我们在等待计算任务完成的同时执行了一条输出语句，用于提醒用户当前程序还是在运行的，并没有僵死。</p><p>我们使用了一个 <code>while</code> 循环，使用 <code>future.isDone()</code> 来检查任务是否完成，一旦完成，就会立即终止循环，并调用 <code>future.get()</code> 方法获取计算的结果。</p><p>因为实现使用了 <code>isDone()</code> 判断任务是否完成，所以 <code>future.get()</code> 并不会发生阻塞，想法，简直就是立即返回。</p><p>使用 <code>isDone()</code> 和 <code>get()</code> 方法来获取结果，这应该是消费 Future 最常见的方式。</p><p>当然了，值得一提的是，<code>Future.get()</code> 方法有一个可以超时等待的重载版本，这个重载版本接收两个参数，一个是超时的时间，另一个是超时时间的单位。方法原型如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException</span><br></pre></td></tr></table></figure><p>而使用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><code>get(long, TimeUnit)</code> 和 <code>get()</code> 的不同之处，是前者在经过指定的超时时间后任务仍未返回，那么就会抛出一个 <code>TimeoutException</code> 异常，表示执行超时。</p><h3 id="使用-Future-cancel-方法取消-Future"><a href="#使用-Future-cancel-方法取消-Future" class="headerlink" title="使用 Future.cancel() 方法取消 Future"></a>使用 <code>Future.cancel()</code> 方法取消 Future</h3><p>假设我们已经触发了一项任务，但由于某种原因，我们不再关心结果了。我们可以使用 <code>Future.cancel(boolean)</code> 告诉执行器停止操作并中断其底层线程。该方法很简单，使用演示如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">SquareCalculator</span>().calculate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>上面这两行代码，我们的 Future 实例永远不会完成它的操作。实际上，如果我们尝试在调用了 <code>cancel()</code> 方法之后立即调用 <code>get()</code> 方法，将会获得一个 <code>CancellationException</code> 异常。</p><p>为了防止 <code>Future.get()</code> 抛出一个 <code>CancellationException</code> 异常，我们可以使用 <code>Future.isCancelled()</code> 检查 Future 是否已被取消。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1、 对 <code>cancel()</code> 的调用可能会失败。如果调用失败，那么它会返回 <code>false</code>。<br>2、 cancel() 方法接受一个布尔值作为参数，该参数用于控制执行此任务的线程是否应该被中断。</p><h2 id="多线程-vs-线程池"><a href="#多线程-vs-线程池" class="headerlink" title="多线程 vs 线程池"></a>多线程 vs 线程池</h2><p>上面的示例中，我们的 <code>ExecutorService</code> 实例是单线程的，因为它是使用 <code>Executors.newSingleThreadExecutor()</code> 方法获得的。</p><p>为了突出演示它是 「 单线程 」，我们改一下代码同时触发两个计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SquareCalculator</span> <span class="variable">squareCalculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SquareCalculator</span>();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future1 = squareCalculator.calculate(<span class="number">10</span>);</span><br><span class="line">Future&lt;Integer&gt; future2 = squareCalculator.calculate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(future1.isDone() &amp;&amp; future2.isDone())) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">      String.format(</span><br><span class="line">        <span class="string">&quot;future1 is %s and future2 is %s&quot;</span>, </span><br><span class="line">        future1.isDone() ? <span class="string">&quot;done&quot;</span> : <span class="string">&quot;not done&quot;</span>, </span><br><span class="line">        future2.isDone() ? <span class="string">&quot;done&quot;</span> : <span class="string">&quot;not done&quot;</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result1</span> <span class="operator">=</span> future1.get();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result2</span> <span class="operator">=</span> future2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(result1 + <span class="string">&quot; and &quot;</span> + result2);</span><br><span class="line"></span><br><span class="line">squareCalculator.shutdown();</span><br></pre></td></tr></table></figure><p>然后我们就会获得类似下面的输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calculating square <span class="keyword">for</span>: 10</span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">calculating square <span class="keyword">for</span>: 100</span><br><span class="line">future1 is <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">100 and 10000</span><br></pre></td></tr></table></figure><p>很明显，整个过程并不是并行执行的。因为第二个任务仅在第一个任务完成后才开始，所以，整个过程大约需要 2 秒钟才能完成。</p><p>为了使我们的程序真正具有多线程，我们应该使用不同风格的 <code>ExecutorService</code> 。例如下面这段代码，我们使用工厂方法<code>Executors.newFixedThreadPool()</code> 创建一个固定大小的线程池，并观察输出的结果有何变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我比较懒，你把相应的代码替换下即可，省略号那段就不用替换了。</p></blockquote><p>这段代码，对 SquareCalculator 类的做了一处简单的更改，使得我们的执行器拥有了 2 个同步线程。</p><p>如果我们再次运行完全相同的客户端代码，我们获得的输出可能如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calculating square <span class="keyword">for</span>: 10</span><br><span class="line">calculating square <span class="keyword">for</span>: 100</span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">future1 is not <span class="keyword">done</span> and future2 is not <span class="keyword">done</span></span><br><span class="line">100 and 10000</span><br></pre></td></tr></table></figure><p>现在看起来心情是否愉快多了，你应该留意到了， 2 个任务是如何同时开始和结束运行的，整个过程大约需要 1 秒钟就能完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四、Java并发 Java 守护线程 ( Daemon Thread )</title>
      <link href="/posts/a36784de.html"/>
      <url>/posts/a36784de.html</url>
      
        <content type="html"><![CDATA[<h1 id="十四、Java并发-Java-守护线程-Daemon-Thread"><a href="#十四、Java并发-Java-守护线程-Daemon-Thread" class="headerlink" title="十四、Java并发 Java 守护线程 ( Daemon Thread )"></a>十四、Java并发 Java 守护线程 ( Daemon Thread )</h1><p>在这篇简短的文章中，我们将讲解下 Java 中的守护线程，看看它们可以做什么。我们还将解释守护线程和用户线程之间的区别。</p><h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p>Java 提供了两种类型的线程：<strong>守护线程</strong> 和 <strong>用户线程</strong></p><ul><li><strong>用户线程</strong> 是高优先级线程。JVM 会在终止之前等待任何用户线程完成其任务。</li><li><strong>用户线程</strong> 是低优先级线程。其唯一作用是为用户线程提供服务。</li></ul><p>由于守护线程的作用是为用户线程提供服务，并且仅在用户线程运行时才需要，因此一旦所有用户线程完成执行，JVM 就会终止。也就是说 <strong>守护线程不会阻止 JVM 退出</strong>。</p><p>这也是为什么通常存在于守护线程中的无限循环不会导致问题，因为任何代码（包括 finally 块 ）都不会在所有用户线程完成执行后执行。</p><p>这也是为什么我们并不推荐 <strong>在守护线程中执行 I/O 任务</strong> 。因为可能导致无法正确关闭资源。</p><p>但是，守护线程并不是 100% 不能阻止 JVM 退出的。守护线程中设计不良的代码可能会阻止 JVM 退出。例如，在正在运行的守护线程上调用<code>Thread.join()</code> 可以阻止应用程序的关闭。</p><h2 id="守护线程能用来做什么？"><a href="#守护线程能用来做什么？" class="headerlink" title="守护线程能用来做什么？"></a>守护线程能用来做什么？</h2><p>常见的做法，就是将守护线程用于后台支持任务，比如垃圾回收、释放未使用对象的内存、从缓存中删除不需要的条目。</p><p>咦，按照这个解释，那么大多数 JVM 线程都是守护线程。</p><h2 id="如何创建守护线程-？"><a href="#如何创建守护线程-？" class="headerlink" title="如何创建守护线程 ？"></a>如何创建守护线程 ？</h2><p>守护线程也是一个线程，因此它的创建和启动其实和普通线程没什么区别？</p><p>要将普通线程设置为守护线程，方法很简单，只需要调用 <code>Thread.setDaemon()</code> 方法即可。</p><p>例如下面这段代码，假设我们继承 <code>Thread</code> 类创建了一个新类 <code>NewThread</code> 。那么我们就可以创建这个类的实例并设置为守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NewThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><p>在 Java 语言中，线程的状态是自动继承的。任何线程都会继承创建它的线程的守护程序状态。怎么理解呢？</p><p>1、 如果一个线程是普通线程（ 用户线程） ，那么它创建的子线程默认也是普通线程（ 用户线程 ）。<br>2、 如果一个线程是守护线程，那么它创建的子线程默认也是守护线程。</p><p>因此，我们可以推演出： 由于主线程是用户线程，因此在 <code>main()</code> 方法内创建的任何线程默认为用户线程。</p><p>需要注意的是调用 <code>setDaemon()</code> 方法的时机，该方法只能在创建 Thread 对象并且在启动线程前调用。在线程运行时尝试调用 <code>setDaemon()</code> 将抛出 IllegalThreadStateException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IllegalThreadStateException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenSetDaemonWhileRunning_thenIllegalThreadStateException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">NewThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">    daemonThread.start();</span><br><span class="line">    daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何检查一个线程是守护线程还是用户线程？"><a href="#如何检查一个线程是守护线程还是用户线程？" class="headerlink" title="如何检查一个线程是守护线程还是用户线程？"></a>如何检查一个线程是守护线程还是用户线程？</h2><p>检查一个线程是否是守护线程，可以简单地调用方法 <code>isDaemon()</code> ，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCallIsDaemon_thenCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">NewThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">    <span class="type">NewThread</span> <span class="variable">userThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">    daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">    userThread.start();</span><br><span class="line"></span><br><span class="line">    assertTrue(daemonThread.isDaemon());</span><br><span class="line">    assertFalse(userThread.isDaemon());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>守护线程的概念是不是很简单？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三、Java并发 Java java.util.concurrent.Locks</title>
      <link href="/posts/e2353faf.html"/>
      <url>/posts/e2353faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="十三、Java并发-Java-java-util-concurrent-Locks"><a href="#十三、Java并发-Java-java-util-concurrent-Locks" class="headerlink" title="十三、Java并发 Java java.util.concurrent.Locks"></a>十三、Java并发 Java java.util.concurrent.Locks</h1><p>对于 Java 来讲，锁 （ Lock ) 是一种比标准同步块 （ synchronized block ） 更灵活，更复杂的线程同步机制。</p><p>其实，Java 1.5 就已经存在 Lock 接口了。这个 Lock 接口在 <code>java.util.concurrent.lock</code> 包中定义，提供了大量的锁操作。</p><p>本文中，我们将讲解 Lock 接口的不同实现并介绍如何在应用程序中使用锁。</p><h2 id="锁-lock-和同步块-synchronized-block-之间的差异"><a href="#锁-lock-和同步块-synchronized-block-之间的差异" class="headerlink" title="锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异"></a>锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异</h2><p>使用 synchronized 块和使用 Lock API 之间几乎没有区别：</p><ul><li><strong>同步块完全包含在方法中</strong> : 在独立的方法中，我们可以使用 Lock 提供的 <code>lock()</code> 和 <code>unlock()</code> 实现锁和解锁操作。</li><li>同步块不支持公平竞争，任何线程都可以获取释放的锁定，且不能指定优先级。但锁 ( Lock ) 就不一样了，可以通过指定公平属性来实现 Lock 中的公平性。这可以确保最长的等待线程被授予锁定权限。</li><li>如果线程无法访问同步块，则会阻塞该线程。Lock 则提供了 <code>tryLock()</code> 方法。线程只有在可用且不被任何其他线程保持时才获取锁定。这减少了线程等待锁定的阻塞时间。</li><li>处于 「 等待 」 状态以获取对同步块的访问的线程不能被中断。Lock 提供了一个 <code>lockInterruptibly()</code> 方法，可用于在等待锁定时中断线程。</li></ul><p>从上面的对比来看，同步块的所有机制，锁 ( Lock ) 都有相应的 API 对应。</p><h2 id="Lock-API"><a href="#Lock-API" class="headerlink" title="Lock API"></a>Lock API</h2><p>我们来看看 Lock 接口提供了哪些方法：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">void lock()</td><td align="center">尝试获取锁（如果可用），如果锁不可用，则线程会被阻塞，直到锁被释放</td></tr><tr><td align="center">oid lockInterruptibly()</td><td align="center">类似于 <code>lock()</code>，但它允许被阻塞的线程被中断并通过抛出的 <code>java.lang.InterruptedException</code> 恢复执行</td></tr><tr><td align="center">boolean tryLock()</td><td align="center"><code>lock()</code> 方法的非阻塞版本，它会立即尝试获取锁定，如果锁定成功则返回 true</td></tr><tr><td align="center">boolean tryLock(long timeout, TimeUnit timeUnit)</td><td align="center">类似于 <code>tryLock()</code>，但它可以指定超时，达到超时之后就会自动放弃获取锁</td></tr><tr><td align="center">void unlock()</td><td align="center">解锁 Lock 实例</td></tr></tbody></table><p>锁定的实例应该始终被解锁以避免死锁情况。</p><p>锁的推荐使用方式是将锁相关的代码块放在 <code>try/catch</code> 和 <code>finally</code> 块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...; </span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access to the shared resource</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 Lock 接口之外，<code>java.util.concurrent.lock</code> 包还提供了一个 ReadWriteLock 接口，俗称 「读写锁」，它维护一对锁，一个用于只读操作，一个用于写操作。</p><p>对于读写锁，只要没有写入，读锁定可以由多个线程同时保持。</p><p>ReadWriteLock 声明了两个方法用于获取读取或写入锁</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Lock readLock()</td><td align="center">返回一个用于读取的锁</td></tr><tr><td align="center">Lock writeLock()</td><td align="center">返回一个用于写的锁</td></tr></tbody></table><h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><h3 id="ReentrantLock-锁"><a href="#ReentrantLock-锁" class="headerlink" title="ReentrantLock 锁"></a>ReentrantLock 锁</h3><p>ReentrantLock 类实现了 <code>Lock</code> 接口。它提供了相同的并发和内存语义，如使用 synchronized 方法和语句访问的隐式监视器锁，而且可以被子类化。</p><p>我们写一个范例演示下如何使用 ReenrtantLock 来实现同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedObject</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">perform</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Critical section here</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的示例所示，我们需要确保在 <code>try-finally</code> 块中包装 <code>lock()</code> 和 <code>unlock()</code> 调用以避免死锁情况。</p><p>现在，让我们来看看 <code>tryLock()</code> 的工作原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTryLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLockAcquired</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLockAcquired) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Critical section here</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个范例中，调用 <code>tryLock()</code> 的线程将等待一秒钟，如果锁定不可用则放弃等待。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock 类实现了 ReadWriteLock 接口。</p><p>我们来看一下线程获取 ReadLock 或 WriteLock 的规则：</p><ul><li><strong>读锁</strong> : 如果没有线程获得写锁定或请求它，则多个线程可以获取读锁定。</li><li><strong>写锁</strong> : 如果没有线程正在读或写，则只有一个线程可以获取写锁。</li></ul><p>我们写一个范例演示下如何使用 ReadWriteLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedHashMapWithReadWriteLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,String&gt;  syncHashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            syncHashMap.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">return</span> syncHashMap.remove(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这两种 “写” 操作，我们需要使用写锁定来包围临界区，只有一个线程可以访问它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">return</span> syncHashMap.get(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">return</span> syncHashMap.containsKey(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这两种 “读” 操作，我们需要使用读锁定来包围临界区。如果没有正在进行的写操作，多个线程可以访问此部分。</p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock 是 Java 8 中引入的。它支持读写锁定。不同的是，锁的获取方法返回的戳记 （ stamp ） 可以用于释放锁定或检查锁定是否仍然有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockDemo</span> &#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StampedLock 提供的另一个功能是 「 乐观锁 」 。大多数时候，读操作不需要等待写操作完成，因此不需要完全成熟的读锁。相反，我们可以升级到读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">readWithOptimisticLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!lock.validate(stamp)) &#123;</span><br><span class="line">        stamp = lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(stamp);               </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><p>Condition 类让线程能够在执行临界区时等待某些条件发生。当线程获得对临界区的访问但没有执行其操作的必要条件时，可能会发生这种情况。</p><p>例如，读线程可以访问共享队列的锁，该队列仍然没有任何数据可供使用。</p><p>传统上，Java 为线程互通提供了 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法。</p><p>Condition 类有类似的机制，而且，还允许我们指定多个条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockWithCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">stackEmptyCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">stackFullCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushToStack</span><span class="params">(String item)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(stack.size() == CAPACITY)&#123;</span><br><span class="line">                stackFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(item);</span><br><span class="line">            stackEmptyCondition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">popFromStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(stack.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                stackEmptyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack.pop();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stackFullCondition.signalAll();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二、Java并发 Java BlockingQueue</title>
      <link href="/posts/deede7ad.html"/>
      <url>/posts/deede7ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="十二、Java并发-Java-BlockingQueue"><a href="#十二、Java并发-Java-BlockingQueue" class="headerlink" title="十二、Java并发 Java BlockingQueue"></a>十二、Java并发 Java BlockingQueue</h1><p>本文中，我们将介绍一个 <code>java.util.concurrent</code> 包提供的用于解决并发生产者 – 消费者问题的最有用的类 – BlockQueue。我们将介绍BlockingQueue 接口的 API 以及如何使用该接口的方法使编写并发程序更容易。</p><p>在本文的后面，我们将展示一个具有多个生产者线程和多个消费者线程的简单程序的示例。</p><h2 id="BlockingQueue-的队列类型"><a href="#BlockingQueue-的队列类型" class="headerlink" title="BlockingQueue 的队列类型"></a>BlockingQueue 的队列类型</h2><p>java.util.concurrent 提供了两种类型的 BlockingQueue：</p><p>1、 无限队列 （unbounded queue ） – 几乎可以无限增长<br>2、 有限队列 （ bounded queue ） – 定义了最大容量</p><h2 id="无限队列"><a href="#无限队列" class="headerlink" title="无限队列"></a>无限队列</h2><p>创建一个无限队列的方法很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>上面这段代码中，<code>blockingQueue</code> 的容量将设置为 <code>Integer.MAX_VALUE</code> 。</p><p>向无限队列添加元素的所有操作都将永远不会阻塞，因此它可以增长到非常大的容量。</p><p>使用无限 BlockingQueue 设计生产者 – 消费者模型时最重要的是 <strong>消费者应该能够像生产者向队列添加消息一样快地消费消息</strong> 。否则，内存可能会填满，然后就会得到一个 <code>OutOfMemory</code> 异常。</p><h2 id="有限队列"><a href="#有限队列" class="headerlink" title="有限队列"></a>有限队列</h2><p>第二种类型的队列是有限队列。我们可以通过将容量作为参数传递给构造函数来创建这样的队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue = new LinkedBlockingDeque&lt;&gt;(10);</span><br></pre></td></tr></table></figure><p>上面这句代码中，我们设置了 <code>blockingQueue</code> 的容量为 10 。这意味着当消费者尝试将元素添加到已经满了的队列时，结果取决于添加元素的方法（ <code>offer()</code> 、<code>add()</code> 、<code>put()</code> ) ，它将阻塞，直到有足够的空间可以插入元素。否则，添加操作将会失败。</p><p>使用有限队列是设计并发程序的好方法，因为当我们将元素插入到已经满了的队列时，这些操作需要等到消费者赶上并在队列中提供一些空间。这种机制可以让那个我们不做任何其它更改就可以实现节流。</p><h2 id="BlockingQueue-API"><a href="#BlockingQueue-API" class="headerlink" title="BlockingQueue API"></a>BlockingQueue API</h2><p>BlockingQueue 接口的所有方法可以分为两大类：负责向队列添加元素的方法和检索这些元素的方法。</p><p>在队列满/空的情况下，来自这两个组的每个方法的行为都不同。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><code>BlockingQueue</code> 提供了以下方法用于添加元素</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">add()</td><td align="center">如果插入成功则返回 true，否则抛出 IllegalStateException 异常</td></tr><tr><td align="center">put()</td><td align="center">将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入</td></tr><tr><td align="center">offer()</td><td align="center">如果插入成功则返回 true，否则返回 false</td></tr><tr><td align="center">offer(E e, long timeout, TimeUnit unit)</td><td align="center">尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入</td></tr></tbody></table><h3 id="检索元素"><a href="#检索元素" class="headerlink" title="检索元素"></a>检索元素</h3><p><code>BlockingQueue</code> 提供了以下方法用于检索元素</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">take()</td><td align="center">获取队列的头部元素并将其删除，如果队列为空，则阻塞并等待元素变为可用</td></tr><tr><td align="center">poll(long timeout, TimeUnit unit)</td><td align="center">检索并删除队列的头部，如有必要，等待指定的等待时间以使元素可用，如果超时，则返回 null</td></tr></tbody></table><p>在构建生产者 – 消费者程序时，这些方法是 BlockingQueue 接口中最重要的构建块。</p><h2 id="多线程生产者-–-消费者示例"><a href="#多线程生产者-–-消费者示例" class="headerlink" title="多线程生产者 – 消费者示例"></a>多线程生产者 – 消费者示例</h2><p>接下来我们创建一个由两部分组成的程序 – 生产者 ( Producer ) 和消费者 ( Consumer ) 。</p><p>生产者将生成一个 0 到 100 的随机数，并将该数字放在 BlockingQueue 中。我们将创建 4 个线程用于生成随机数并使用 <code>put()</code> 方法阻塞，直到队列中有可用空间。</p><p>需要记住的重要一点是，我们需要阻止我们的消费者线程无限期地等待元素出现在队列中。</p><p>从生产者向消费者发出信号的好方法是，不需要处理消息，而是发送称为毒 （ poison ） 丸 （ pill ） 的特殊消息。 我们需要发送尽可能多的毒 （ poison ） 丸 （ pill ） ，因为我们有消费者。然后当消费者从队列中获取特殊的毒 （ poison ） 丸 （ pill ）消息时，它将优雅地完成执行。</p><p>我们来看以下生产者的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumbersProducer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; numbersQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poisonPill;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poisonPillPerProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumbersProducer</span><span class="params">(BlockingQueue&lt;Integer&gt; numbersQueue, <span class="type">int</span> poisonPill, <span class="type">int</span> poisonPillPerProducer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numbersQueue = numbersQueue;</span><br><span class="line">        <span class="built_in">this</span>.poisonPill = poisonPill;</span><br><span class="line">        <span class="built_in">this</span>.poisonPillPerProducer = poisonPillPerProducer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            generateNumbers();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">generateNumbers</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numbersQueue.put(ThreadLocalRandom.current().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; poisonPillPerProducer; j++) &#123;</span><br><span class="line">            numbersQueue.put(poisonPill);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的生成器构造函数将 BlockingQueue 作为参数，用于协调生产者和使用者之间的处理。我们看到方法 <code>generateNumbers()</code> 将 100 个元素放入队列中。它还需要有毒 （ poison ） 丸 （ pill ） 消息，以便知道在执行完成时放入队列的消息类型。该消息需要将 poisonPillPerProducer 次放入队列中。</p><p>每个消费者将使用 <code>take()</code> 方法从 BlockingQueue 获取一个元素，因此它将阻塞，直到队列中有一个元素。从队列中取出一个 Integer 后，它会检查该消息是否是毒 （ poison ） 丸 （ pill ） ，如果是，则完成一个线程的执行。否则，它将在标准输出上打印出结果以及当前线程的名称。</p><p>这将使我们深入了解消费者的内部运作机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumbersConsumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poisonPill;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumbersConsumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue, <span class="type">int</span> poisonPill)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        <span class="built_in">this</span>.poisonPill = poisonPill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                <span class="keyword">if</span> (number.equals(poisonPill)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; result: &quot;</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的重要事项是队列的使用。与生成器构造函数中的相同，队列作为参数传递。我们可以这样做，是因为 BlockingQueue 可以在线程之间共享而无需任何显式同步。</p><p>既然我们有生产者和消费者，我们就可以开始我们的计划。我们需要定义队列的容量，并将其设置为 100 个元素。</p><p>我们希望有 4 个生产者线程，并且有许多消费者线程将等于可用处理器的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">BOUND</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N_PRODUCERS</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N_CONSUMERS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="type">int</span> <span class="variable">poisonPill</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">poisonPillPerProducer</span> <span class="operator">=</span> N_CONSUMERS / N_PRODUCERS;</span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> N_CONSUMERS % N_PRODUCERS;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(BOUND);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N_PRODUCERS; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NumbersProducer</span>(queue, poisonPill, poisonPillPerProducer)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N_CONSUMERS; j++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NumbersConsumer</span>(queue, poisonPill)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NumbersProducer</span>(queue, poisonPill, poisonPillPerProducer + mod)).start();</span><br></pre></td></tr></table></figure><p>BlockingQueue 是使用具有容量的构造创建的。我们正在创造 4 个生产者和 N 个消费者。我们将我们的毒 （ poison ） 丸 （ pill ）消息指定为 <code>Integer.MAX_VALUE</code>，因为我们的生产者在正常工作条件下永远不会发送这样的值。这里要注意的最重要的事情是 BlockingQueue 用于协调它们之间的工作。</p><p>当我们运行程序时，4 个生产者线程将随机整数放入 BlockingQueue 中，消费者将从队列中获取这些元素。每个线程将打印到标准输出线程的名称和结果。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一、Java并发 Java CountDownLatch</title>
      <link href="/posts/92030527.html"/>
      <url>/posts/92030527.html</url>
      
        <content type="html"><![CDATA[<h1 id="十一、Java并发-Java-CountDownLatch"><a href="#十一、Java并发-Java-CountDownLatch" class="headerlink" title="十一、Java并发 Java CountDownLatch"></a>十一、Java并发 Java CountDownLatch</h1><p>本章节我们来讨论下 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html">java.util.concurrent.CountDownLatch</a> 这个类，顺带演示下如何在一些实际例子中使用它。</p><p>CountDownLatch 类的作用呢？ 怎么说呢？ 简单来说，我们可以使用它来阻塞线程，直到其他线程完成给定任务。</p><h2 id="并发编程中使用-CountDownLatch"><a href="#并发编程中使用-CountDownLatch" class="headerlink" title="并发编程中使用 CountDownLatch"></a>并发编程中使用 CountDownLatch</h2><p>简而言之，CountDownLatch 有一个计数器字段，我们可以根据需要减少它，因此，我们可以使用它来阻止调用线程，直到它被计数到零。</p><p>如果我们正在进行一些并行处理，我们可以使用与计数器相同的值来实例化 CountDownLatch，因为我们想要处理多个线程。然后，我们可以在每个线程完成后调用 <code>countdown()</code>，保证调用 <code>await()</code> 的依赖线程将阻塞，直到工作线程完成。</p><h2 id="使用-CountDownLatch-等待线程池完成"><a href="#使用-CountDownLatch-等待线程池完成" class="headerlink" title="使用 CountDownLatch 等待线程池完成"></a>使用 CountDownLatch 等待线程池完成</h2><p>我们通过创建一个 Worker 来尝试这个模式，并使用 CountDownLatch 字段来指示它何时完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; outputScraper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(List&lt;String&gt; outputScraper, CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.outputScraper = outputScraper;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doSomeWork();</span><br><span class="line">        outputScraper.add(<span class="string">&quot;Counted down&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个测试，以证明我们可以让 CountDownLatch 等待 Worker 实例完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenParallelProcessing_thenMainThreadWillBlockUntilCompletion</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; outputScraper = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    List&lt;Thread&gt; workers = Stream</span><br><span class="line">      .generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(outputScraper, countDownLatch)))</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(toList());</span><br><span class="line"></span><br><span class="line">      workers.forEach(Thread::start);</span><br><span class="line">      countDownLatch.await(); </span><br><span class="line">      outputScraper.add(<span class="string">&quot;Latch released&quot;</span>);</span><br><span class="line"></span><br><span class="line">      assertThat(outputScraper)</span><br><span class="line">        .containsExactly(</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Latch released&quot;</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个示例中，<code>&quot;Latch release&quot;</code> 将始终是最后一个输出 – 因为它取决于 CountDownLatch 的释放。</p><p>注意，如果我们没有调用 <code>await()</code> 方法，我们将无法保证线程执行的顺序，因此测试会随机失败。</p><h2 id="在等待开始的线程池中使用-CountDownLatch"><a href="#在等待开始的线程池中使用-CountDownLatch" class="headerlink" title="在等待开始的线程池中使用 CountDownLatch"></a>在等待开始的线程池中使用 CountDownLatch</h2><p>我们重用前面的示例，但是这次开启了了数千个线程而不是 5 个线程，很可能许多早期的线程在后面的线程上调用 <code>start()</code> 之前已经完成了处理。这可能会使尝试重现并发问题变得困难，因为我们无法让所有线程并行运行。</p><p>为了解决这个问题，我们让 CountdownLatch 的工作方式与上一个示例有所不同。在某些子线程完成之前，我们可以阻止每个子线程直到所有其他子线程都启动，而不是阻塞父线程。</p><p>我们把上一个示例的 <code>run()</code> 方法修改下，使其在处理之前阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; outputScraper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch readyThreadCounter;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch callingThreadBlocker;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch completedThreadCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitingWorker</span><span class="params">(</span></span><br><span class="line"><span class="params">      List&lt;String&gt; outputScraper,</span></span><br><span class="line"><span class="params">      CountDownLatch readyThreadCounter,</span></span><br><span class="line"><span class="params">      CountDownLatch callingThreadBlocker,</span></span><br><span class="line"><span class="params">      CountDownLatch completedThreadCounter)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.outputScraper = outputScraper;</span><br><span class="line">        <span class="built_in">this</span>.readyThreadCounter = readyThreadCounter;</span><br><span class="line">        <span class="built_in">this</span>.callingThreadBlocker = callingThreadBlocker;</span><br><span class="line">        <span class="built_in">this</span>.completedThreadCounter = completedThreadCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        readyThreadCounter.countDown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callingThreadBlocker.await();</span><br><span class="line">            doSomeWork();</span><br><span class="line">            outputScraper.add(<span class="string">&quot;Counted down&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            completedThreadCounter.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们修改下测试，直到所有工人都已启动，解锁工人，然后阻止，直到工人完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenDoingLotsOfThreadsInParallel_thenStartThemAtTheSameTime</span><span class="params">()</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; outputScraper = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">readyThreadCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">callingThreadBlocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">completedThreadCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    List&lt;Thread&gt; workers = Stream</span><br><span class="line">      .generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitingWorker</span>(</span><br><span class="line">        outputScraper, readyThreadCounter, callingThreadBlocker, completedThreadCounter)))</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(toList());</span><br><span class="line"></span><br><span class="line">    workers.forEach(Thread::start);</span><br><span class="line">    readyThreadCounter.await(); </span><br><span class="line">    outputScraper.add(<span class="string">&quot;Workers ready&quot;</span>);</span><br><span class="line">    callingThreadBlocker.countDown(); </span><br><span class="line">    completedThreadCounter.await(); </span><br><span class="line">    outputScraper.add(<span class="string">&quot;Workers complete&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assertThat(outputScraper)</span><br><span class="line">      .containsExactly(</span><br><span class="line">        <span class="string">&quot;Workers ready&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Counted down&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Workers complete&quot;</span></span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式对于尝试重现并发错误非常有用，可以用来强制数千个线程尝试并行执行某些逻辑。</p><h2 id="让-CountdownLatch-尽早结束"><a href="#让-CountdownLatch-尽早结束" class="headerlink" title="让 CountdownLatch 尽早结束"></a>让 CountdownLatch 尽早结束</h2><p>有时，我们可能会遇到一个情况，即在 CountdownLatch 倒计时之前，Workers 已经终止了错误。这可能导致它永远不会达到零并且 <code>await()</code> 永远不会终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oh dear, I&#x27;m a BrokenWorker&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    outputScraper.add(<span class="string">&quot;Counted down&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改下之前的测试以使用 BrokenWorker，来演示 <code>await()</code> 将如何永久阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenFailingToParallelProcess_thenMainThreadShouldGetNotGetStuck</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; outputScraper = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">    List&lt;Thread&gt; workers = Stream</span><br><span class="line">      .generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BrokenWorker</span>(outputScraper, countDownLatch)))</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .collect(toList());</span><br><span class="line"></span><br><span class="line">    workers.forEach(Thread::start);</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这不是我们想要的行为 – 应用程序继续比无限阻塞要好得多。</p><p>为了解决这个问题，我们在调用 <code>await()</code> 时添加一个超时参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">completed</span> <span class="operator">=</span> countDownLatch.await(<span class="number">3L</span>, TimeUnit.SECONDS);</span><br><span class="line">assertThat(completed).isFalse();</span><br></pre></td></tr></table></figure><p>然后，我们可以看到，测试最终会超时，<code>await()</code> 将返回 false</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、Java并发系列之 Java 并发编程面试题</title>
      <link href="/posts/774c589b.html"/>
      <url>/posts/774c589b.html</url>
      
        <content type="html"><![CDATA[<h1 id="十、Java并发系列之-Java-并发编程面试题"><a href="#十、Java并发系列之-Java-并发编程面试题" class="headerlink" title="十、Java并发系列之 Java 并发编程面试题"></a>十、Java并发系列之 Java 并发编程面试题</h1><p>应聘 Java 岗，总是免不了几个 Java 并发编程的面试题，不过大多数都局限在 <code>java.util.concurrent</code> 包下的知识和实现问题。本文针对 Java 并发相关的常见的面试题做一些解释。</p><h2 id="Q1-进程和线程的区别？"><a href="#Q1-进程和线程的区别？" class="headerlink" title="Q1: 进程和线程的区别？"></a><strong>Q1: 进程和线程的区别？</strong></h2><blockquote><p>这是一个非常基础的面试题，如果这道题没有回答的比较满意，一般情况下，面试官会认为应聘者在并发方面的基础只是不牢固，就不会继续深入询问其它并发问题了。</p></blockquote><p>1、进程和线程都是并发单元，但它们有一个根本区别：<strong>进程不共享公共内存，而线程则共享</strong>。<br>2、从操作系统的角度来看，进程是一个独立的软件，在其自己的虚拟内存空间中运行。任何一个多任务操作系统（这几乎意味着任何现代操作系统）都必须将内存中的进程分开，这样一个失败的进程就不会通过加扰公共内存来拖累所有其它进程。因此，进程通常是隔离的，它们通过进程间通信进行协作，进程间通信由操作系统定义为一种中间 API。<br>3、相反，线程是应用程序的一部分，它与同一应用程序的其他线程共享公共内存。使用公共内存可以减少大量开销，因此使用线程可以更快的交换数据和进行线程间协作。</p><blockquote><p>关于进程间通讯那一块可以不用回答，如果你不懂的话，不必然会导致接下来的某个问题是 进程间通讯的的原理.</p></blockquote><h2 id="Q2-如何创建一个线程实例并且运行它？"><a href="#Q2-如何创建一个线程实例并且运行它？" class="headerlink" title="Q2: 如何创建一个线程实例并且运行它？"></a><strong>Q2: 如何创建一个线程实例并且运行它？</strong></h2><blockquote><p>这道题考察的是对 Runnable 的理解。</p></blockquote><p>创建一个线程的实例，有两种方法可供选择:</p><p>1、把 Runnable 的实例传递给 Thread 的构造函数并调用 <code>start()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;</span><br><span class="line">  System.out.println(<span class="string">&quot;Hello World from Runnable!&quot;</span>));</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure><p>Runnable是一个函数接口，因此可以作为 lambda 表达式传递<br>2、因为线程本身也实现了 Runnable 接口，所以另一种创建线程的方法是创建一个匿名子类，覆写它的 <code>run()</code> 方法，然后调用 <code>start()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World from subclass!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><h2 id="Q3-描述线程的不同状态以及何时发生状态转换-？"><a href="#Q3-描述线程的不同状态以及何时发生状态转换-？" class="headerlink" title="Q3: 描述线程的不同状态以及何时发生状态转换 ？"></a><strong>Q3: 描述线程的不同状态以及何时发生状态转换 ？</strong></h2><blockquote><p>这道题考察的是对线程生命周期的理解。</p></blockquote><p>1、一般情况下，我们会使用 <code>Thread.getState()</code> 方法检查线程 ( Thread ) 的状态。<br>2、线程的不同状态都定义在 <code>Thread.State</code> 枚举中。<br>3、线程的所有状态如下所示</p><p>1、<strong>NEW</strong> : 一个尚未调用 <code>Thread.start()</code> 方法启动的新 Thread 实例。<br>2、<strong>RUNNABLE</strong> : 一个正在运行的线程。它被称为 runnable，因为在任何给定时间，它要么正在运行要么在等待线程调度。当调用<code>Thread.start()</code> 方法时，会将一个 <code>NEW</code> 线程进入 <code>RUNNABLE</code> 状态。<br>3、<strong>BLOCKED</strong> : 如果正在运行的线程需要进入同步部分但由于另一个线程持有此部分的监视器而无法执行此操作，则该线程将被阻塞。<br>4、<strong>WAITING</strong> : 如果线程等待另一个线程执行特定操作，则该线程进入此状态。例如，一个线程在它持有的监视器上调用 <code>Object.wait()</code> 法时进入此状态，或者在另一个线程上调用 <code>Thread.join()</code> 方法也会进入此状态。<br>5、<strong>IMED_WAITING</strong> : 跟 <strong>WAITING</strong> 状态差不多。但线程在调用 <code>Thread.sleep()</code>、<code>Object.wait()</code>、或 <code>Thread.join()</code> 和其他一些方法的定时版本后进入此状态<br>6、<strong>TERMINATED</strong> ： 当一个线程已经完成它的 <code>Runnable.run()</code> 方法的执行并终止时进入此状态。</p><h2 id="Q4-Runnable-和-Callable-接口有什么区别？它们是如何使用的？"><a href="#Q4-Runnable-和-Callable-接口有什么区别？它们是如何使用的？" class="headerlink" title="Q4: Runnable 和 Callable 接口有什么区别？它们是如何使用的？"></a>Q4: Runnable 和 Callable 接口有什么区别？它们是如何使用的？</h2><p>1、Runnable 接口表示必须在单独的线程中运行的计算单位，它只有一个 <code>run()</code> 方法。Runnable 接口不允许此方法返回值或抛出未经检查的异常。<br>2、Callable 接口表示具有返回值的任务，它只有一个 <code>call()</code> 方法。<code>call()</code> 方法可以返回一个值 ( 可以是 Void )，也可以抛出一个异常。Callable 通常在 <code>ExecutorService</code> 实例中用于启动异步任务，然后调用返回的 Future 实例以获取其值。</p><h2 id="Q5-什么是守护线程，它的使用场景是什么？如何创建守护线程-？"><a href="#Q5-什么是守护线程，它的使用场景是什么？如何创建守护线程-？" class="headerlink" title="Q5: 什么是守护线程，它的使用场景是什么？如何创建守护线程 ？"></a>Q5: 什么是守护线程，它的使用场景是什么？如何创建守护线程 ？</h2><p>1、守护线程是一个不阻止 Java 虚拟机 ( JVM ) 退出的线程。当所有非守护线程终止时，JVM 只是放弃所有剩余的守护线程。<br>2、守护线程通常用于为其他线程执行一些支持或服务任务，但我们应该考虑到它们可能随时被放弃。<br>3、要将一个线程作为守护线程启动，应该在调用 <code>start()</code> 之前使用 <code>setDaemon()</code>方法设置为守护线程。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()</span><br><span class="line">  -&gt; System.out.println(<span class="string">&quot;Hello from daemon!&quot;</span>));</span><br><span class="line">daemon.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure><h3 id="额外的"><a href="#额外的" class="headerlink" title="额外的"></a>额外的</h3><p>奇怪的是，如果将上面的代码放在 <code>main()</code> 内运行，则可能无法打印该消息。而发生这种情况的原因，是因为 <code>main()</code> 线程在守护线程运行到打印消息之前就已经终止。</p><p>我们不应该在守护线程中执行任何 I/O 操作，因为它们甚至无法执行其 finally 块并在被放弃时关闭资源。</p><h2 id="Q6-什么是-Thread-的中断标志？怎么设置和检查它？它与-InterruptedException-有什么关系？"><a href="#Q6-什么是-Thread-的中断标志？怎么设置和检查它？它与-InterruptedException-有什么关系？" class="headerlink" title="Q6: 什么是 Thread 的中断标志？怎么设置和检查它？它与 InterruptedException 有什么关系？"></a>Q6: 什么是 Thread 的中断标志？怎么设置和检查它？它与 InterruptedException 有什么关系？</h2><p>1、中断 ( interrupt ) 标志或中断状态是线程中断时设置的内部线程标志 ( <code>flag</code> 属性 ）。<br>2、要设置一个线程的中断标志，只需要简单的在线程对象上调用 <code>thread.interrupt()</code> 方法。<br>3、如果在某个方法内部的一个线程抛出了 <code>InterruptedException</code>（ <code>wait</code>、<code>join</code>、<code>sleep</code> 等 ），那么此方法会立即抛出InterruptedException。线程可以根据自己的逻辑自由处理此异常。如果一个线程不在这样的方法中并且调用了 <code>thread.interrupt()</code>，则不会发生任何特殊情况。<br>4、线程的中断状态可以通过使用静态 <code>Thread.interrupted()</code> 方法或实例的 <code>isInterrupted()</code> 方法定期检查。这两个方法的区别是静态<code>Thread.interrupt()</code> 会清除了中断标志，而 <code>isInterrupted()</code> 则不会。</p><h2 id="Q7-什么是-Executor-和-ExecutorService-？这两个接口有什么区别？"><a href="#Q7-什么是-Executor-和-ExecutorService-？这两个接口有什么区别？" class="headerlink" title="Q7: 什么是 Executor 和 ExecutorService ？这两个接口有什么区别？"></a>Q7: 什么是 Executor 和 ExecutorService ？这两个接口有什么区别？</h2><p>1、<code>Executor</code> 和 <code>ExecutorService</code> 是 <code>java.util.concurrent</code> 框架提供的两个相关接口。<br>2、<code>Executor</code> 是一个非常简单的接口，只有一个 <code>execute()</code> 方法接受 Runnable 实例来执行。在大多数情况下，这是我们的任务执行代码应该依赖的接口。<br>3、<code>ExecutorService</code> 扩展了 <code>Executor</code> 接口，并且添加了许多其它方法以处理和检查并发任务执行服务的生命周期（在关闭时终止任务）和更复杂的异步任务处理，包括 Futures。</p><blockquote><p>更多 Executor 和 ExecutorService 的知识，可以访问 一文秒懂 Java ExecutorService。</p></blockquote><h2 id="Q8-java-util-concurrent-标准库中-ExecutorService-的可用实现是什么-？"><a href="#Q8-java-util-concurrent-标准库中-ExecutorService-的可用实现是什么-？" class="headerlink" title="Q8: java.util.concurrent 标准库中 ExecutorService 的可用实现是什么 ？"></a>Q8: java.util.concurrent 标准库中 ExecutorService 的可用实现是什么 ？</h2><blockquote><p>这是一个非常变 tai 的问题。问这个问题的面试官，你想咋样啊 ？</p></blockquote><p>ExecutorService 接口有三个标准实现</p><p>1、<code>ThreadPoolExecutor</code> : 使用线程池执行任务。一旦某个线程完成执行任务，它就会回到线程池中。如果池中的所有线程都忙，则任务必须等待轮到它。<br>2、<code>ScheduledThreadPoolExecutor</code> : 允许安排任务执行，而不是简单的在线程可用时立即运行任务。它还可以按固定频率或固定延迟安排任务。<br>3、<code>ForkJoinPool</code> : 是一个特殊的 ExecutorService，用于处理递归算法任务。如果你使用常规 ThreadPoolExecutor 进行递归算法，那么你很快发现所有线程都在忙着等待较低级别的递归完成。ForkJoinPool 实现了所谓的工作窃取算法，允许它更有效地使用可用线程。</p><h2 id="Q9-什么是-Java-内存模型（-JMM-）？描述下其目的和基本思想"><a href="#Q9-什么是-Java-内存模型（-JMM-）？描述下其目的和基本思想" class="headerlink" title="Q9: 什么是 Java 内存模型（ JMM ）？描述下其目的和基本思想"></a>Q9: 什么是 Java 内存模型（ JMM ）？描述下其目的和基本思想</h2><p>Java 内存模式是 Java 语言规范的一部分</p><p>JMM 规定了多个线程如何访问并发 Java 应用程序中的公共内存，以及一个线程的数据更改如何对其他线程可见。</p><p>是不是很简单，虽然简短又简洁，但如果没有强大的数学背景，JMM 可能很难掌握。</p><p>对内存模型的需求源于这样一个事实：<strong>Java 代码访问数据的方式并不像它在底层实际发生的那样</strong>。</p><p>在保证内存读写的可观察结果是相同的情况下，Java 编译器，JIT 编译器甚至 CPU 都可以对内存读写进行重新排序或优化。</p><p>当我们的应用程序扩展到多个线程时，这会导致反直觉的结果，因为大多数这些优化只会考虑单个执行线程（ 跨线程优化器仍然非常难以实现 ）。</p><p>另一个可怕的问题是现代系统中的内存是多层的：<strong>处理器的多个内核可能会在其缓存或读/写缓冲区中保留一些非刷新数据，这也会影响从其它内核观察到的内存状态</strong>。</p><p>更糟糕的是，不同内存访问架构的存在将打破Java 「 一次编写，随处运行 」 的承诺。</p><p>但另所有 Java 程序员高兴的是，JMM 指定了在设计多线程应用程序时可能依赖的一些保证。坚持这些保证有助于程序员编写在各种体系结构之间稳定且可移植的多线程代码。</p><p>JMM 的主要概念是：</p><ul><li><strong>动作 ( Action )</strong> : 这些是线程间的动作，可以由一个线程执行并由另一个线程检测，如读取或写入变量，锁定/解锁监视器等等。</li><li><strong>同步动作 ( Synchronization actions )</strong> : 某个动作子集，例如读取/写入易失性变量，或锁定/解锁监视器。</li><li><strong>程序顺序 ( Program Order )</strong> : 俗称 <code>PO</code>，单个线程内可观察的动作总顺序。</li><li><strong>同步顺序 ( Synchronization Order )</strong> : 俗称 <code>SO</code>，所有同步操作之间的总顺序 – 它必须与程序顺序一致，也就是说，如果两个同步操作在PO 中一个接一个地出现，它们在 SO 中以相同的顺序出现 。</li><li><strong>同步与（ synchronizes-with）</strong> : 俗称 <code>SW</code> ，某些同步操作之间的关系，例如解锁监视器和锁定同一监视器（ 在另一个或同一个线程中 ）。</li><li><strong>发生在顺序之前 ( Happens-before Order )</strong> : 将 PO 与 SW 结合（ 在集合论中称为传递闭包 ），以创建线程之间所有动作的部分排序。如果一个动作发生在另一个动作之前，则第二个动作可以观察到第一个动作的结果（ 例如，在一个线程中写入变量并在另一个线程中读取 ）。</li><li><strong>发生在一致性之前 ( Happens-before consistency )</strong> : 如果每次读取都遵循先前发生的顺序中对该位置的最后一次写入，或者通过数据竞争进行其他一些写入操作，则一组操作是 HB 一致的。</li><li><strong>执行 ( Execution )</strong> : 它们之间有一组有序的动作和一致性规则</li></ul><p>对于给定的程序，我们可以观察到具有各种结果的多个不同的执行.但是如果一个程序正确同步，那么它的所有执行似乎都是顺序一致的，这意味着我们可以将多线程程序推断为一系列按顺序发生的动作。这样可以省去考虑引擎盖下重新排序，优化或数据缓存的麻烦。</p><blockquote><p>如果你了解协程，相关的概念和协程很相像的。</p></blockquote><h2 id="Q10-什么是易失-（-volatile-）-字段，JMM-对这样的领域有什么保证？"><a href="#Q10-什么是易失-（-volatile-）-字段，JMM-对这样的领域有什么保证？" class="headerlink" title="Q10: 什么是易失 （ volatile ） 字段，JMM 对这样的领域有什么保证？"></a>Q10: 什么是易失 （ volatile ） 字段，JMM 对这样的领域有什么保证？</h2><p>根据 Java 内存模型 （ 参见 Q9 ） ，<code>volatile</code> 字段具有特殊属性。<code>volatile</code> 变量的读取和写入是同步操作，这意味着它们具有总排序（ 所有线程将遵循这些操作的一致顺序 ）。根据此顺序，保证读取 volatile 变量可以观察到对此变量的最后一次写入。</p><p>如果你有一个从多个线程访问的字段，且至少有一个线程写入它，那么你应该考虑使它变得 <code>volatile</code> ，否则某个线程从这个字段读取的内容并不会得到一丝的保证。</p><p><code>volatile</code> 的另一个保证是写入和读取 64 位值（ <code>long</code> 类型和 <code>double</code> 类型 ）的原子性。如果没有 <code>volatile</code> 修饰符，读取此类字段可能会观察到另一个线程部分写入的值。</p><h2 id="Q11-以下哪项操作是原子操作"><a href="#Q11-以下哪项操作是原子操作" class="headerlink" title="Q11: 以下哪项操作是原子操作 ?"></a>Q11: 以下哪项操作是原子操作 ?</h2><ul><li>写入一个非 volatile int 类型</li><li>写入一个 volatile int 类型</li><li>写入一个非 volatile long 类型</li><li>写入一个 volatile long 类型</li><li>递增一个 volatile long 类型</li></ul><p>是不是瞬间蒙了？我们来解释一下</p><p>1、对 int 类型（ 32位 ）变量的写入保证是原子的，无论它是否是易失性的。<br>2、long 类型（ 64位 ）变量可能需要在两个单独的步骤中写入，例如，在 32 位体系结构上，因此默认情况下，没有原子性保证。但是，如果添加了 <code>volatile</code> 修饰符，则保证以原子方式访问 long 变量。<br>3、递增操作通常由多个步骤完成（ 检索值，更改它并写回 ），因此它永远不会保证是原子的，变量是易变的。如果要实现值的原子增量，则应使用类<code>AtomicInteger</code>， <code>AtomicLong</code> 等。</p><h2 id="Q12-JMM-对添加了-final-修饰符的类的字段有什么特殊保证-？"><a href="#Q12-JMM-对添加了-final-修饰符的类的字段有什么特殊保证-？" class="headerlink" title="Q12: JMM 对添加了 final 修饰符的类的字段有什么特殊保证 ？"></a>Q12: JMM 对添加了 <code>final</code> 修饰符的类的字段有什么特殊保证 ？</h2><p>JVM 基本上会保证在任何线程获取对象之前初始化类的 <code>final</code> 字段。</p><p>如果没有这种保证，由于重新排序或其他优化，在初始化该对象的所有字段之前，可以向另一个线程发布对象的引用，即变得可见。这可能会导致对这些字段的访问。</p><p>这就是为什么在创建不可变对象时，应始终将其所有字段设为 <code>final</code>，即使它们不能通过 getter 方法访问。</p><h2 id="Q13-方法定义中-synchronized-关键字的含义是什么？静态方法？在一个块之前-？"><a href="#Q13-方法定义中-synchronized-关键字的含义是什么？静态方法？在一个块之前-？" class="headerlink" title="Q13: 方法定义中 synchronized 关键字的含义是什么？静态方法？在一个块之前 ？"></a>Q13: 方法定义中 synchronized 关键字的含义是什么？静态方法？在一个块之前 ？</h2><p>块 ( block ) 之前的 synchronized 关键字表示进入该块的任何线程都必须获取监视器（ 括号中的对象 ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">如果监视器已被另一个线程获取，则前一个线程将进入 BLOCKED 状态并等待监视器被释放。</span><br><span class="line"></span><br><span class="line">同步实例方法具有相同的语义，但会使用实例本身充当监视器。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态同步方法，监视器是表示声明类的 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q14-如果两个线程同时在不同的对象实例上调用-synchronized-方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办"><a href="#Q14-如果两个线程同时在不同的对象实例上调用-synchronized-方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办" class="headerlink" title="Q14: 如果两个线程同时在不同的对象实例上调用 synchronized 方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办?"></a>Q14: 如果两个线程同时在不同的对象实例上调用 synchronized 方法，这些线程中的一个是否会阻塞？如果该方法是静态的，该怎么办?</h2><p>如果方法是实例方法，则实例充当方法的监视器。在不同实例上调用该方法的两个线程获取不同的监视器，因此它们都不会被阻塞。</p><p>如果方法是静态的，则监视器是 <code>Class</code> 对象。对于两个线程，监视器是相同的，因此其中一个可能会阻塞并等待另一个退出 <code>synchronized</code> 方法。</p><h2 id="Q15-Object类的-wait，notify-和-notifyAll-方法的目的是什么-？"><a href="#Q15-Object类的-wait，notify-和-notifyAll-方法的目的是什么-？" class="headerlink" title="Q15: Object类的 wait，notify 和 notifyAll 方法的目的是什么 ？"></a>Q15: Object类的 wait，notify 和 notifyAll 方法的目的是什么 ？</h2><p>拥有对象监视器的线程（ 例如，已进入由对象保护的同步部分的线程 ）可以调用 <code>object.wait()</code> 来临时释放监视器并为其他线程提供获取监视器的机会。例如，这可以在等待某个条件的情况下完成。</p><p>当另一个获取监视器的线程满足条件时，它可以调用 <code>object.notify()</code> 或 <code>object.notifyAll()</code> 并释放监视器。<code>notify()</code> 方法唤醒处于等待状态的单个线程，<code>notifyAll()</code> 方法唤醒等待此监视器的所有线程，并且它们都竞争重新获取锁定。</p><p>下面的 BlockingQueue 实现演示了多个线程如何通过 <code>wait-notify</code> 模式一起工作。如果我们将一个元素放入一个空队列，那么在 <code>take()</code> 方法中等待的所有线程都会唤醒并尝试接收该值。如果我们将一个元素放入一个已经满了的队列，<code>put()</code> 方法将等待对 <code>get()</code> 方法的调用。<code>get()</code> 方法删除一个元素，并通知在 <code>put()</code> 方法中等待队列对新项目有空位置的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == limit) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == limit) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q16-描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因"><a href="#Q16-描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因" class="headerlink" title="Q16: 描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因 ?"></a>Q16: 描述死锁，存活锁和饥饿的条件。描述这些情况的可能原因 ?</h2><ul><li>死锁 （ <code>DeadLock</code> ） 是一组无法进行的线程中的条件，因为组中的每个线程都必须获取已由组中的另一个线程获取的某些资源。最简单的情况是两个线程需要锁定两个资源才能进行，第一个资源已被一个线程锁定，第二个资源已被另一个线程锁定。因为这些线程永远不会获得对两个资源的锁定，因此永远不会进展。</li><li>存活锁 ( <code>LiveLock</code> ) 是多线程对自己生成的条件或事件做出反应的一种情况。事件发生在一个线程中，必须由另一个线程处理。在此处理期间，发生的新事件必须在第一个线程中处理，依此类推。这样的线程是活着的并且没有被阻挡，但是仍然没有取得任何进展，因为它们用无用的工作压倒了对方</li><li>饥饿锁 ( <code>Starvation</code> ) 是线程无法获取资源的情况，因为其他线程（或多个线程）占用它太长时间或具有更高的优先级。线程无法取得进展，因此无法完成有用的工作。</li></ul><h2 id="Q17-描述-fork-join-框架的用途和用例"><a href="#Q17-描述-fork-join-框架的用途和用例" class="headerlink" title="Q17: 描述 fork/join 框架的用途和用例"></a>Q17: 描述 fork/join 框架的用途和用例</h2><p>fork/join 框架允许并行化递归算法。使用 ThreadPoolExecutor 之类的并行递归的主要问题是，可能会快速耗尽线程，因为每个递归步骤都需要自己的线程，而堆栈中的线程将处于空闲状态并等待。</p><p>fork/join 框架入口点是 ForkJoinPool 类，它是 ExecutorService 的一个实现。它实现了工作窃取算法，空闲线程会试图从忙线程中 「 窃取 」 工作。这允许在不同线程之间传播计算并在使用比通常的线程池所需的更少的线程时取得进展</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、Java并发 Java CompletableFuture ( 下 )</title>
      <link href="/posts/47722b62.html"/>
      <url>/posts/47722b62.html</url>
      
        <content type="html"><![CDATA[<h1 id="九、Java并发-Java-CompletableFuture-下"><a href="#九、Java并发-Java-CompletableFuture-下" class="headerlink" title="九、Java并发 Java CompletableFuture ( 下 )"></a>九、Java并发 Java CompletableFuture ( 下 )</h1><p>上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果</p><h2 id="组合-Futures"><a href="#组合-Futures" class="headerlink" title="组合 Futures"></a>组合 Futures</h2><p>CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。</p><p>这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。</p><p>CompletableFuture 提供了方法 <code>thenCompose()</code> 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。</p><p>例如下面这个示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;简单&quot;</span>)</span><br><span class="line">    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;教程&quot;</span>));</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;云遇未晚&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p><code>thenCompose()</code> 方法与 <code>thenApply()</code> 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。</p><p>两个方法都接收一个函数并将其应用于计算结果，但 <code>thenCompose()</code> （ <code>flatMap()</code> ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。</p><p>如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 <code>thenCombine()</code> 并传递能够接收两个参数的函数或表达式来处理这两个结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line">      () -&gt; <span class="string">&quot; World&quot;</span>), (s1, s2) -&gt; s1 + s2));</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello World&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p>更简单的情况是，当你想要使用两个 Futures 的结果时，但有不想把任何结果值传递给 Future 链，则可以使用 <code>thenAcceptBoth()</code> 方法，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompletableFuture</span> <span class="variable">future</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">  .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot; World&quot;</span>),</span><br><span class="line">    (s1, s2) -&gt; System.out.println(s1 + s2));</span><br></pre></td></tr></table></figure><h2 id="并行执行多个-Future"><a href="#并行执行多个-Future" class="headerlink" title="并行执行多个 Future"></a>并行执行多个 Future</h2><p>当我们需要并行执行多个 Futures 时，通常是希望等待所有 Futures 执行完成然后处理它们的组合结果。</p><p><code>CompletableFuture.allOf()</code> 静态方法允许等待作为 var-arg 提供的所有 Future 的完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future2  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Beautiful&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; future3  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; combinedFuture </span><br><span class="line">  = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">combinedFuture.get();</span><br><span class="line"></span><br><span class="line">assertTrue(future1.isDone());</span><br><span class="line">assertTrue(future2.isDone());</span><br><span class="line">assertTrue(future3.isDone());</span><br></pre></td></tr></table></figure><blockquote><p>var-arg 的意思是：参数数量不定的意思。也就是可以传递任意相同类型的参数。</p></blockquote><p>上面的示例中，你应该留意到了 <code>CompletableFuture.allOf()</code> 方法的返回类型是 <code>CompletableFuture &lt;Void&gt;</code>，这个方法的局限是它不会返回所有 Future 的综合结果。相反，你必须手动从 Futures 获取结果。幸运的是，<code>CompletableFuture.join()</code> 方法和 Java 8 Streams API 可以做到这一点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">combined</span> <span class="operator">=</span> Stream.of(future1, future2, future3)</span><br><span class="line">  .map(CompletableFuture::join)</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello Beautiful World&quot;</span>, combined);</span><br></pre></td></tr></table></figure><p><code>CompletableFuture.join()</code> 方法类似于 <code>get()</code> 方法，但是如果 Future 未正常完成，它会抛出未经检查的异常，这种机制，使得它可以作为 <code>Stream.map()</code> 的参数。</p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>对于异步计算步骤链中的错误处理，惯用的方法是调整 <code>throw/catch</code> 。</p><p>怎么个调整法呢 ？</p><p>CompletableFuture 类允许我们在特殊的 <code>handle()</code> 方法中处理它，而不是在语法块中捕获异常。</p><p>此 <code>handle()</code> 方法接收接收两个参数：计算结果（ 如果成功完成 ）和抛出异常（ 如果某些计算步骤未正常完成 ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">  &#125;)&#125;).handle((s, t) -&gt; s != <span class="literal">null</span> ? s : <span class="string">&quot;Hello, Stranger!&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello, Stranger!&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p>上面这个示例中，我们使用 <code>handle()</code> 方法在问候语的异步计算完成时提供默认值，因为没有提供 <code>name</code> 。</p><p>作为替代方案，假设我们想要手动使用某个值完成 Future ，就像第一个示例中所示，但同时又需要有能力通过异常完成它。那么，可以使用 <code>completeExceptionally()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">completableFuture.completeExceptionally(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Calculation failed!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">completableFuture.get(); <span class="comment">// ExecutionException</span></span><br></pre></td></tr></table></figure><p>上面这个示例的 <code>completableFuture.get()</code> 方法会抛出 <code>ExecutionException</code>，并使用<code>RuntimeException</code> 作为异常发生的原因。</p><p>在上面的例子中，我们也可以使用 <code>handle()</code> 方法异步处理异常，但使用 <code>get()</code> 方法是更典型的同步异常处理机制。</p><h2 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h2><p>CompletableFuture 类中的大多数流式 API 方法都又两个带有 <code>Async</code> 后缀的变体。这些变体方法通常用于在另一个线程中运行相应的执行步骤。</p><ul><li>没有 <code>Async</code> 后缀的方法使用当前调用线程运行下一个执行阶段。</li><li>不带 Executor 参数的 Async 后缀方法使用 <code>ForkJoinPool.commonPool()</code> 方法访问 Executor 的公共 fork/join 线程池实现运行一个步骤。</li><li>带有 Executor 参数的 Async 后缀方法使用传递的 Executor 运行一个步骤。</li></ul><p>下面这个范例中，我们使用了 Function 实例处理计算结果。和之前范例的唯一可见的区别就是 <code>thenApplyAsync()</code> 方法。但在幕后，函数的应用程序被包装到 ForkJoinTask 实例中（ 有关 fork/join 框架的更多信息，请阅读我们的 一文秒懂 Java Fork/Join ），这样可以进一步并行化我们的计算并更有效地使用系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture  </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class="line">  .thenApplyAsync(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello World&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><h2 id="Java-9-CompletableFuture-新增的-API"><a href="#Java-9-CompletableFuture-新增的-API" class="headerlink" title="Java 9 CompletableFuture 新增的 API"></a>Java 9 CompletableFuture 新增的 API</h2><p>Java 9 提供了一下变更进一步强化了 CompletableFuture：</p><ul><li>添加了新的工厂方法</li><li>支持延时和超时</li><li>改进了对子类化的支持</li></ul><p>Java 9 同时也引入了新的 CompletableFuture 实例 API</p><ul><li>Executor defaultExecutor()</li><li>CompletableFuture newIncompleteFuture()</li><li>CompletableFuture copy()CompletionStage minimalCompletionStage()</li><li>CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)C</li><li>ompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier)</li><li>CompletableFuture orTimeout(long timeout, TimeUnit unit)</li><li>CompletableFuture completeOnTimeout(T value, long timeout, TimeUnit unit)</li></ul><p>还添加了一些静态的使用方法</p><ul><li>Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)</li><li>Executor delayedExecutor(long delay, TimeUnit unit)</li><li>CompletionStage completedStage(U value)</li><li>CompletionStage failedStage(Throwable ex)</li><li>CompletableFuture failedFuture(Throwable ex)</li></ul><p>最后，为了解决超时问题，Java 9 引入了另外两个新功能</p><ul><li><code>orTimeout()</code></li><li><code>completeOnTimeout()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、Java并发 Java CompletableFuture</title>
      <link href="/posts/1e640cc2.html"/>
      <url>/posts/1e640cc2.html</url>
      
        <content type="html"><![CDATA[<h1 id="八、Java并发-Java-CompletableFuture-上"><a href="#八、Java并发-Java-CompletableFuture-上" class="headerlink" title="八、Java并发 Java CompletableFuture ( 上 )"></a>八、Java并发 Java CompletableFuture ( 上 )</h1><p>本文我们来了解下 Java 8 引入的 CompletableFuture 类，了解下该类提供的功能和用例。</p><h2 id="Java-中的异步计算"><a href="#Java-中的异步计算" class="headerlink" title="Java 中的异步计算"></a>Java 中的异步计算</h2><p>异步计算很难推理的，因为我们的大脑是同步的，会将任何计算看成是一系列的同步计算。</p><p>我们在实现异步计算时，往往会把回调的动作分散在代码中或者深深地嵌套在彼此内部，这种情况下，当我们需要处理其中一个步骤中可能发生的错误时，情况变得更糟。</p><p>人生的一大悲剧是，尽管 Java 5 已经看到了这种恶性循环，提供了<code>Future</code> 接口作为异步计算的结果，但它没有提供任何方法来组合这些计算或处理可能的错误。</p><p>直到 Java 8，才引入了 CompletableFuture 类。该类不仅实现了 <code>Future</code> 接口，还实现了 <code>CompletionStage</code> 接口。此接口定义了可与异步计算步骤组合的异步计算步骤契约。</p><p>官方文档真是拗口，简单来说，<code>CompletionStage</code> 接口规范了一个异步计算步骤如何与另一个异步计算步骤组合。</p><p>CompletableFuture 类还是一个集大成者，即是一个构建块，也是一个框架，提供了大约 50 种不同的方法来构造，组合，执行异步计算步骤和处理错误。</p><p>API 数量如此之多，第一眼看到简直就傻眼了，不过好在它们可以分门别类，因为它们大多属于几个明确且不同的用例。</p><h2 id="将-CompletableFuture-当作简单的-Future-使用"><a href="#将-CompletableFuture-当作简单的-Future-使用" class="headerlink" title="将 CompletableFuture 当作简单的 Future 使用"></a>将 CompletableFuture 当作简单的 Future 使用</h2><p>为什么可以 ？</p><p>因为 CompletableFuture 类实现了 Future 接口，因此我们可以将其用作 Future 实现，但需要自己实现额外的完成逻辑。</p><p>例如，我们可以使用无任何参数的构造函数来创建此类的实例，用于表示未来的某些结果，然后将其交给使用者，并在将来的某个时间调用 <code>complete()</code> 方法完成。消费者可以使用 <code>get()</code> 方法来阻止当前线程，直到提供此结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">calculateAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">      = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        completableFuture.complete(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例中，我们创建了一个创建 <code>CompletableFuture</code> 实例的方法，把计算分离到另一个线程中并立即返回 Future。当计算完成后，该方法通过将结果提供给 <code>complete()</code> 方法来完成 Future。</p><p>为了分离计算，我们使用了前几章节 一文秒懂 Java 线程池 ( Thread Pool ) （上） 中提到的 Executor API。这种创建和完成 CompletableFuture 的方法可以与任何并发机制或 API（ 包括原始线程 ）一起使用。</p><p>请注意，calculateAsync() 方法返回 Future 实例。</p><p>接下来，我们只要调用此方法，接收 Future 实例并在我们准备阻塞结果时调用它的 get() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = calculateAsync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> completableFuture.get();</span><br><span class="line">assertEquals(<span class="string">&quot;Hello&quot;</span>, result);</span><br></pre></td></tr></table></figure><p>注意: <code>get()</code> 方法会抛出一些已检查的异常，即 <code>ExecutionException</code>（ 封装计算期间发生的异常 ）和 <code>InterruptedException</code>（ 表示执行方法的线程被中断的异常 )。</p><p>如果你已经知道计算的结果，可以将表示此计算的结果作为参数传递给 <code>completedFuture()</code> 静态方法，这样，Future 的 get() 方法永远不会阻塞，而是立即返回此结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; completableFuture = </span><br><span class="line">  CompletableFuture.completedFuture(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> completableFuture.get();</span><br><span class="line">assertEquals(<span class="string">&quot;Hello&quot;</span>, result);</span><br></pre></td></tr></table></figure><p>当然了，有时候，你可能希望取消 Future 的执行。</p><p>假设我们没有找到结果并决定完全取消异步执行，这可以通过调用 Future 的 cancel() 方法完成。此方法接收一个布尔参数 <code>mayInterruptIfRunning</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">calculateAsyncWithCancellation</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Executors.newCachedThreadPool().submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        completableFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个异步方法的修改版本的范例中，当我们使用 <code>Future.get()</code> 方法阻塞结果时，如果 future 取消了，那么将抛出CancellationException 异常。</p><p>但是，在类型为 CompletableFuture 的情况下，cancel() 方法没有任何效果，因为 CompletableFuture 并不会响应中断也不会处理中断。</p><h2 id="用于封装计算逻辑的-CompletableFuture"><a href="#用于封装计算逻辑的-CompletableFuture" class="headerlink" title="用于封装计算逻辑的 CompletableFuture"></a>用于封装计算逻辑的 CompletableFuture</h2><p>上面讲解的这些代码，都允许我们选择任何并发执行机制，但是，如果我们想跳过这个样板代码并简单地异步执行一些代码呢？</p><p><code>CompletableFuture</code> 的静态方法 <code>runAsync()</code> 和 <code>supplyAsync()</code> 允许我们从 Runnable 和 Supplier 中创建 CompletableFuture 实例。 Runnable 和 Supplier 都是功能接口，由 Java 8 的新功能，可以将它们的实例作为lambda 表达式传递：</p><ul><li>Runnable 接口与线程中使用的旧接口相同，不允许返回值</li><li>Supplier 接口是一个通用的功能接口，只有一个没有参数的方法，并返回一个参数化类型的值</li></ul><p>下面的代码演示了如何将 Supplier 的实例作为 lambda 表达式参数，该表达式执行计算并返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><h2 id="处理异步计算的结果"><a href="#处理异步计算的结果" class="headerlink" title="处理异步计算的结果"></a>处理异步计算的结果</h2><p>处理计算结果的最通用方法是将其提供给函数。<code>CompletableFuture.thenApply()</code> 方法就是这样做的： <strong>接受一个 Function 实例，用它来处理结果并返回一个用于保存函数返回的值 Future</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = completableFuture</span><br><span class="line">  .thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;Hello World&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p>如果你不需要在 Future 链中返回值，则可以使用 Consumer 功能接口的实例。它只有一个方法，该方法接受一个参数并返回 void。而相应的，CompletableFuture 也提供了一个使用 Consumer 实例的方法 <code>thenAccept()</code> 。该方法接收一个 Consumer 并将其传递给计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class="line">  .thenAccept(s -&gt; System.out.println(<span class="string">&quot;Computation returned: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><p>上面这个示例中，最后的 <code>future.get()</code> 方法会返回空值 <code>Void</code> 。</p><p>最后，如果你既不需要计算的值也不想在链的末尾返回一些值，那么你可以将 <code>Runnable</code> lambda 传递给 <code>thenRun()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture </span><br><span class="line">  = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = completableFuture</span><br><span class="line">  .thenRun(() -&gt; System.out.println(<span class="string">&quot;计算完成&quot;</span>));</span><br><span class="line"></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><p>上面这个示例中，调用 <code>future.get()</code> 方法之后会在控制台打印一行 <code>计算完成</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、Java并发 Java Google Guava 实现</title>
      <link href="/posts/cb5d7b3f.html"/>
      <url>/posts/cb5d7b3f.html</url>
      
        <content type="html"><![CDATA[<h1 id="七、Java并发-Java-Google-Guava-实现"><a href="#七、Java并发-Java-Google-Guava-实现" class="headerlink" title="七、Java并发 Java Google Guava 实现"></a>七、Java并发 Java Google Guava 实现</h1><p><a href="https://github.com/google/guava">Guava</a> 是托管在 <a href="https://github.com/">Github.com</a> 上的流行的 Google 开源的 Java 线程池库。</p><p>Guava 包含了许多有用的并发类，同时还包含了几个方便的 <code>ExecutorService</code> 实现，但这些实现类都无法通过直接实例化或子类化来创建实例。取而代之的是提供了 MoreExecutors 助手类来创建它们的实例。</p><h2 id="给-Maven-添加-Guava-依赖"><a href="#给-Maven-添加-Guava-依赖" class="headerlink" title="给 Maven 添加 Guava 依赖"></a>给 Maven 添加 Guava 依赖</h2><p>为了将 Google Guava 库包含进当前的项目中，需要将下面的依赖项添加到 Maven pom 文件中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>26.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在 [Maven 中央仓库](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.guava&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.guava&quot;</a> AND a%3A”guava”) 中找到最新版本的 Guava 库</p><h2 id="直接执行者和直接执行者服务"><a href="#直接执行者和直接执行者服务" class="headerlink" title="直接执行者和直接执行者服务"></a>直接执行者和直接执行者服务</h2><p>有时候，我们希望在当前线程或线程池中执行任务，具体在哪里取决于某些条件。这种情况下，你应该会更喜欢使用单个 Executor 接口，且只需切换实现即可。</p><p>虽然将当前线程中的任务的 Executor 或 ExecutorService 的提取出来单独实现并不困难，但它仍然需要编写一些样板代码。</p><p>值得庆幸的是，Guava 为我们提供了预定义的实例。</p><p>下面的范例演示了如何在同一个线程中执行任务。简单起见，提交的任务会将当前线程休眠 500 毫秒并阻塞当前线程，并在执行的调用完成后让结果立即可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> MoreExecutors.directExecutor();</span><br><span class="line"></span><br><span class="line"><span class="type">AtomicBoolean</span> <span class="variable">executed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executed.set(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assertTrue(executed.get());</span><br></pre></td></tr></table></figure><p><code>directExecutor()</code> 方法返回的实例实际上是一个静态单例，因此使用此方法根本不会在对象创建上带来任何开销。</p><p>你应该更喜欢使用此方法来访问 <code>MoreExecutors.newDirectExecutorService()</code>，因为该 API 会在每次调用时创建完整的执行程序服务实现。</p><h2 id="退出-Executor-服务"><a href="#退出-Executor-服务" class="headerlink" title="退出 Executor 服务"></a>退出 Executor 服务</h2><p>另一个常见问题是： <strong>在线程池仍在运行其任务时关闭虚拟机</strong>。即使采用了取消机制，也无法保证任务执行良好，并在执行程序服务 （ Executor ）关闭时停止工作。这可能会导致 JVM 在任务继续工作时无限期挂起。</p><p>为了解决这个问题，Guava 引入了一系列已经实例化好的执行器 （ Executor ） 服务。它们是守护线程模式，但会与 JVM 一起终止。</p><p>这些执行器服务还提供了 <code>Runtime.getRuntime().addShutdownHook()</code> 方法用于添加一个关闭钩子，用于设置 VM 在放弃挂起的任务之前等待一段预配置的超时时间。</p><p>下面的示例中，我们提交了一个无限循环的任务，我们使用了包含 100 毫秒超时时间的已经存在的执行程序服务来运行任务，并在超过配置的超时时间之后终止 VM 。如果没有 exitingExecutorService ，此任务将导致 VM 无限期挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> </span><br><span class="line">  (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> </span><br><span class="line">  MoreExecutors.getExitingExecutorService(executor, </span><br><span class="line">    <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="监听装饰器"><a href="#监听装饰器" class="headerlink" title="监听装饰器"></a>监听装饰器</h2><p>监听装饰器允许我们封装 ExecutorService 并在提交任务时返回 ListenableFuture 实例而不是简简单单的 Future 实例。</p><p>ListenableFuture 接口扩展自 Future 接口，并添加了一个新方法 <code>addListener()</code>，该方法用于添加在将来完成时调用的侦听器。</p><p>一般情况下，我们很少直接使用 <code>ListenableFuture.addListener()</code> 方法，而是使用 Futures 类提供的许多辅助方法。例如，通过<code>Futures.allAsList()</code> 方法，我们可以在单个 ListenableFuture 中组合多个 ListenableFuture 实例，并会在这些实例在成功完成后将所有的 futures 合并并返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">listeningExecutorService</span> <span class="operator">=</span> </span><br><span class="line">  MoreExecutors.listeningDecorator(executorService);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;String&gt; future1 = </span><br><span class="line">  listeningExecutorService.submit(() -&gt; <span class="string">&quot;java&quot;</span>);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = </span><br><span class="line">  listeningExecutorService.submit(() -&gt; <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> Futures.allAsList(future1, future2).get()</span><br><span class="line">  .stream()</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot;&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;云遇未晚&quot;</span>, greeting);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
            <tag> Guava </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、Java并发 Java ForkJoinPool</title>
      <link href="/posts/b57a6e2b.html"/>
      <url>/posts/b57a6e2b.html</url>
      
        <content type="html"><![CDATA[<h1 id="六、Java并发-Java-ForkJoinPool"><a href="#六、Java并发-Java-ForkJoinPool" class="headerlink" title="六、Java并发 Java ForkJoinPool"></a>六、Java并发 Java ForkJoinPool</h1><p>ForkJoinPool 是Java 7 中引入的 fork/join 框架的核心之一。它解决了一个常见的问题： 如何在递归中生成多个任务。因为，即使是使用一个简单的 <code>ThreadPoolExecutor</code> ，也会在不断的递归中快速耗尽线程。因为每个任务或子任务都需要自己的线程来运行。</p><p>在 fork/join 框架中，任何任务都可以生成 ( fork ) 多个子任务并使用 <code>join()</code> 方法等待它们的完成。fork/join 框架的好处是它不会为每个任务或子任务创建新线程，而是实现了 <strong>工作窃取</strong> ( Work Stealing ) 算法。关于 fork/join 框架的详细信息，你可以访问我们的 一文秒懂 Java Fork/Join。</p><p>接下来，我们看一个使用 <code>ForkJoinPool</code> 遍历节点树并计算所有叶值之和的简单示例。在这个示例中，树是一个由节点，int 值和一组子节点组成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Set&lt;TreeNode&gt; children;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> value, TreeNode... children) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.children = Sets.newHashSet(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了树 <code>TreeNode</code> 之后，如果我们想要并行地对树中的所有值求和，我们需要实现一个 <code>RecursiveTask&lt;Integer&gt;</code> 接口。每个任务都接收自己的节点，并将其值添加到其子节点的值之和上。</p><p>要计算子节点值的总和，任务实现执行以下操作</p><p>1、 将子节点集合转换为流 ( stream )<br>2、 映射前面操作中创建的流，为每个元素创建一个新的 CountingTask<br>3、 通过 <code>fork</code> 执行每个子任务<br>4、 通过在每个 <code>fork</code> 任务上调用 <code>join()</code> 方法来收集结果<br>5、 使用 ·Collectors.summingInt` 收集器对结果求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CountingTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountingTask</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.value + node.children.stream()</span><br><span class="line">          .map(childNode -&gt; <span class="keyword">new</span> <span class="title class_">CountingTask</span>(childNode).fork())</span><br><span class="line">          .collect(Collectors.summingInt(ForkJoinTask::join));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在树上运行计算的代码非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> forkJoinPool.invoke(<span class="keyword">new</span> <span class="title class_">CountingTask</span>(tree));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
            <tag> forkJoinPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、Java并发 ScheduledThreadPoolExecutor</title>
      <link href="/posts/5975178e.html"/>
      <url>/posts/5975178e.html</url>
      
        <content type="html"><![CDATA[<h1 id="五、Java并发-ScheduledThreadPoolExecutor"><a href="#五、Java并发-ScheduledThreadPoolExecutor" class="headerlink" title="五、Java并发 ScheduledThreadPoolExecutor"></a>五、Java并发 ScheduledThreadPoolExecutor</h1><p><code>ScheduledThreadPoolExecutor</code> 扩展自 一文秒懂 Java 线程池之 ThreadPoolExecutor 讲解的 <code>了ThreadPoolExecutor</code> 类，并且添加了其它方法实现了 <code>ScheduledExecutorService</code> 接口。</p><ul><li><code>schedule()</code> 方法允许在指定的延迟后执行一次任务</li><li><code>scheduleAtFixedRate()</code> 方法允许在指定的初始延迟后执行任务，然后以一定的周期重复执行，其中 <code>period</code> 参数用于指定两个任务的开始时间之间的间隔时间，因此任务执行的频率是固定的。</li><li><code>scheduleWithFixedDelay()</code> 方法类似于 <code>scheduleAtFixedRate()</code> ，它也重复执行给定的任务，但<code>period</code> 参数用于指定前一个任务的结束和下一个任务的开始之间的间隔时间。也就是指定下一个任务延时多久后才执行。执行频率可能会有所不同，具体取决于执行任何给定任务所需的时间。</li></ul><p>静态方法 <code>Executors.newScheduledThreadPool()</code> 方法用于创建包含了指定 <code>corePoolSize</code>，无上限 <code>maximumPoolSize</code> 和 <code>0</code> 存活时间 <code>keepAliveTime</code> 的 <code>ScheduledThreadPoolExecutor</code> 实例。</p><p>例如下面的示例创建了一个包含了 5 个核心线程的 <code>ScheduledThreadPoolExecutor</code> 实例，且每隔 500 毫秒运行一个输出 <code>Hello World</code> 的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h2 id="范例-2"><a href="#范例-2" class="headerlink" title="范例 2"></a>范例 2</h2><p>下面的代码则演示了如何在 500 毫秒延迟后执行任务，然后每 100 毫秒重复执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    lock.countDown();</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">lock.await(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、Java并发 Java 线程池之 ThreadPoolExecutor</title>
      <link href="/posts/f6cd6d86.html"/>
      <url>/posts/f6cd6d86.html</url>
      
        <content type="html"><![CDATA[<h1 id="四、Java并发-Java-线程池之-ThreadPoolExecutor"><a href="#四、Java并发-Java-线程池之-ThreadPoolExecutor" class="headerlink" title="四、Java并发 Java 线程池之 ThreadPoolExecutor"></a>四、Java并发 Java 线程池之 ThreadPoolExecutor</h1><p>因为上一章节篇幅有限，所以我决定把 <strong>一文秒懂 Java 线程池</strong> 拆分为三篇文章单独介绍。本章节，我们就来看看 <code>ThreadPoolExecutor</code> 。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code> 是一个可被继承 ( extends ) 的线程池实现，包含了用于微调的许多参数和钩子。</p><p>我们并不会讨论 ThreadPoolExecutor 类中的所有的参数和钩子，只会讨论几个主要的配置参数：</p><ol><li> `corePoolSize``</li><li>``maximumPoolSize`</li><li> <code>keepAliveTime</code></li></ol><p>ThreadPoolExecutor 创建的线程池由固定数量的核心线程组成，这些线程在 ThreadPoolExecutor 生命周期内始终存在，除此之外还有一些额外的线程可能会被创建，并会在不需要时主动销毁。<code>corePoolSize</code> 参数用于指定在线程池中实例化并保留的核心线程数。如果所有核心线程都忙，并且提交了更多任务，则允许线程池增长到 <code>maximumPoolSize</code> 。</p><p><code>keepAliveTime</code> 参数是额外的线程（ 即，实例化超过 corePoolSize 的线程 ）在空闲状态下的存活时间。</p><p>这三个参数涵盖了广泛的使用场景，但最典型的配置是在 Executors 静态方法中预定义的。</p><h3 id="Executors-newFixedThreadPool"><a href="#Executors-newFixedThreadPool" class="headerlink" title="Executors.newFixedThreadPool()"></a>Executors.newFixedThreadPool()</h3><p>例如，<code>Executors.newFixedThreadPool()</code> 静态方法创建了一个 <code>ThreadPoolExecutor</code> ，它的参数 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都是相等的，且参数 <code>keepAliveTime</code> 始终为 <code>0</code> ，也就意味着此线程池中的线程数始终相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> </span><br><span class="line">  (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">2</span>, executor.getPoolSize());</span><br><span class="line">assertEquals(<span class="number">1</span>, executor.getQueue().size());</span><br></pre></td></tr></table></figure><p>上面这个示例中，我们实例化了一个固定线程数为 <code>2</code> 的 <code>ThreadPoolExecutor</code>。这意味着如果同时运行的任务的数量始终小于或等于 2 ，那么这些任务会立即执行。否则，其中一些任务可能会被放入队列中等待轮到它们。</p><p>上面这个示例中，我们创建了三个 <code>Callable</code> 任务，通过睡眠模拟 1000 毫秒的繁重工作。前两个任务将立即执行，第三个任务必须在队列中等待。我们可以通过在提交任务后立即调用 <code>getPoolSize()</code> 和 <code>getQueue().size()</code> 来方法来验证。</p><h3 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h3><p><code>Executors</code> 还提供了 <code>Executors.newCachedThreadPool()</code> 静态方法创建另一个预配置的 <code>ThreadPoolExecutor</code>。该方法创建的线程池没有任何核心线程，因为它将 <code>corePoolSize</code> 属性设置为 <code>0</code>，但同时有可以创建最大数量的额外线程，因为它将 <code>maximumPoolSize</code> 设置为 <code>Integer.MAX_VALUE</code> ，且将 <code>keepAliveTime</code> 的值设置为 <code>60</code> 秒。</p><p>这些参数值意味着缓存的线程池可以无限制地增长以容纳任何数量的已提交任务。但是，当不再需要线程时，它们将在 60秒不活动后被销毁。这种线程池的使用场景一般是你的应用程序中有很多短期任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> </span><br><span class="line">  (ThreadPoolExecutor) Executors.newCachedThreadPool();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">3</span>, executor.getPoolSize());</span><br><span class="line">assertEquals(<span class="number">0</span>, executor.getQueue().size());</span><br></pre></td></tr></table></figure><p>上面这个示例中的队列大小始终为 <code>0</code> ，因为在内部使用了 <code>SynchronousQueue</code> 的实例。在 <code>SynchronousQueue</code> 中，插入和删除操作总是成对出现且同时发生。因此队列实际上从不包含任何内容。</p><h3 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h3><p><code>Executors.newSingleThreadExecutor()</code> 静态方法则创建另一种典型的只包含单个线程的 <code>ThreadPoolExecutor</code> 实例。</p><p>这种单线程执行程序是创建事件循环的理想选择。</p><p>在这个单线程 <code>ThreadPoolExecutor</code> 实例中，属性 <code>corePoolSize</code> 和属性 <code>maximumPoolSize</code> 的值都为 <code>1</code>，而属性 <code>keepAliveTime</code> 的值为 <code>0</code> 。</p><p>在单线程 <code>ThreadPoolExecutor</code> 实例中，所有的任务都按顺序执行。因此，下面的示例中，任务完成后标志的值是 <code>2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.set(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此外，单线程 <code>ThreadPoolExecutor</code> 实例使用了不可变包装器进行修饰，因此在创建后无法重新配置。当然了，这也是我们无法将该示例强制转换为 <code>ThreadPoolExecutor</code> 的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、Java并发 Java 线程池 ( Thread Pool )</title>
      <link href="/posts/bd483eb7.html"/>
      <url>/posts/bd483eb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="三、Java并发-Java-线程池-Thread-Pool"><a href="#三、Java并发-Java-线程池-Thread-Pool" class="headerlink" title="三、Java并发 Java 线程池 ( Thread Pool )"></a>三、Java并发 Java 线程池 ( Thread Pool )</h1><p>本文我们将讲解 Java 中的线程池 ( Thread Pool )，从 Java 标准库中的线程池的不同实现开始，到 Google 开发的 Guava 库的前世今生。</p><blockquote><p>本章节涉及到很多前几个章节中阐述的知识点。我们希望你是按照顺序阅读下来的，不然有些知识会一头雾水。</p></blockquote><p>Java 语言的实现中，把 Java 线程一一映射到操作系统级的线程，而后者是操作系统的资源，这意味着，如果开发者毫无节制地创建线程，那么线程资源就会被快速的耗尽。</p><blockquote><p>在 Windows 操作系统上，每个线程要预留出 1m 的内存空间，意味着 2G 的内存理论上做多只能创建 2048 个线程。而在 Linux 上，最大线程数由常量 <code>PTHREAD_THREADS_MAX</code> 决定，一般为 1024。</p></blockquote><p>出于模拟并行性的目的，Java 线程之间的上下文切换也由操作系统完成。因为线程上下文切换需要消耗时间，所以，一个简单的观点是：产生的线程越多，每个线程花在实际工作上的时间就越少。</p><blockquote><p>为什么会有线程上下文切换？</p><p>一台电脑，运行起来后，它的 CPU 是固定的，05 年之前，还是单核时代，也就是一次只能运行一个线程，虽然随着时间的推移，现在的 CPU 已经有很多个核心，比如 8 核 16 核之类的。但相比于一个应用程序能够创建的线程数，那真的是太少了。而每个核心一次只能运行一个线程，所以多个线程需要运行时就需要来回不停的在多个线程间切换，这就是线程之间的上下文切换。</p></blockquote><p>为了节制创建线程的数量，也为了节省创建线程的开销，因此提出了线程池的概念。线程池模式有助于节省多线程应用程序中的资源，还可以在某些预定义的限制内包含并行性。</p><p>当我们使用线程池时，我们可以以并行任务的形式编写并发代码并将其提交到线程池的实例中执行。</p><p>这个线程池实例控制了多个重用线程以执行这些任务。</p><p><img src="https://s3.uuu.ovh/imgs/2022/05/04/4e8bcdf1df3e7006.png" alt="img_1.png"></p><p>这种线程池模式，允许我们控制应用程序创建的线程数，生命周期，以及计划任务的执行并将传入的任务保留在队列中。</p><h2 id="Java-中的线程池"><a href="#Java-中的线程池" class="headerlink" title="Java 中的线程池"></a>Java 中的线程池</h2><h3 id="Executors、Executor-和-ExecutorService"><a href="#Executors、Executor-和-ExecutorService" class="headerlink" title="Executors、Executor 和 ExecutorService"></a>Executors、Executor 和 ExecutorService</h3><p><code>Executors</code> 是一个帮助类，提供了创建几种预配置线程池实例的方法。如果你不需要应用任何自定义的微调，可以调用这些方法创建默认配置的线程池，因为它能节省很多时间和代码。</p><p><code>Executor</code> 和 <code>ExecutorService</code> 接口则用于与 Java 中不同线程池的实现协同工作。通常，你应该将代码与线程池的实际实现分离，并在整个应用程序中使用这些接口。</p><p>Executor 接口提供了一个 <code>execute()</code> 方法将 Runnable 实例提交到线程池中执行。</p><p>下面的代码是一个快速示例，演示了如何使用 Executors API 获取包含了单个线程池和无限队列支持的 Executor 实例，以便按顺序执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>获取了 <code>Executor</code> 示例后，我们就可以使用 <code>execute()</code> 方法将一个只在屏幕上打印 <code>Hello World</code> 的任务提交到队列中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>));</span><br></pre></td></tr></table></figure><p>上面这个示例使用了 lambda （ Java 8特性 ）提交任务，JVM 会自动推断该任务为 <code>Runnable</code></p><p>我们在 Java Shell 演示下上面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; <span class="keyword">import</span> java.util.concurrent.*</span><br><span class="line"></span><br><span class="line">jshell&gt; <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor ==&gt; java.util.concurrent.Executors$FinalizableDelegatedExecutorService@<span class="number">1e127982</span></span><br><span class="line"></span><br><span class="line">jshell&gt; executor.execute(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"></span><br><span class="line">jshell&gt; Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jshell&gt; </span><br></pre></td></tr></table></figure><p><code>ExecutorService</code> 接口则包含大量用于控制任务进度和管理服务终止的方法。我们可以使用此接口来提交要执行的任务，还可以使用此接口返回的 Future 实例控制任务的执行。</p><p>下面的示例中，我们创建了一个 ExecutorService 的实例，提交了一个任务，然后使用返回的 Future 的 get() 方法等待提交的任务完成并返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(() -&gt; <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="comment">// 一些其它操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br></pre></td></tr></table></figure><p>在实际使用时，我们并不会立即调用 <code>future.get()</code> 方法，可能会等待一些时间，推迟调用它直到我们需要它的值用于计算等目的。</p><p><code>ExecutorService</code> 中的 <code>submit()</code> 方法被重载为支持 <code>Runnable</code> 或 <code>Callable</code> ，它们都是功能接口，可以接收一个 lambdas 作为参数（ 从 Java 8 开始 ）：</p><ul><li>使用 Runnable 作为参数的方法不会抛出异常也不会返回任何值 ( 返回 <code>void</code> )</li><li>使用 Callable 作为参数的方法则可以抛出异常也可以返回值。</li></ul><p>如果想让编译器将参数推断为 Callable 类型，只需要 lambda 返回一个值即可。</p><p><code>ExecutorService</code> 接口的更多使用范例和特性，你可以访问前面的章节 一文秒懂 Java ExecutorService。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Java并发 Java Fork-Join</title>
      <link href="/posts/4a515c30.html"/>
      <url>/posts/4a515c30.html</url>
      
        <content type="html"><![CDATA[<h1 id="二、Java并发-Java-Fork-Join"><a href="#二、Java并发-Java-Fork-Join" class="headerlink" title="二、Java并发 Java Fork-Join"></a>二、Java并发 Java Fork-Join</h1><p>fork/join 框架是 Java 7 中引入的 ，它是一个工具，通过 「 分而治之 」 的方法尝试将所有可用的处理器内核使用起来帮助加速并行处理。</p><p>在实际使用过程中，这种 「 分而治之 」的方法意味着框架首先要 <code>fork</code> ，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。然后，<code>join</code> 部分开始工作，将所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待每个子任务执行完毕。</p><p>为了提供有效的并行执行，fork/join 框架使用了一个名为 <code>ForkJoinPool</code> 的线程池，用于管理 <code>ForkJoinWorkerThread</code> 类型的工作线程。</p><h2 id="ForkJoinPool-线程池"><a href="#ForkJoinPool-线程池" class="headerlink" title="ForkJoinPool 线程池"></a>ForkJoinPool 线程池</h2><p><code>ForkJoinPool</code> 是 fork/join 框架的核心，是 ExecutorService 的一个实现，用于管理工作线程，并提供了一些工具来帮助获取有关线程池状态和性能的信息。</p><p>工作线程一次只能执行一个任务。</p><p><code>ForkJoinPool</code> 线程池并不会为每个子任务创建一个单独的线程，相反，池中的每个线程都有自己的双端队列用于存储任务 （ double-ended queue ）( 或 deque，发音 <code>deck</code> ）。</p><p>这种架构使用了一种名为工作窃取（ work-stealing ）算法来平衡线程的工作负载。</p><h3 id="工作窃取（-work-stealing-）算法"><a href="#工作窃取（-work-stealing-）算法" class="headerlink" title="工作窃取（ work-stealing ）算法"></a>工作窃取（ work-stealing ）算法</h3><p>要怎么解释 「 工作窃取算法 」 呢 ？</p><p>简单来说，就是 <strong>空闲的线程试图从繁忙线程的 deques 中 *窃取* 工作</strong>。</p><p>默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方。</p><p>这种方法最大限度地减少了线程竞争任务的可能性。它还减少了工作线程寻找任务的次数，因为它首先在最大可用的工作块上工作。</p><h3 id="ForkJoinPool-线程池的实例化"><a href="#ForkJoinPool-线程池的实例化" class="headerlink" title="ForkJoinPool 线程池的实例化"></a>ForkJoinPool 线程池的实例化</h3><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h4><p>在 Java 8 中，创建 ForkJoinPool 实例的最简单的方式就是使用其静态方法 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--">commonPool()</a>。</p><p><code>commonPool()</code> 静态方法，见名思义，就是提供了对公共池的引用，公共池是每个 ForkJoinTask 的默认线程池。</p><p>根据 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">Oracle 的官方文档</a>，使用预定义的公共池可以减少资源消耗，因为它会阻止每个任务创建一个单独的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">commonPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br></pre></td></tr></table></figure><h4 id="Java-7"><a href="#Java-7" class="headerlink" title="Java 7"></a>Java 7</h4><p>如果要在 Java 7 中实现相同的行为，则需要通过创建 ForkJoinPool 的实例并将其赋值给实用程序类的公共静态字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>使用构造函数实例化 ForkJoinPool 时，可以创建具有指定级别的并行性，线程工厂和异常处理程序的自定义线程池。在上面的示例中，线程池的并行度级别为 2 ，意味着线程池将使用 2 个处理器核心。</p><p>然后就可以通过这个公共静态字段轻松的访问 ForkJoinPool 的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> PoolUtil.forkJoinPool;</span><br></pre></td></tr></table></figure><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p><code>ForkJoinTask</code> 是 <code>ForkJoinPool</code> 线程之中执行的任务的基本类型。我们日常使用时，一般不直接使用 <code>ForkJoinTask</code> ，而是扩展它的两个子类中的任意一个</p><p>1、任务不返回结果 ( 返回 <code>void</code> ） 的 <code>RecursiveAction</code><br>2、返回值的任务的 <code>RecursiveTask &lt;V&gt;</code></p><p>这两个类都有一个抽象方法 <code>compute()</code> ，用于定义任务的逻辑。</p><p>我们所要做的，就是继承任意一个类，然后实现 <code>compute()</code> 方法。</p><h3 id="RecursiveAction-使用示例"><a href="#RecursiveAction-使用示例" class="headerlink" title="RecursiveAction 使用示例"></a>RecursiveAction 使用示例</h3><p>出于演示目的，示例当然是尽可能的简单，因此，我们的示例，执行了一个比较荒谬的任务：将输入转为大写并记录。</p><p>所有的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRecursiveAction</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">workload</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> </span><br><span class="line">      Logger.getAnonymousLogger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRecursiveAction</span><span class="params">(String workload)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workload = workload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workload.length() &gt; THRESHOLD) &#123;</span><br><span class="line">            ForkJoinTask.invokeAll(createSubtasks());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           processing(workload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;CustomRecursiveAction&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CustomRecursiveAction&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">partOne</span> <span class="operator">=</span> workload.substring(<span class="number">0</span>, workload.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">partTwo</span> <span class="operator">=</span> workload.substring(workload.length() / <span class="number">2</span>, workload.length());</span><br><span class="line"></span><br><span class="line">        subtasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveAction</span>(partOne));</span><br><span class="line">        subtasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveAction</span>(partTwo));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subtasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processing</span><span class="params">(String work)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> work.toUpperCase();</span><br><span class="line">        logger.info(<span class="string">&quot;This result - (&quot;</span> + result + <span class="string">&quot;) - was processed by &quot;</span></span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了一个字符串类型 ( String ) 的名为 <code>workload</code> 属性来表示要处理的工作单元。</p><p>同时，为了演示 fork/join 框架的 fork 行为，在该示例中，如果 <code>workload.length()</code> 大于指定的阈值，那么就使用 <code>createSubtask()</code> 方法拆分任务。</p><p>在 <code>createSubtasks()</code> 方法中，输入的字符串被递归地划分为子串，然后创建基于这些子串的 <code>CustomRecursiveTask</code> 实例。</p><p>当递归分割字符串完毕时，<code>createSubtasks()</code> 方法返回 <code>List&lt;CustomRecursiveAction&gt;</code> 作为结果。</p><p>然后在 <code>compute()</code> 方法中使用 <code>invokeAll()</code> 方法将任务列表提交给 <code>ForkJoinPool</code> 线程池。</p><p>我们来总结下创建 RecursiveAction 的步骤：</p><p>1、创建一个表示工作总量的对象<br>2、选择合适的阈值<br>3、定义分割工作的方法<br>4、定义执行工作的方法</p><p>类似的，我们可以使用相同的方式开发自己的 <code>RecursiveAction</code> 类。</p><h2 id="RecursiveTask-使用示例"><a href="#RecursiveTask-使用示例" class="headerlink" title="RecursiveTask 使用示例"></a>RecursiveTask 使用示例</h2><p>对于有返回值的任务，除了将每个子任务的结果在一个结果中合并，其它逻辑和 <code>RecursiveAction</code> 都差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRecursiveTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRecursiveTask</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> ForkJoinTask.invokeAll(createSubtasks())</span><br><span class="line">              .stream()</span><br><span class="line">              .mapToInt(ForkJoinTask::join)</span><br><span class="line">              .sum();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> processing(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;CustomRecursiveTask&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CustomRecursiveTask&gt; dividedTasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveTask</span>(</span><br><span class="line">          Arrays.copyOfRange(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>)));</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveTask</span>(</span><br><span class="line">          Arrays.copyOfRange(arr, arr.length / <span class="number">2</span>, arr.length)));</span><br><span class="line">        <span class="keyword">return</span> dividedTasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">processing</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(arr)</span><br><span class="line">          .filter(a -&gt; a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">27</span>)</span><br><span class="line">          .map(a -&gt; a * <span class="number">10</span>)</span><br><span class="line">          .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个示例中，任务由存储在 <code>CustomRecursiveTask</code> 类的 <code>arr</code> 字段中的数组表示。</p><p><code>createSubtask()</code> 方法递归地将任务划分为较小的工作，直到每个部分小于阈值。然后，<code>invokeAll()</code>方法将子任务提交给公共拉取并返回 Future 列表。</p><p>要触发执行，需要为每个子任务调用 <code>join()</code> 方法。</p><p>上面这个示例中，我们使用了 Java 8 的流 ( Stream ) API ， <code>sum()</code> 方法用于将子结果组合到最终结果中。</p><h2 id="将任务提交到-ForkJoinPool-线程池中"><a href="#将任务提交到-ForkJoinPool-线程池中" class="headerlink" title="将任务提交到 ForkJoinPool 线程池中"></a>将任务提交到 ForkJoinPool 线程池中</h2><p>只要使用很少的方法，就可以把任务提交到 ForkJoinPool 线程池中。</p><p>1、<code>submit()</code> 或 <code>execute()</code> 方法</p><p>这两个方法的调用方式是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forkJoinPool.execute(customRecursiveTask);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> customRecursiveTask.join();</span><br></pre></td></tr></table></figure><p>2、使用 <code>invoke()</code> 方法 <code>fork</code> 任务并等待结果，不需要任何手动连接 ( join )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.invoke(customRecursiveTask);</span><br></pre></td></tr></table></figure><p>3、<code>invokeAll()</code> 方法是将 ForkJoinTasks 序列提交给 ForkJoinPool 的最方便的方法。它将任务作为参数 ( 两个任务，var args 或集合 ），<code>fork</code> 它们，并按照生成它们的顺序返回 Future 对象的集合。<br>4、或者，我们还可以使用单独的 <code>fork()</code> 和 <code>join()</code> 方法。</p><ul><li><code>fork()</code> 方法将任务提交给线程池，但不会触发任务的执行。</li><li><code>join()</code> 方法则用于触发任务的执行。在 <code>RecursiveAction</code> 的情况下，join() 返回 null，但对于 <code>RecursiveTask&lt;V&gt;</code> ，它返回任务执行的结果。</li></ul><p>customRecursiveTaskFirst.fork(); result = customRecursiveTaskLast.join();</p><p>上面的 <code>RecursiveTask&lt;V&gt;</code> 示例中，我们使用 <code>invokeAll()</code> 方法向线程池提交一系列子任务。同样的工作，也可以使用 <code>fork()</code> 和 <code>join()</code> 来完成，但这可能会对结果的排序产生影响。</p><p>为了避免混淆，当涉及到多个任务且要保证任务的顺序时，通常都是使用 <code>ForkJoinPool.invokeAll()</code> 。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>使用 fork/join 框架可以加速处理大型任务，但要实现这一结果，应遵循一些指导原则：</p><ul><li>使用尽可能少的线程池。绝大多数情况下，最好的决定是每个应用程序或系统只使用一个线程池。 (是线程池而不是线程)。</li><li>当不需要任何调整时，使用默认的公共线程池。</li><li>使用合理的阈值。将 ForkJoingTask 任务拆分为子任务。</li><li>避免在 ForkJoingTasks 中出现任何阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Thread pool </tag>
            
            <tag> Thread </tag>
            
            <tag> 工具 </tag>
            
            <tag> forkJoinPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Java并发 Java ExecutorService</title>
      <link href="/posts/d5817b6f.html"/>
      <url>/posts/d5817b6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java并发-Java-ExecutorService"><a href="#一、Java并发-Java-ExecutorService" class="headerlink" title="一、Java并发 Java ExecutorService"></a>一、Java并发 Java ExecutorService</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> 是 Java <code>java.util.concurrent</code> 包的重要组成部分，是 Java JDK 提供的框架，用于简化异步模式下任务的执行。</p><p>一般来说，ExecutorService 会自动提供一个线程池和相关 API，用于为其分配任务。</p><h2 id="实例化-ExecutorService"><a href="#实例化-ExecutorService" class="headerlink" title="实例化 ExecutorService"></a>实例化 ExecutorService</h2><p>实例化 ExecutorService 的方式有两种：一种是工厂方法，另一种是直接创建。</p><h3 id="Executors-newFixedThreadPool-工厂方法创建-ExecutorService-实例"><a href="#Executors-newFixedThreadPool-工厂方法创建-ExecutorService-实例" class="headerlink" title="Executors.newFixedThreadPool() 工厂方法创建 ExecutorService 实例"></a><code>Executors.newFixedThreadPool()</code> 工厂方法创建 ExecutorService 实例</h3><p>创建 ExecutorService 实例的最简单方法是使用 <code>Executors</code> 类的提供的工厂方法。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当然还有其它很多工厂方法，每种工厂方法都可以创建满足特定用例的预定义 ExecutorService 实例。你所需要做的就是找到自己想要的合适的方法。这些方法都在 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">Oracle 的 JDK 官方文档中有列出</a></p><h3 id="直接创建-ExecutorService-的实例"><a href="#直接创建-ExecutorService-的实例" class="headerlink" title="直接创建 ExecutorService 的实例"></a>直接创建 ExecutorService 的实例</h3><p>因为 <code>ExecutorService</code> 是只是一个接口，因此可以使用其任何实现类的实例。Java <code>java.util.concurrent</code> 包已经预定义了几种实现可供我们选择，或者你也可以创建自己的实现。</p><p>例如，<code>ThreadPoolExecutor</code> 类实现了 <code>ExecutorService</code> 接口并提供了一些构造函数用于配置执行程序服务及其内部池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,   </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>你可能会注意到，上面的代码与工厂方法 <code>newSingleThreadExecutor()</code> 的 源代码 非常相似。对于大多数情况，不需要详细的手动配置。</p><h2 id="将任务分配给-ExecutorService"><a href="#将任务分配给-ExecutorService" class="headerlink" title="将任务分配给 ExecutorService"></a>将任务分配给 ExecutorService</h2><p><code>ExecutorService</code> 可以执行 <code>Runnable</code> 和 <code>Callable</code> 任务。为了使本文简单易懂。我们将使用两个两个原始任务，如下面的代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnableTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Callable&lt;String&gt; callableTask = () -&gt; &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task&#x27;s execution&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; callableTasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">callableTasks.add(callableTask);</span><br><span class="line">callableTasks.add(callableTask);</span><br><span class="line">callableTasks.add(callableTask);</span><br></pre></td></tr></table></figure><blockquote><p>注意: 上面的代码使用了 lambda 表达式而不是匿名内部类。</p></blockquote><p>创建完了任务之后，就可以使用多种方法将任务分配给 ExecutorService ，比如 <code>execute()</code> 方法，还有 <code>submit()</code>、<code>invokeAny()</code> 和 <code>invokeAll()</code> 等方法。这些方法都继承自 <code>Executor</code> 接口。</p><p>1、首先来看看 <code>execute()</code> 方法。</p><p>该方法返回值为空 ( <code>void</code> )。因此使用该方法没有任何可能获得任务执行结果或检查任务的状态（ 是正在运行 ( running ) 还是执行完毕 ( executed ) ）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(runnableTask);</span><br></pre></td></tr></table></figure><p>2、其次看看 <code>submit()</code> 方法。</p><p><code>submit()</code> 方法会将一个 <code>Callable</code> 或 <code>Runnable</code> 任务提交给 <code>ExecutorService</code> 并返回 <code>Future</code> 类型的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executorService.submit(callableTask);</span><br></pre></td></tr></table></figure><p>3、然后是 <code>invokeAny()</code> 方法。</p><p><code>invokeAny()</code> 方法将一组任务分配给 ExecutorService，使每个任务执行，并返回任意一个成功执行的任务的结果 ( 如果成功执行 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> executorService.invokeAny(callableTasks);</span><br></pre></td></tr></table></figure><p>4、最后是 <code>invokeAll()</code> 方法。</p><p><code>invokeAll()</code> 方法将一组任务分配给 ExecutorService ，使每个任务执行，并以 Future 类型的对象列表的形式返回所有任务执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableTasks);</span><br></pre></td></tr></table></figure><p>在继续深入理解 ExecutorService 之前，我们必须先讲解下另外两件事：关闭 ExecutorService 和处理 Future 返回类型。</p><h2 id="关闭-ExecutorService"><a href="#关闭-ExecutorService" class="headerlink" title="关闭 ExecutorService"></a>关闭 ExecutorService</h2><p>一般情况下，ExecutorService 并不会自动关闭，即使所有任务都执行完毕，或者没有要处理的任务，也不会自动销毁 ExecutorService 。它会一直出于等待状态，等待我们给它分配新的工作。</p><p>这种机制，在某些情况下是非常有用的，比如，，如果应用程序需要处理不定期出现的任务，或者在编译时不知道这些任务的数量。</p><p>但另一方面，这也带来了副作用：即使应用程序可能已经到达它的终点，但并不会被停止，因为等待的 ExecutorService 将导致 JVM 继续运行。这样，我们就需要主动关闭 ExecutorService。</p><p>要正确的关闭 ExecutorService，可以调用实例的 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法。</p><p>1、<code>shutdown()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p><code>shutdown()</code> 方法并不会立即销毁 ExecutorService 实例，而是首先让 ExecutorService 停止接受新任务，并在所有正在运行的线程完成当前工作后关闭。<br>2、<code>shutdownNow()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Runnable&gt; notExecutedTasks = executorService.shutDownNow();</span><br></pre></td></tr></table></figure><p><code>shutdownNow()</code> 方法会尝试立即销毁 ExecutorService 实例，所以并不能保证所有正在运行的线程将同时停止。该方法会返回等待处理的任务列表，由开发人员自行决定如何处理这些任务。</p><p>因为提供了两个方法，因此关闭 ExecutorService 实例的最佳实战 （ 也是 Oracle 所推荐的 ）就是同时使用这两种方法并结合 <code>awaitTermination()</code> 方法。</p><p>使用这种方式，ExecutorService 首先停止执行新任务，等待指定的时间段完成所有任务。如果该时间到期，则立即停止执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!executorService.awaitTermination(<span class="number">800</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h2><p><code>submit()</code> 方法和 <code>invokeAll()</code> 方法返回一个 Future 接口的对象或 Future 类型的对象集合。这些 Future 接口的对象允许我们获取任务执行的结果或检查任务的状态 ( 是正在运行还是执行完毕 ）。</p><h3 id="Future-接口-get-方法"><a href="#Future-接口-get-方法" class="headerlink" title="Future 接口 get() 方法"></a>Future 接口 get() 方法</h3><p>Future 接口提供了一个特殊的阻塞方法 <code>get()</code>，它返回 Callable 任务执行的实际结果，但如果是 Runnable 任务，则只会返回 null。</p><p>因为 <code>get()</code> 方法是阻塞的。如果调用 <code>get()</code> 方法时任务仍在运行，那么调用将会一直被执阻塞，直到任务正确执行完毕并且结果可用时才返回。</p><p>而且更重要的是，正在被执行的任务随时都可能抛出异常或中断执行。因此我们要将 <code>get()</code> 调用放在 <code>try catch</code> 语句块中，并捕捉 <code>InterruptedException</code> 或 <code>ExecutionException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executorService.submit(callableTask);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>get()</code> 方法是阻塞的，而且并不知道要阻塞多长时间。因此可能导致应用程序的性能降低。如果结果数据并不重要，那么我们可以使用超时机制来避免长时间阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>这个 <code>get()</code> 的重载，第一个参数为超时的时间，第二个参数为时间的单位。上面的实例所表示就的就是等待 200 毫秒。</p><p>注意，这个 <code>get()</code> 重载方法，如果在超时时间内正常结束，那么返回的是 Future 类型的结果，如果超时了还没结束，那么将抛出 TimeoutException 异常。</p><p>除了 get() 方法之外，Future 还提供了其它很多方法，我们将几个重要的方法罗列在此</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">isDone()</td><td align="center">检查已分配的任务是否已处理</td></tr><tr><td align="center">cancel()</td><td align="center">取消任务执行</td></tr><tr><td align="center">isCancelled()</td><td align="center">检查任务是否已取消</td></tr></tbody></table><p>这些方法的使用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isDone</span>      <span class="operator">=</span> future.isDone();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">canceled</span>    <span class="operator">=</span> future.cancel(<span class="literal">true</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCancelled</span> <span class="operator">=</span> future.isCancelled();</span><br></pre></td></tr></table></figure><h2 id="ScheduledExecutorService-接口"><a href="#ScheduledExecutorService-接口" class="headerlink" title="ScheduledExecutorService 接口"></a>ScheduledExecutorService 接口</h2><p><code>ScheduledExecutorService</code> 接口用于在一些预定义的延迟之后运行任务和（ 或 ）定期运行任务。</p><p>同样的，实例化 <code>ScheduledExecutorService</code> 的最佳方式是使用 Executors 类的工厂方法。</p><blockquote><p>Executors 类为很多类都提供了工厂方法，简直就是工厂方法的集大成者。</p></blockquote><p>本章节为了简单起见，我们只使用只有一个线程的 ScheduledExecutorService 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure><p>有了实例之后，事情就好办了，比如，要在固定延迟后安排单个任务的执行，可以使用 ScheduledExecutorService 实例的 <code>scheduled()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; resultFuture = executorService.schedule(callableTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>上面这个实例中的代码在执行 callableTask 之前延迟了一秒钟。</p><p><code>scheduled()</code> 方法有两个重载，分别用于执行 Runnable 任务或 Callable 任务。</p><p>另外，ScheduledExecutorService 实例还提供了另一个重要方法 <code>scheduleAtFixedRate()</code> ，它允许在固定延迟后定期执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; resultFuture = service.scheduleAtFixedRate(runnableTask, <span class="number">100</span>, <span class="number">450</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>上面的代码块将在 100 毫秒的初始延迟后执行任务，之后，它将每 450 毫秒执行相同的任务。</p><p>如果处理器需要更多时间来执行分配的任务，那么可以使用 <code>scheduleAtFixedRate()</code> 方法的 period 参数，ScheduledExecutorService 将等到当前任务完成后再开始下一个任务。</p><p>如果任务迭代之间必须具有固定长度的延迟，那么可以使用 <code>scheduleWithFixedDelay()</code> 方法 。例如，以下代码将保证当前执行结束与另一个执行结束之间的暂停时间为 150 毫秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.scheduleWithFixedDelay(task, <span class="number">100</span>, <span class="number">150</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>根据 <code>scheduleAtFixedRate()</code> 和 <code>scheduleWithFixedDelay()</code> 方法契约，在任务执行期间，如果 ExecutorService 终止了或任务抛出了异常，那么任务将自动结束。</p><h2 id="ExecutorService-或-Fork-Join"><a href="#ExecutorService-或-Fork-Join" class="headerlink" title="ExecutorService 或 Fork/Join"></a>ExecutorService 或 Fork/Join</h2><p>Fork/Join 是 Java 7 提供的新框架，在 Java 7 发布之后，许多开发人员都作出了将 ExecutorService 框架替换为 fork/join 框架的决定。</p><p>但，这并不总是正确的决定。尽管 fork/join 使用起来更加简单且频繁使用时更带来更快的性能，但开发人员对并发执行的控制量也有所减少。</p><p>使用 ExecutorService ，开发人员能够控制生成的线程数以及应由不同线程执行的任务粒度。ExecutorService 的最佳用例是处理独立任务，例如根据 「 一个任务的一个线程 」 方案的事务或请求。</p><p>而相比之下，根据 <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Oracle 文档</a>，fork/join 旨在简化和加速工作，可以将任务递归地分成更小的部分。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>尽管 ExecutorService 相对简单，但仍有一些常见的陷阱。我们罗列于此</p><p>1、保持未使用的 ExecutorService 存活</p><p>本文中对如何关闭 ExecutorService 已经做出了详细解释。</p><p>2、使用固定长度的线程池时设置了错误的线程池容量</p><p>使用 ExecutorService 最重要的一件事，就是确定应用程序有效执行任务所需的线程数</p><ul><li>太大的线程池只会产生不必要的开销，只会创建大多数处于等待模式的线程。</li><li>太少的线程池会让应用程序看起来没有响应，因为队列中的任务等待时间很长。</li></ul><p>3、在取消任务后调用 Future 的 get() 方法</p><p>尝试获取已取消任务的结果将触发 CancellationException 异常。</p><p>4、使用 Future 的 get() 方法意外地阻塞了很长时间</p><p>应该使用超时来避免意外的等待。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Java并发 </tag>
            
            <tag> Executor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
